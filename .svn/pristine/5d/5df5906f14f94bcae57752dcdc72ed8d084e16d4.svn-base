; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\delay.o --depend=..\OBJ\delay.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;55     //SYSCLK:系统时钟
;;;56     void delay_init(u8 SYSCLK)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;57     {
;;;58     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;59     	u32 reload;
;;;60     #endif
;;;61      	SysTick->CTRL&=~(1<<2);	//SYSTICK使用外部时钟源	 
000004  6909              LDR      r1,[r1,#0x10]
000006  f0210104          BIC      r1,r1,#4
00000a  f04f22e0          MOV      r2,#0xe000e000
00000e  6111              STR      r1,[r2,#0x10]
;;;62     	fac_us=SYSCLK/8;		//不论是否使用ucos,fac_us都需要使用
000010  4601              MOV      r1,r0
000012  17c2              ASRS     r2,r0,#31
000014  eb007252          ADD      r2,r0,r2,LSR #29
000018  10d2              ASRS     r2,r2,#3
00001a  4b1f              LDR      r3,|L1.152|
00001c  701a              STRB     r2,[r3,#0]
;;;63     	    
;;;64     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;65     	reload=SYSCLK/8;		//每秒钟的计数次数 单位为K	   
;;;66     	reload*=1000000/OS_TICKS_PER_SEC;//根据OS_TICKS_PER_SEC设定溢出时间
;;;67     							//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;68     	fac_ms=1000/OS_TICKS_PER_SEC;//代表ucos可以延时的最少单位	   
;;;69     	SysTick->CTRL|=1<<1;   	//开启SYSTICK中断
;;;70     	SysTick->LOAD=reload; 	//每1/OS_TICKS_PER_SEC秒中断一次	
;;;71     	SysTick->CTRL|=1<<0;   	//开启SYSTICK    
;;;72     #else
;;;73     	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
00001e  4619              MOV      r1,r3
000020  7809              LDRB     r1,[r1,#0]  ; fac_us
000022  f44f727a          MOV      r2,#0x3e8
000026  4351              MULS     r1,r2,r1
000028  1c9a              ADDS     r2,r3,#2
00002a  8011              STRH     r1,[r2,#0]
;;;74     #endif
;;;75     }								    
00002c  4770              BX       lr
;;;76     
                          ENDP

                  delay_us PROC
;;;118    //nus为要延时的us数.		    								   
;;;119    void delay_us(u32 nus)
00002e  4a1a              LDR      r2,|L1.152|
;;;120    {		
;;;121    	u32 temp;	    	 
;;;122    	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000030  7812              LDRB     r2,[r2,#0]  ; fac_us
000032  4342              MULS     r2,r0,r2
000034  f04f23e0          MOV      r3,#0xe000e000
000038  615a              STR      r2,[r3,#0x14]
;;;123    	SysTick->VAL=0x00;        //清空计数器
00003a  2200              MOVS     r2,#0
00003c  619a              STR      r2,[r3,#0x18]
;;;124    	SysTick->CTRL=0x01 ;      //开始倒数 	 
00003e  2201              MOVS     r2,#1
000040  611a              STR      r2,[r3,#0x10]
;;;125    	do
000042  bf00              NOP      
                  |L1.68|
;;;126    	{
;;;127    		temp=SysTick->CTRL;
000044  f04f22e0          MOV      r2,#0xe000e000
000048  6911              LDR      r1,[r2,#0x10]
;;;128    	}
;;;129    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
00004a  f0110f01          TST      r1,#1
00004e  d002              BEQ      |L1.86|
000050  f4113f80          TST      r1,#0x10000
000054  d0f6              BEQ      |L1.68|
                  |L1.86|
;;;130    	SysTick->CTRL=0x00;       //关闭计数器
000056  2200              MOVS     r2,#0
000058  f04f23e0          MOV      r3,#0xe000e000
00005c  611a              STR      r2,[r3,#0x10]
;;;131    	SysTick->VAL =0X00;       //清空计数器	 
00005e  619a              STR      r2,[r3,#0x18]
;;;132    }
000060  4770              BX       lr
;;;133    //延时nms
                          ENDP

                  delay_ms PROC
;;;138    //对72M条件下,nms<=1864 
;;;139    void delay_ms(u16 nms)
000062  4a0d              LDR      r2,|L1.152|
;;;140    {	 		  	  
;;;141    	u32 temp;		   
;;;142    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
000064  1c92              ADDS     r2,r2,#2
000066  8812              LDRH     r2,[r2,#0]  ; fac_ms
000068  4342              MULS     r2,r0,r2
00006a  f04f23e0          MOV      r3,#0xe000e000
00006e  615a              STR      r2,[r3,#0x14]
;;;143    	SysTick->VAL =0x00;           //清空计数器
000070  2200              MOVS     r2,#0
000072  619a              STR      r2,[r3,#0x18]
;;;144    	SysTick->CTRL=0x01 ;          //开始倒数  
000074  2201              MOVS     r2,#1
000076  611a              STR      r2,[r3,#0x10]
;;;145    	do
000078  bf00              NOP      
                  |L1.122|
;;;146    	{
;;;147    		temp=SysTick->CTRL;
00007a  f04f22e0          MOV      r2,#0xe000e000
00007e  6911              LDR      r1,[r2,#0x10]
;;;148    	}
;;;149    	while((temp&0x01)&&!(temp&(1<<16)));//等待时间到达   
000080  f0110f01          TST      r1,#1
000084  d002              BEQ      |L1.140|
000086  f4113f80          TST      r1,#0x10000
00008a  d0f6              BEQ      |L1.122|
                  |L1.140|
;;;150    	SysTick->CTRL=0x00;       //关闭计数器
00008c  2200              MOVS     r2,#0
00008e  f04f23e0          MOV      r3,#0xe000e000
000092  611a              STR      r2,[r3,#0x10]
;;;151    	SysTick->VAL =0X00;       //清空计数器	  	    
000094  619a              STR      r2,[r3,#0x18]
;;;152    } 
000096  4770              BX       lr
;;;153    #endif
                          ENDP

                  |L1.152|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
