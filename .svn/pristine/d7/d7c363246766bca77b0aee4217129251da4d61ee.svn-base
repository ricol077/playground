; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\usart.o --depend=..\OBJ\usart.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;52     //定义_sys_exit()以避免使用半主机模式    
;;;53     _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;54     { 
;;;55     	x = x; 
000002  bf00              NOP      
;;;56     } 
000004  4770              BX       lr
;;;57     //重定义fputc函数 
                          ENDP

                  fputc PROC
;;;58     int fputc(int ch, FILE *f)
000006  bf00              NOP      
                  |L1.8|
;;;59     {      
;;;60     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000008  4a65              LDR      r2,|L1.416|
00000a  8812              LDRH     r2,[r2,#0]
00000c  f0120f40          TST      r2,#0x40
000010  d0fa              BEQ      |L1.8|
;;;61     	USART1->DR = (u8) ch;      
000012  b2c2              UXTB     r2,r0
000014  4b62              LDR      r3,|L1.416|
000016  1d1b              ADDS     r3,r3,#4
000018  801a              STRH     r2,[r3,#0]
;;;62     	return ch;
;;;63     }
00001a  4770              BX       lr
;;;64     #endif 
                          ENDP

                  USART1_IRQHandler PROC
;;;83     
;;;84     void USART1_IRQHandler(void)
00001c  4960              LDR      r1,|L1.416|
;;;85     {
;;;86     	u8 res;	
;;;87     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;88     	OSIntEnter();    
;;;89     #endif
;;;90     	if(USART1->SR&(1<<5))//接收到数据
00001e  8809              LDRH     r1,[r1,#0]
000020  f0110f20          TST      r1,#0x20
000024  d04a              BEQ      |L1.188|
;;;91     	{	
;;;92     
;;;93     		res=USART1->DR; 
000026  495e              LDR      r1,|L1.416|
000028  1d09              ADDS     r1,r1,#4
00002a  8809              LDRH     r1,[r1,#0]
00002c  b2c8              UXTB     r0,r1
;;;94     		/*
;;;95     		if((USART_RX_STA&0x8000)==0)//接收未完成
;;;96     		{
;;;97     			if(USART_RX_STA&0x4000)//接收到了0x0d
;;;98     			{
;;;99     				if(res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
;;;100    				else USART_RX_STA|=0x8000;	//接收完成了 
;;;101    			}else //还没收到0X0D
;;;102    			{	
;;;103    				if(res==0x0d)USART_RX_STA|=0x4000;
;;;104    				else
;;;105    				{
;;;106    					USART_RX_BUF[USART_RX_STA&0X3FFF]=res;
;;;107    					USART_RX_STA++;
;;;108    					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
;;;109    				}		 
;;;110    			}
;;;111    		} 
;;;112    	*/
;;;113    	 if(RxStage==IDLE)
00002e  495d              LDR      r1,|L1.420|
000030  7809              LDRB     r1,[r1,#0]  ; RxStage
000032  b951              CBNZ     r1,|L1.74|
;;;114    	 {
;;;115    	 	RxIdx=0;
000034  2100              MOVS     r1,#0
000036  4a5c              LDR      r2,|L1.424|
000038  7011              STRB     r1,[r2,#0]
;;;116    	 	if(res==HEADER)
00003a  28aa              CMP      r0,#0xaa
00003c  d13e              BNE      |L1.188|
;;;117    		{
;;;118    			RxBuffer[0]= res;
00003e  495b              LDR      r1,|L1.428|
000040  7008              STRB     r0,[r1,#0]
;;;119    			RxStage= BUSY;
000042  2101              MOVS     r1,#1
000044  4a57              LDR      r2,|L1.420|
000046  7011              STRB     r1,[r2,#0]
000048  e038              B        |L1.188|
                  |L1.74|
;;;120    		}	
;;;121    	 }
;;;122    	 else if(RxStage==BUSY)
00004a  4956              LDR      r1,|L1.420|
00004c  7809              LDRB     r1,[r1,#0]  ; RxStage
00004e  2901              CMP      r1,#1
000050  d11f              BNE      |L1.146|
;;;123    	 	{
;;;124    		  	if(RxIdx < MAX_LIMIT)
000052  4955              LDR      r1,|L1.424|
000054  7809              LDRB     r1,[r1,#0]  ; RxIdx
000056  2940              CMP      r1,#0x40
000058  da15              BGE      |L1.134|
;;;125    		  	{
;;;126    				RxIdx++;
00005a  4953              LDR      r1,|L1.424|
00005c  7809              LDRB     r1,[r1,#0]  ; RxIdx
00005e  1c49              ADDS     r1,r1,#1
000060  4a51              LDR      r2,|L1.424|
000062  7011              STRB     r1,[r2,#0]
;;;127    				RxBuffer[RxIdx]= res;
000064  4951              LDR      r1,|L1.428|
000066  7812              LDRB     r2,[r2,#0]  ; RxIdx
000068  5488              STRB     r0,[r1,r2]
;;;128    
;;;129    				if(res==TAIL)	
00006a  2817              CMP      r0,#0x17
00006c  d102              BNE      |L1.116|
;;;130    					RxStage=END;
00006e  2102              MOVS     r1,#2
000070  4a4c              LDR      r2,|L1.420|
000072  7011              STRB     r1,[r2,#0]
                  |L1.116|
;;;131    				if(RxIdx==5)
000074  494c              LDR      r1,|L1.424|
000076  7809              LDRB     r1,[r1,#0]  ; RxIdx
000078  2905              CMP      r1,#5
00007a  d11f              BNE      |L1.188|
;;;132    					RxIdx=RxIdx;	
00007c  494a              LDR      r1,|L1.424|
00007e  7809              LDRB     r1,[r1,#0]  ; RxIdx
000080  4a49              LDR      r2,|L1.424|
000082  7011              STRB     r1,[r2,#0]
000084  e01a              B        |L1.188|
                  |L1.134|
;;;133    			}
;;;134    			else
;;;135    			{
;;;136    			 	RxStage=IDLE;
000086  2100              MOVS     r1,#0
000088  4a46              LDR      r2,|L1.420|
00008a  7011              STRB     r1,[r2,#0]
;;;137    				RxIdx=0;
00008c  4a46              LDR      r2,|L1.424|
00008e  7011              STRB     r1,[r2,#0]
000090  e014              B        |L1.188|
                  |L1.146|
;;;138    			}
;;;139    		}else if(RxStage==END)
000092  4944              LDR      r1,|L1.420|
000094  7809              LDRB     r1,[r1,#0]  ; RxStage
000096  2902              CMP      r1,#2
000098  d110              BNE      |L1.188|
;;;140    				{
;;;141    					RxIdx++;
00009a  4943              LDR      r1,|L1.424|
00009c  7809              LDRB     r1,[r1,#0]  ; RxIdx
00009e  1c49              ADDS     r1,r1,#1
0000a0  4a41              LDR      r2,|L1.424|
0000a2  7011              STRB     r1,[r2,#0]
;;;142    					RxBuffer[RxIdx]= res;
0000a4  4941              LDR      r1,|L1.428|
0000a6  7812              LDRB     r2,[r2,#0]  ; RxIdx
0000a8  5488              STRB     r0,[r1,r2]
;;;143    				   	if(res==TAIL)
0000aa  2817              CMP      r0,#0x17
0000ac  d103              BNE      |L1.182|
;;;144    				   		RxStage=CMPLT;
0000ae  2103              MOVS     r1,#3
0000b0  4a3c              LDR      r2,|L1.420|
0000b2  7011              STRB     r1,[r2,#0]
0000b4  e002              B        |L1.188|
                  |L1.182|
;;;145    				   	else
;;;146    					    RxStage=BUSY;				
0000b6  2101              MOVS     r1,#1
0000b8  4a3a              LDR      r2,|L1.420|
0000ba  7011              STRB     r1,[r2,#0]
                  |L1.188|
;;;147    				}
;;;148    	 		 									     
;;;149    	}
;;;150    #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;151    	OSIntExit();  											 
;;;152    #endif
;;;153    } 
0000bc  4770              BX       lr
;;;154    #endif										 
                          ENDP

                  uart_init PROC
;;;159    //091209
;;;160    void uart_init(u32 pclk2,u32 bound)
0000be  e92d5ff0          PUSH     {r4-r12,lr}
;;;161    {  	 
0000c2  4604              MOV      r4,r0
0000c4  460d              MOV      r5,r1
;;;162    	float temp;
;;;163    	u16 mantissa;
;;;164    	u16 fraction;	   
;;;165    	temp=(float)(pclk2*1000000)/(bound*16);//得到USARTDIV
0000c6  0128              LSLS     r0,r5,#4
0000c8  f7fffffe          BL       __aeabi_ui2f
0000cc  4681              MOV      r9,r0
0000ce  4938              LDR      r1,|L1.432|
0000d0  fb04f001          MUL      r0,r4,r1
0000d4  f7fffffe          BL       __aeabi_ui2f
0000d8  4682              MOV      r10,r0
0000da  4649              MOV      r1,r9
0000dc  f7fffffe          BL       __aeabi_fdiv
0000e0  4606              MOV      r6,r0
;;;166    	mantissa=temp;				 //得到整数部分
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       __aeabi_f2uiz
0000e8  b287              UXTH     r7,r0
;;;167    	fraction=(temp-mantissa)*16; //得到小数部分	 
0000ea  4638              MOV      r0,r7
0000ec  f7fffffe          BL       __aeabi_ui2f
0000f0  4683              MOV      r11,r0
0000f2  4631              MOV      r1,r6
0000f4  f7fffffe          BL       __aeabi_frsub
0000f8  4682              MOV      r10,r0
0000fa  f04f4183          MOV      r1,#0x41800000
0000fe  f7fffffe          BL       __aeabi_fmul
000102  4681              MOV      r9,r0
000104  f7fffffe          BL       __aeabi_f2uiz
000108  4680              MOV      r8,r0
;;;168        mantissa<<=4;
00010a  013f              LSLS     r7,r7,#4
;;;169    	mantissa+=fraction; 
00010c  eb070008          ADD      r0,r7,r8
000110  b287              UXTH     r7,r0
;;;170    	RCC->APB2ENR|=1<<2;   //使能PORTA口时钟  
000112  4828              LDR      r0,|L1.436|
000114  6980              LDR      r0,[r0,#0x18]
000116  f0400004          ORR      r0,r0,#4
00011a  4926              LDR      r1,|L1.436|
00011c  6188              STR      r0,[r1,#0x18]
;;;171    	RCC->APB2ENR|=1<<14;  //使能串口时钟 
00011e  4608              MOV      r0,r1
000120  6980              LDR      r0,[r0,#0x18]
000122  f4404080          ORR      r0,r0,#0x4000
000126  6188              STR      r0,[r1,#0x18]
;;;172    	GPIOA->CRH&=0XFFFFF00F;//IO状态设置
000128  4823              LDR      r0,|L1.440|
00012a  6800              LDR      r0,[r0,#0]
00012c  f420607f          BIC      r0,r0,#0xff0
000130  4922              LDR      r1,|L1.444|
000132  f8c10804          STR      r0,[r1,#0x804]
;;;173    	GPIOA->CRH|=0X000008B0;//IO状态设置
000136  4608              MOV      r0,r1
000138  f8d00804          LDR      r0,[r0,#0x804]
00013c  f440600b          ORR      r0,r0,#0x8b0
000140  f8c10804          STR      r0,[r1,#0x804]
;;;174    		  
;;;175    	RCC->APB2RSTR|=1<<14;   //复位串口1
000144  481b              LDR      r0,|L1.436|
000146  68c0              LDR      r0,[r0,#0xc]
000148  f4404080          ORR      r0,r0,#0x4000
00014c  4919              LDR      r1,|L1.436|
00014e  60c8              STR      r0,[r1,#0xc]
;;;176    	RCC->APB2RSTR&=~(1<<14);//停止复位	   	   
000150  4608              MOV      r0,r1
000152  68c0              LDR      r0,[r0,#0xc]
000154  f4204080          BIC      r0,r0,#0x4000
000158  60c8              STR      r0,[r1,#0xc]
;;;177    	//波特率设置
;;;178     	USART1->BRR=mantissa; // 波特率设置	 
00015a  4819              LDR      r0,|L1.448|
00015c  f8a07808          STRH     r7,[r0,#0x808]
;;;179    	USART1->CR1|=0X200C;  //1位停止,无校验位.
000160  480f              LDR      r0,|L1.416|
000162  300c              ADDS     r0,r0,#0xc
000164  8800              LDRH     r0,[r0,#0]
000166  f242010c          MOV      r1,#0x200c
00016a  4308              ORRS     r0,r0,r1
00016c  4914              LDR      r1,|L1.448|
00016e  f8a1080c          STRH     r0,[r1,#0x80c]
;;;180    #if EN_USART1_RX		  //如果使能了接收
;;;181    	//使能接收中断
;;;182    	USART1->CR1|=1<<8;    //PE中断使能
000172  4608              MOV      r0,r1
000174  f8b0080c          LDRH     r0,[r0,#0x80c]
000178  f4407080          ORR      r0,r0,#0x100
00017c  f8a1080c          STRH     r0,[r1,#0x80c]
;;;183    	USART1->CR1|=1<<5;    //接收缓冲区非空中断使能	    	
000180  4608              MOV      r0,r1
000182  f8b0080c          LDRH     r0,[r0,#0x80c]
000186  f0400020          ORR      r0,r0,#0x20
00018a  4905              LDR      r1,|L1.416|
00018c  310c              ADDS     r1,r1,#0xc
00018e  8008              STRH     r0,[r1,#0]
;;;184    	MY_NVIC_Init(3,3,USART1_IRQChannel,2);//组2，最低优先级 
000190  2302              MOVS     r3,#2
000192  2225              MOVS     r2,#0x25
000194  2103              MOVS     r1,#3
000196  4608              MOV      r0,r1
000198  f7fffffe          BL       MY_NVIC_Init
;;;185    #endif
;;;186    }
00019c  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

                  |L1.416|
                          DCD      0x40013800
                  |L1.420|
                          DCD      RxStage
                  |L1.424|
                          DCD      RxIdx
                  |L1.428|
                          DCD      RxBuffer
                  |L1.432|
                          DCD      0x000f4240
                  |L1.436|
                          DCD      0x40021000
                  |L1.440|
                          DCD      0x40010804
                  |L1.444|
                          DCD      0x40010000
                  |L1.448|
                          DCD      0x40013000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  RxBuffer
                          %        64
                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  USART_RX_STA
000000  0000              DCW      0x0000
                  RxIdx
000002  00                DCB      0x00
                  RxStage
000003  00                DCB      0x00
                  __stdout
                          DCD      0x00000000
