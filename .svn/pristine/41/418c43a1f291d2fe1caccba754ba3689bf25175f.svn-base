; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\adc.o --depend=..\OBJ\adc.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\adc.crf ..\HARDWARE\ADC\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Adc_Init PROC
;;;21     //我们默认仅开启通道1																	   
;;;22     void  Adc_Init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;23     {    
;;;24     	//先初始化IO口
;;;25      	RCC->APB2ENR|=1<<2;    //使能PORTA口时钟 
000002  4881              LDR      r0,|L1.520|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400004          ORR      r0,r0,#4
00000a  497f              LDR      r1,|L1.520|
00000c  6188              STR      r0,[r1,#0x18]
;;;26     	GPIOA->CRL&=0XFFFF000F;//PA1,2,3 anolog输入
00000e  487f              LDR      r0,|L1.524|
000010  6800              LDR      r0,[r0,#0]
000012  f64f71f0          MOV      r1,#0xfff0
000016  4388              BICS     r0,r0,r1
000018  497d              LDR      r1,|L1.528|
00001a  f8c10800          STR      r0,[r1,#0x800]
;;;27     
;;;28      	RCC->APB2ENR|=1<<4;    //使能PORTC口时钟 
00001e  487a              LDR      r0,|L1.520|
000020  6980              LDR      r0,[r0,#0x18]
000022  f0400010          ORR      r0,r0,#0x10
000026  4978              LDR      r1,|L1.520|
000028  6188              STR      r0,[r1,#0x18]
;;;29     	GPIOC->CRL&=0XFF00FFFFF;//PC4,5 anolog输入
00002a  497a              LDR      r1,|L1.532|
00002c  6808              LDR      r0,[r1,#0]
00002e  2100              MOVS     r1,#0
000030  e9cd0102          STRD     r0,r1,[sp,#8]
000034  a478              ADR      r4,|L1.536|
000036  9a03              LDR      r2,[sp,#0xc]
000038  cc18              LDM      r4,{r3,r4}
00003a  ea000103          AND      r1,r0,r3
00003e  4022              ANDS     r2,r2,r4
000040  e9cd1200          STRD     r1,r2,[sp,#0]
000044  4a73              LDR      r2,|L1.532|
000046  6011              STR      r1,[r2,#0]
;;;30     
;;;31     	//通道10/11设置			 
;;;32     	RCC->APB2ENR|=1<<9;    //ADC1时钟使能	  
000048  486f              LDR      r0,|L1.520|
00004a  6980              LDR      r0,[r0,#0x18]
00004c  f4407000          ORR      r0,r0,#0x200
000050  496d              LDR      r1,|L1.520|
000052  6188              STR      r0,[r1,#0x18]
;;;33     	RCC->APB2RSTR|=1<<9;   //ADC1复位
000054  4608              MOV      r0,r1
000056  68c0              LDR      r0,[r0,#0xc]
000058  f4407000          ORR      r0,r0,#0x200
00005c  60c8              STR      r0,[r1,#0xc]
;;;34     	RCC->APB2RSTR&=~(1<<9);//复位结束	    
00005e  4608              MOV      r0,r1
000060  68c0              LDR      r0,[r0,#0xc]
000062  f4207000          BIC      r0,r0,#0x200
000066  60c8              STR      r0,[r1,#0xc]
;;;35     	RCC->CFGR&=~(3<<14);   //分频因子清零	
000068  4608              MOV      r0,r1
00006a  6840              LDR      r0,[r0,#4]
00006c  f4204040          BIC      r0,r0,#0xc000
000070  6048              STR      r0,[r1,#4]
;;;36     	//SYSCLK/DIV2=12M ADC时钟设置为12M,ADC最大时钟不能超过14M!
;;;37     	//否则将导致ADC准确度下降! 
;;;38     	RCC->CFGR|=1<<14;      // ADC clock prescale to 32M/4	 
000072  4608              MOV      r0,r1
000074  6840              LDR      r0,[r0,#4]
000076  f4404080          ORR      r0,r0,#0x4000
00007a  6048              STR      r0,[r1,#4]
;;;39     	ADC1->CR1&=0XF0FFFF;   //工作模式清零
00007c  4868              LDR      r0,|L1.544|
00007e  6800              LDR      r0,[r0,#0]
000080  4968              LDR      r1,|L1.548|
000082  4008              ANDS     r0,r0,r1
000084  4968              LDR      r1,|L1.552|
000086  f8c10404          STR      r0,[r1,#0x404]
;;;40     	ADC1->CR1&=~(0xf<<16);      //独立工作模式  
00008a  4608              MOV      r0,r1
00008c  f8d00404          LDR      r0,[r0,#0x404]
000090  f4202070          BIC      r0,r0,#0xf0000
000094  f8c10404          STR      r0,[r1,#0x404]
;;;41     	ADC1->CR1&=~(1<<8);    //非扫描模式	  
000098  4608              MOV      r0,r1
00009a  f8d00404          LDR      r0,[r0,#0x404]
00009e  f4207080          BIC      r0,r0,#0x100
0000a2  f8c10404          STR      r0,[r1,#0x404]
;;;42     	ADC1->CR2&=~(1<<1);    //单次转换模式
0000a6  4608              MOV      r0,r1
0000a8  f8d00408          LDR      r0,[r0,#0x408]
0000ac  f0200002          BIC      r0,r0,#2
0000b0  f8c10408          STR      r0,[r1,#0x408]
;;;43     	ADC1->CR2&=~(7<<17);	   
0000b4  4608              MOV      r0,r1
0000b6  f8d00408          LDR      r0,[r0,#0x408]
0000ba  f4202060          BIC      r0,r0,#0xe0000
0000be  f8c10408          STR      r0,[r1,#0x408]
;;;44     	ADC1->CR2|=7<<17;	   //软件控制转换  
0000c2  4608              MOV      r0,r1
0000c4  f8d00408          LDR      r0,[r0,#0x408]
0000c8  f4402060          ORR      r0,r0,#0xe0000
0000cc  f8c10408          STR      r0,[r1,#0x408]
;;;45     	ADC1->CR2|=1<<20;      //使用用外部触发(SWSTART)!!!	必须使用一个事件来触发
0000d0  4608              MOV      r0,r1
0000d2  f8d00408          LDR      r0,[r0,#0x408]
0000d6  f4401080          ORR      r0,r0,#0x100000
0000da  f8c10408          STR      r0,[r1,#0x408]
;;;46     	ADC1->CR2&=~(1<<11);   //右对齐	 
0000de  4608              MOV      r0,r1
0000e0  f8d00408          LDR      r0,[r0,#0x408]
0000e4  f4206000          BIC      r0,r0,#0x800
0000e8  f8c10408          STR      r0,[r1,#0x408]
;;;47     	ADC1->CR2|=1<<23;      //使能温度传感器
0000ec  4608              MOV      r0,r1
0000ee  f8d00408          LDR      r0,[r0,#0x408]
0000f2  f4400000          ORR      r0,r0,#0x800000
0000f6  f8c10408          STR      r0,[r1,#0x408]
;;;48     
;;;49     	ADC1->SQR1&=~(0XF<<20);
0000fa  4608              MOV      r0,r1
0000fc  f8d0042c          LDR      r0,[r0,#0x42c]
000100  f4200070          BIC      r0,r0,#0xf00000
000104  f8c1042c          STR      r0,[r1,#0x42c]
;;;50     	ADC1->SQR1&=0<<20;     //1个转换在规则序列中 也就是只转换规则序列1 			   
000108  4608              MOV      r0,r1
00010a  f8d0042c          LDR      r0,[r0,#0x42c]
00010e  2000              MOVS     r0,#0
000110  f8c1042c          STR      r0,[r1,#0x42c]
;;;51     	//设置通道1的采样时间
;;;52     	ADC1->SMPR2&=~(7<<3);  //通道1采样时间清空	  
000114  4608              MOV      r0,r1
000116  f8d00410          LDR      r0,[r0,#0x410]
00011a  f0200038          BIC      r0,r0,#0x38
00011e  f8c10410          STR      r0,[r1,#0x410]
;;;53      	ADC1->SMPR2|=7<<3;     //通道1  239.5周期,提高采样时间可以提高精确度	 
000122  4608              MOV      r0,r1
000124  f8d00410          LDR      r0,[r0,#0x410]
000128  f0400038          ORR      r0,r0,#0x38
00012c  f8c10410          STR      r0,[r1,#0x410]
;;;54     
;;;55      	ADC1->SMPR1&=~(7<<18);  //清除通道16原来的设置	 
000130  4608              MOV      r0,r1
000132  f8d0040c          LDR      r0,[r0,#0x40c]
000136  f42010e0          BIC      r0,r0,#0x1c0000
00013a  f8c1040c          STR      r0,[r1,#0x40c]
;;;56     	ADC1->SMPR1|=7<<18;     //通道16  239.5周期,提高采样时间可以提高精确度	 
00013e  4608              MOV      r0,r1
000140  f8d0040c          LDR      r0,[r0,#0x40c]
000144  f44010e0          ORR      r0,r0,#0x1c0000
000148  f8c1040c          STR      r0,[r1,#0x40c]
;;;57     
;;;58     	ADC1->CR2|=1<<0;	   //开启AD转换器	 
00014c  4608              MOV      r0,r1
00014e  f8d00408          LDR      r0,[r0,#0x408]
000152  f0400001          ORR      r0,r0,#1
000156  f8c10408          STR      r0,[r1,#0x408]
;;;59     	ADC1->CR2|=1<<3;       //使能复位校准  
00015a  4608              MOV      r0,r1
00015c  f8d00408          LDR      r0,[r0,#0x408]
000160  f0400008          ORR      r0,r0,#8
000164  f8c10408          STR      r0,[r1,#0x408]
;;;60     	while(ADC1->CR2&1<<3); //等待校准结束 			 
000168  bf00              NOP      
                  |L1.362|
00016a  482d              LDR      r0,|L1.544|
00016c  1d00              ADDS     r0,r0,#4
00016e  6800              LDR      r0,[r0,#0]
000170  f0100f08          TST      r0,#8
000174  d1f9              BNE      |L1.362|
;;;61         //该位由软件设置并由硬件清除。在校准寄存器被初始化后该位将被清除。 		 
;;;62     	ADC1->CR2|=1<<2;        //开启AD校准	   
000176  482a              LDR      r0,|L1.544|
000178  1d00              ADDS     r0,r0,#4
00017a  6800              LDR      r0,[r0,#0]
00017c  f0400004          ORR      r0,r0,#4
000180  4929              LDR      r1,|L1.552|
000182  f8c10408          STR      r0,[r1,#0x408]
;;;63     	while(ADC1->CR2&1<<2);  //等待校准结束
000186  bf00              NOP      
                  |L1.392|
000188  4825              LDR      r0,|L1.544|
00018a  1d00              ADDS     r0,r0,#4
00018c  6800              LDR      r0,[r0,#0]
00018e  f0100f04          TST      r0,#4
000192  d1f9              BNE      |L1.392|
;;;64     	//该位由软件设置以开始校准，并在校准结束时由硬件清除  
;;;65     }				  
000194  bd1f              POP      {r0-r4,pc}
;;;66     //获得ADC值
                          ENDP

                  Get_Adc PROC
;;;68     //返回值:转换结果
;;;69     u16 Get_Adc(u8 ch)   
000196  4601              MOV      r1,r0
;;;70     {
;;;71     	//设置转换序列	  		 
;;;72     	ADC1->SQR3&=0XFFFFFFE0;//规则序列1 通道ch
000198  4821              LDR      r0,|L1.544|
00019a  3030              ADDS     r0,r0,#0x30
00019c  6800              LDR      r0,[r0,#0]
00019e  f020001f          BIC      r0,r0,#0x1f
0001a2  4a21              LDR      r2,|L1.552|
0001a4  f8c20434          STR      r0,[r2,#0x434]
;;;73     	ADC1->SQR3|=ch;		  			    
0001a8  4610              MOV      r0,r2
0001aa  f8d00434          LDR      r0,[r0,#0x434]
0001ae  4308              ORRS     r0,r0,r1
0001b0  f8c20434          STR      r0,[r2,#0x434]
;;;74     	ADC1->CR2|=1<<22;       //启动规则转换通道 
0001b4  4610              MOV      r0,r2
0001b6  f8d00408          LDR      r0,[r0,#0x408]
0001ba  f4400080          ORR      r0,r0,#0x400000
0001be  f8c20408          STR      r0,[r2,#0x408]
;;;75     	while(!(ADC1->SR&1<<1));//等待转换结束	 	   
0001c2  bf00              NOP      
                  |L1.452|
0001c4  4816              LDR      r0,|L1.544|
0001c6  1f00              SUBS     r0,r0,#4
0001c8  6800              LDR      r0,[r0,#0]
0001ca  f0100f02          TST      r0,#2
0001ce  d0f9              BEQ      |L1.452|
;;;76     	return ADC1->DR;		//返回adc值	
0001d0  4813              LDR      r0,|L1.544|
0001d2  3048              ADDS     r0,r0,#0x48
0001d4  6800              LDR      r0,[r0,#0]
0001d6  b280              UXTH     r0,r0
;;;77     }
0001d8  4770              BX       lr
;;;78     //获取通道ch的转换值，取times次,然后平均 
                          ENDP

                  Get_Adc_Average PROC
;;;81     //返回值:通道ch的times次转换结果平均值
;;;82     u16 Get_Adc_Average(u8 ch,u8 times)
0001da  e92d41f0          PUSH     {r4-r8,lr}
;;;83     {
0001de  4604              MOV      r4,r0
0001e0  460d              MOV      r5,r1
;;;84     	u32 temp_val=0;
0001e2  2600              MOVS     r6,#0
;;;85     	u8 t;
;;;86     	for(t=0;t<times;t++)
0001e4  2700              MOVS     r7,#0
0001e6  e008              B        |L1.506|
                  |L1.488|
;;;87     	{
;;;88     		temp_val+=Get_Adc(ch);
0001e8  4620              MOV      r0,r4
0001ea  f7fffffe          BL       Get_Adc
0001ee  4406              ADD      r6,r6,r0
;;;89     		delay_ms(5);
0001f0  2005              MOVS     r0,#5
0001f2  f7fffffe          BL       delay_ms
0001f6  1c78              ADDS     r0,r7,#1              ;86
0001f8  b2c7              UXTB     r7,r0                 ;86
                  |L1.506|
0001fa  42af              CMP      r7,r5                 ;86
0001fc  dbf4              BLT      |L1.488|
;;;90     	}
;;;91     	return temp_val/times;
0001fe  fbb6f0f5          UDIV     r0,r6,r5
000202  b280              UXTH     r0,r0
;;;92     } 
000204  e8bd81f0          POP      {r4-r8,pc}
;;;93     	 
                          ENDP

                  |L1.520|
                          DCD      0x40021000
                  |L1.524|
                          DCD      0x40010800
                  |L1.528|
                          DCD      0x40010000
                  |L1.532|
                          DCD      0x40011000
                  |L1.536|
000218  f00fffff
00021c  0000000f          DCQ      0x0000000ff00fffff
                  |L1.544|
                          DCD      0x40012404
                  |L1.548|
                          DCD      0x00f0ffff
                  |L1.552|
                          DCD      0x40012000
