; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\sys.o --depend=..\OBJ\sys.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\sys.crf ..\SYSTEM\sys\sys.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  MY_NVIC_SetVectorTable PROC
;;;30     //Offset:偏移量			 
;;;31     void MY_NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)	 
000000  4aac              LDR      r2,|L1.692|
;;;32     { 	   	 
;;;33     	SCB->VTOR = NVIC_VectTab|(Offset & (u32)0x1FFFFF80);//设置NVIC的向量表偏移寄存器
000002  400a              ANDS     r2,r2,r1
000004  4302              ORRS     r2,r2,r0
000006  4bac              LDR      r3,|L1.696|
000008  601a              STR      r2,[r3,#0]
;;;34     	//用于标识向量表是在CODE区还是在RAM区
;;;35     }
00000a  4770              BX       lr
;;;36     //设置NVIC分组
                          ENDP

                  MY_NVIC_PriorityGroupConfig PROC
;;;37     //NVIC_Group:NVIC分组 0~4 总共5组 		   
;;;38     void MY_NVIC_PriorityGroupConfig(u8 NVIC_Group)	 
00000c  2307              MOVS     r3,#7
;;;39     { 
;;;40     	u32 temp,temp1;	  
;;;41     	temp1=(~NVIC_Group)&0x07;//取后三位
00000e  ea230200          BIC      r2,r3,r0
;;;42     	temp1<<=8;
000012  0212              LSLS     r2,r2,#8
;;;43     	temp=SCB->AIRCR;  //读取先前的设置
000014  4ba8              LDR      r3,|L1.696|
000016  1d1b              ADDS     r3,r3,#4
000018  6819              LDR      r1,[r3,#0]
;;;44     	temp&=0X0000F8FF; //清空先前分组
00001a  f64f03ff          MOV      r3,#0xf8ff
00001e  4019              ANDS     r1,r1,r3
;;;45     	temp|=0X05FA0000; //写入钥匙
000020  4ba6              LDR      r3,|L1.700|
000022  4319              ORRS     r1,r1,r3
;;;46     	temp|=temp1;	   
000024  4311              ORRS     r1,r1,r2
;;;47     	SCB->AIRCR=temp;  //设置分组	    	  				   
000026  f04f23e0          MOV      r3,#0xe000e000
00002a  f8c31d0c          STR      r1,[r3,#0xd0c]
;;;48     }
00002e  4770              BX       lr
;;;49     //设置NVIC 
                          ENDP

                  MY_NVIC_Init PROC
;;;61     //NVIC_SubPriority和NVIC_PreemptionPriority的原则是,数值越小,越优先	   
;;;62     void MY_NVIC_Init(u8 NVIC_PreemptionPriority,u8 NVIC_SubPriority,u8 NVIC_Channel,u8 NVIC_Group)	 
000030  e92d47f0          PUSH     {r4-r10,lr}
;;;63     { 
000034  4604              MOV      r4,r0
000036  460d              MOV      r5,r1
000038  4616              MOV      r6,r2
00003a  461f              MOV      r7,r3
;;;64     	u32 temp;	
;;;65     	u8 IPRADDR=NVIC_Channel/4;  //每组只能存4个,得到组地址 
00003c  4630              MOV      r0,r6
00003e  17f1              ASRS     r1,r6,#31
000040  eb067191          ADD      r1,r6,r1,LSR #30
000044  ea4f09a1          ASR      r9,r1,#2
;;;66     	u8 IPROFFSET=NVIC_Channel%4;//在组内的偏移
000048  17f1              ASRS     r1,r6,#31
00004a  eb067191          ADD      r1,r6,r1,LSR #30
00004e  1089              ASRS     r1,r1,#2
000050  eba60181          SUB      r1,r6,r1,LSL #2
000054  f0010aff          AND      r10,r1,#0xff
;;;67     	IPROFFSET=IPROFFSET*8+4;    //得到偏移的确切位置
000058  2104              MOVS     r1,#4
00005a  eb0100ca          ADD      r0,r1,r10,LSL #3
00005e  f0000aff          AND      r10,r0,#0xff
;;;68     	MY_NVIC_PriorityGroupConfig(NVIC_Group);//设置分组
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       MY_NVIC_PriorityGroupConfig
;;;69     	temp=NVIC_PreemptionPriority<<(4-NVIC_Group);	  
000068  f1c70004          RSB      r0,r7,#4
00006c  fa04f800          LSL      r8,r4,r0
;;;70     	temp|=NVIC_SubPriority&(0x0f>>NVIC_Group);
000070  200f              MOVS     r0,#0xf
000072  4138              ASRS     r0,r0,r7
000074  4028              ANDS     r0,r0,r5
000076  ea400808          ORR      r8,r0,r8
;;;71     	temp&=0xf;//取低四位
00007a  f008080f          AND      r8,r8,#0xf
;;;72     
;;;73     	if(NVIC_Channel<32)NVIC->ISER[0]|=1<<NVIC_Channel;//使能中断位(要清除的话,相反操作就OK)
00007e  2e20              CMP      r6,#0x20
000080  da09              BGE      |L1.150|
000082  488f              LDR      r0,|L1.704|
000084  6800              LDR      r0,[r0,#0]
000086  2101              MOVS     r1,#1
000088  40b1              LSLS     r1,r1,r6
00008a  4308              ORRS     r0,r0,r1
00008c  f04f21e0          MOV      r1,#0xe000e000
000090  f8c10100          STR      r0,[r1,#0x100]
000094  e00b              B        |L1.174|
                  |L1.150|
;;;74     	else NVIC->ISER[1]|=1<<(NVIC_Channel-32);    
000096  488a              LDR      r0,|L1.704|
000098  1d00              ADDS     r0,r0,#4
00009a  6801              LDR      r1,[r0,#0]
00009c  f1a60220          SUB      r2,r6,#0x20
0000a0  2001              MOVS     r0,#1
0000a2  4090              LSLS     r0,r0,r2
0000a4  4301              ORRS     r1,r1,r0
0000a6  f04f20e0          MOV      r0,#0xe000e000
0000aa  f8c01104          STR      r1,[r0,#0x104]
                  |L1.174|
;;;75     	NVIC->IPR[IPRADDR]|=temp<<IPROFFSET;//设置响应优先级和抢断优先级   	    	  				   
0000ae  4885              LDR      r0,|L1.708|
0000b0  f8500029          LDR      r0,[r0,r9,LSL #2]
0000b4  fa08f10a          LSL      r1,r8,r10
0000b8  4301              ORRS     r1,r1,r0
0000ba  4882              LDR      r0,|L1.708|
0000bc  f8401029          STR      r1,[r0,r9,LSL #2]
;;;76     }
0000c0  e8bd87f0          POP      {r4-r10,pc}
;;;77     
                          ENDP

                  Ex_NVIC_Config PROC
;;;85     //该函数会自动开启对应中断,以及屏蔽线   	    
;;;86     void Ex_NVIC_Config(u8 GPIOx,u8 BITx,u8 TRIM) 
0000c4  b570              PUSH     {r4-r6,lr}
;;;87     {
;;;88     	u8 EXTADDR;
;;;89     	u8 EXTOFFSET;
;;;90     	EXTADDR=BITx/4;//得到中断寄存器组的编号
0000c6  460d              MOV      r5,r1
0000c8  17ce              ASRS     r6,r1,#31
0000ca  eb017696          ADD      r6,r1,r6,LSR #30
0000ce  10b3              ASRS     r3,r6,#2
;;;91     	EXTOFFSET=(BITx%4)*4;
0000d0  17ce              ASRS     r6,r1,#31
0000d2  eb017696          ADD      r6,r1,r6,LSR #30
0000d6  10b6              ASRS     r6,r6,#2
0000d8  eba10686          SUB      r6,r1,r6,LSL #2
0000dc  06b6              LSLS     r6,r6,#26
0000de  0e34              LSRS     r4,r6,#24
;;;92     						   
;;;93     	RCC->APB2ENR|=0x01;//使能io复用时钟
0000e0  4d79              LDR      r5,|L1.712|
0000e2  69ad              LDR      r5,[r5,#0x18]
0000e4  f0450501          ORR      r5,r5,#1
0000e8  4e77              LDR      r6,|L1.712|
0000ea  61b5              STR      r5,[r6,#0x18]
;;;94     
;;;95     	AFIO->EXTICR[EXTADDR]&=~(0x000F<<EXTOFFSET);//清除原来设置！！！
0000ec  ea4f35b6          ROR      r5,r6,#14
0000f0  f8556023          LDR      r6,[r5,r3,LSL #2]
0000f4  250f              MOVS     r5,#0xf
0000f6  40a5              LSLS     r5,r5,r4
0000f8  43ae              BICS     r6,r6,r5
0000fa  4d74              LDR      r5,|L1.716|
0000fc  f8456023          STR      r6,[r5,r3,LSL #2]
;;;96     	AFIO->EXTICR[EXTADDR]|=GPIOx<<EXTOFFSET;//EXTI.BITx映射到GPIOx.BITx
000100  f8555023          LDR      r5,[r5,r3,LSL #2]
000104  fa00f604          LSL      r6,r0,r4
000108  4335              ORRS     r5,r5,r6
00010a  4e70              LDR      r6,|L1.716|
00010c  f8465023          STR      r5,[r6,r3,LSL #2]
;;;97     	
;;;98     	//自动设置
;;;99     	EXTI->IMR|=1<<BITx;//  开启line BITx上的中断
000110  4d6f              LDR      r5,|L1.720|
000112  682e              LDR      r6,[r5,#0]
000114  2501              MOVS     r5,#1
000116  408d              LSLS     r5,r5,r1
000118  432e              ORRS     r6,r6,r5
00011a  4d6c              LDR      r5,|L1.716|
00011c  3d08              SUBS     r5,r5,#8
00011e  f8c56400          STR      r6,[r5,#0x400]
;;;100    	//EXTI->EMR|=1<<BITx;//不屏蔽line BITx上的事件 (如果不屏蔽这句,在硬件上是可以的,但是在软件仿真的时候无法进入中断!)
;;;101     	if(TRIM&0x01)EXTI->FTSR|=1<<BITx;//line BITx上事件下降沿触发
000122  f0120f01          TST      r2,#1
000126  d009              BEQ      |L1.316|
000128  4d69              LDR      r5,|L1.720|
00012a  350c              ADDS     r5,r5,#0xc
00012c  682e              LDR      r6,[r5,#0]
00012e  2501              MOVS     r5,#1
000130  408d              LSLS     r5,r5,r1
000132  432e              ORRS     r6,r6,r5
000134  4d65              LDR      r5,|L1.716|
000136  3d08              SUBS     r5,r5,#8
000138  f8c5640c          STR      r6,[r5,#0x40c]
                  |L1.316|
;;;102    	if(TRIM&0x02)EXTI->RTSR|=1<<BITx;//line BITx上事件上升降沿触发
00013c  f0120f02          TST      r2,#2
000140  d009              BEQ      |L1.342|
000142  4d63              LDR      r5,|L1.720|
000144  3508              ADDS     r5,r5,#8
000146  682e              LDR      r6,[r5,#0]
000148  2501              MOVS     r5,#1
00014a  408d              LSLS     r5,r5,r1
00014c  432e              ORRS     r6,r6,r5
00014e  4d5f              LDR      r5,|L1.716|
000150  3d08              SUBS     r5,r5,#8
000152  f8c56408          STR      r6,[r5,#0x408]
                  |L1.342|
;;;103    } 	  
000156  bd70              POP      {r4-r6,pc}
;;;104    //不能在这里执行所有外设复位!否则至少引起串口不工作.		    
                          ENDP

                  MYRCC_DeInit PROC
;;;105    //把所有时钟寄存器复位		  
;;;106    void MYRCC_DeInit(void)
000158  b500              PUSH     {lr}
;;;107    {	
;;;108     	RCC->APB1RSTR = 0x00000000;//复位结束			 
00015a  2000              MOVS     r0,#0
00015c  495a              LDR      r1,|L1.712|
00015e  6108              STR      r0,[r1,#0x10]
;;;109    	RCC->APB2RSTR = 0x00000000; 
000160  60c8              STR      r0,[r1,#0xc]
;;;110    	  
;;;111      	RCC->AHBENR = 0x00000015;  //睡眠模式闪存和SRAM时钟使能.PENG: enable DMA1 clock.	  
000162  2015              MOVS     r0,#0x15
000164  6148              STR      r0,[r1,#0x14]
;;;112      	RCC->APB2ENR = 0x00000000; //外设时钟关闭.			   
000166  2000              MOVS     r0,#0
000168  6188              STR      r0,[r1,#0x18]
;;;113      	RCC->APB1ENR = 0x00000000;   
00016a  61c8              STR      r0,[r1,#0x1c]
;;;114    	RCC->CR |= 0x00000001;     //使能内部高速时钟HSION	 															 
00016c  4608              MOV      r0,r1
00016e  6800              LDR      r0,[r0,#0]
000170  f0400001          ORR      r0,r0,#1
000174  6008              STR      r0,[r1,#0]
;;;115    	RCC->CFGR &= 0xF8FF0000;   //复位SW[1:0],HPRE[3:0],PPRE1[2:0],PPRE2[2:0],ADCPRE[1:0],MCO[2:0]					 
000176  4608              MOV      r0,r1
000178  6840              LDR      r0,[r0,#4]
00017a  4956              LDR      r1,|L1.724|
00017c  4008              ANDS     r0,r0,r1
00017e  4952              LDR      r1,|L1.712|
000180  6048              STR      r0,[r1,#4]
;;;116    	RCC->CR &= 0xFEF6FFFF;     //复位HSEON,CSSON,PLLON
000182  4608              MOV      r0,r1
000184  6800              LDR      r0,[r0,#0]
000186  4954              LDR      r1,|L1.728|
000188  4008              ANDS     r0,r0,r1
00018a  494f              LDR      r1,|L1.712|
00018c  6008              STR      r0,[r1,#0]
;;;117    	RCC->CR &= 0xFFFBFFFF;     //复位HSEBYP	   	  
00018e  4608              MOV      r0,r1
000190  6800              LDR      r0,[r0,#0]
000192  f4202080          BIC      r0,r0,#0x40000
000196  6008              STR      r0,[r1,#0]
;;;118    	RCC->CFGR &= 0xFF80FFFF;   //复位PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE 
000198  4608              MOV      r0,r1
00019a  6840              LDR      r0,[r0,#4]
00019c  f42000fe          BIC      r0,r0,#0x7f0000
0001a0  6048              STR      r0,[r1,#4]
;;;119    	RCC->CIR = 0x00000000;     //关闭所有中断		 
0001a2  2000              MOVS     r0,#0
0001a4  6088              STR      r0,[r1,#8]
;;;120    	//配置向量表				  
;;;121    #ifdef  VECT_TAB_RAM
;;;122    	MY_NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
;;;123    #else   
;;;124    	MY_NVIC_SetVectorTable(NVIC_VectTab_FLASH,0x0);
0001a6  2100              MOVS     r1,#0
0001a8  f04f6000          MOV      r0,#0x8000000
0001ac  f7fffffe          BL       MY_NVIC_SetVectorTable
;;;125    #endif
;;;126    }
0001b0  bd00              POP      {pc}
;;;127    //THUMB指令不支持汇编内联
                          ENDP

                  Sys_Standby PROC
;;;151    //进入待机模式	  
;;;152    void Sys_Standby(void)
0001b2  b510              PUSH     {r4,lr}
;;;153    {
;;;154    	SCB->SCR|=1<<2;//使能SLEEPDEEP位 (SYS->CTRL)	   
0001b4  4840              LDR      r0,|L1.696|
0001b6  3008              ADDS     r0,r0,#8
0001b8  6800              LDR      r0,[r0,#0]
0001ba  f0400004          ORR      r0,r0,#4
0001be  f04f21e0          MOV      r1,#0xe000e000
0001c2  f8c10d10          STR      r0,[r1,#0xd10]
;;;155      	RCC->APB1ENR|=1<<28;     //使能电源时钟	    
0001c6  4840              LDR      r0,|L1.712|
0001c8  69c0              LDR      r0,[r0,#0x1c]
0001ca  f0405080          ORR      r0,r0,#0x10000000
0001ce  493e              LDR      r1,|L1.712|
0001d0  61c8              STR      r0,[r1,#0x1c]
;;;156     	PWR->CSR|=1<<8;          //设置WKUP用于唤醒
0001d2  4842              LDR      r0,|L1.732|
0001d4  6840              LDR      r0,[r0,#4]
0001d6  f4407080          ORR      r0,r0,#0x100
0001da  4940              LDR      r1,|L1.732|
0001dc  6048              STR      r0,[r1,#4]
;;;157    	PWR->CR|=1<<2;           //清除Wake-up 标志
0001de  4608              MOV      r0,r1
0001e0  6800              LDR      r0,[r0,#0]
0001e2  f0400004          ORR      r0,r0,#4
0001e6  6008              STR      r0,[r1,#0]
;;;158    	PWR->CR|=1<<1;           //PDDS置位		  
0001e8  4608              MOV      r0,r1
0001ea  6800              LDR      r0,[r0,#0]
0001ec  f0400002          ORR      r0,r0,#2
0001f0  6008              STR      r0,[r1,#0]
;;;159    	WFI_SET();				 //执行WFI指令		 
0001f2  f7fffffe          BL       WFI_SET
;;;160    }	     
0001f6  bd10              POP      {r4,pc}
;;;161    //系统软复位   
                          ENDP

                  Sys_Soft_Reset PROC
;;;162    void Sys_Soft_Reset(void)
0001f8  4830              LDR      r0,|L1.700|
;;;163    {   
;;;164    	SCB->AIRCR =0X05FA0000|(u32)0x04;	  
0001fa  1d00              ADDS     r0,r0,#4
0001fc  492e              LDR      r1,|L1.696|
0001fe  1d09              ADDS     r1,r1,#4
000200  6008              STR      r0,[r1,#0]
;;;165    } 		 
000202  4770              BX       lr
;;;166    //JTAG模式设置,用于设置JTAG的模式
                          ENDP

                  JTAG_Set PROC
;;;170    //#define JTAG_SWD_ENABLE    0X00		  
;;;171    void JTAG_Set(u8 mode)
000204  4601              MOV      r1,r0
;;;172    {
;;;173    	u32 temp;
;;;174    	temp=mode;
;;;175    	temp<<=25;
000206  4608              MOV      r0,r1
000208  0649              LSLS     r1,r1,#25
;;;176    	RCC->APB2ENR|=1<<0;     //开启辅助时钟	   
00020a  4a2f              LDR      r2,|L1.712|
00020c  6992              LDR      r2,[r2,#0x18]
00020e  f0420201          ORR      r2,r2,#1
000212  4b2d              LDR      r3,|L1.712|
000214  619a              STR      r2,[r3,#0x18]
;;;177    	AFIO->MAPR&=0XF8FFFFFF; //清除MAPR的[26:24]
000216  4a2d              LDR      r2,|L1.716|
000218  3a08              SUBS     r2,r2,#8
00021a  6852              LDR      r2,[r2,#4]
00021c  f02262e0          BIC      r2,r2,#0x7000000
000220  4b2a              LDR      r3,|L1.716|
000222  3b08              SUBS     r3,r3,#8
000224  605a              STR      r2,[r3,#4]
;;;178    	AFIO->MAPR|=temp;       //设置jtag模式
000226  461a              MOV      r2,r3
000228  6852              LDR      r2,[r2,#4]
00022a  430a              ORRS     r2,r2,r1
00022c  605a              STR      r2,[r3,#4]
;;;179    } 
00022e  4770              BX       lr
;;;180    //系统时钟初始化函数
                          ENDP

                  Stm32_Clock_Init PROC
;;;181    //pll:选择的倍频数，从2开始，最大值为16		 
;;;182    void Stm32_Clock_Init(u8 PLL)
000230  b530              PUSH     {r4,r5,lr}
;;;183    {
000232  4604              MOV      r4,r0
;;;184    	unsigned char temp=0;   
000234  2500              MOVS     r5,#0
;;;185    	MYRCC_DeInit();		  //复位并配置向量表
000236  f7fffffe          BL       MYRCC_DeInit
;;;186     	RCC->CR|=0x00010000;  //外部高速时钟使能HSEON
00023a  4823              LDR      r0,|L1.712|
00023c  6800              LDR      r0,[r0,#0]
00023e  f4403080          ORR      r0,r0,#0x10000
000242  4921              LDR      r1,|L1.712|
000244  6008              STR      r0,[r1,#0]
;;;187    	while(!(RCC->CR>>17));//等待外部时钟就绪
000246  bf00              NOP      
                  |L1.584|
000248  481f              LDR      r0,|L1.712|
00024a  6800              LDR      r0,[r0,#0]
00024c  0c40              LSRS     r0,r0,#17
00024e  d0fb              BEQ      |L1.584|
;;;188    	RCC->CFGR=0X00002400; //APB1=DIV2;APB2=DIV2;AHB=DIV1;
000250  f44f5010          MOV      r0,#0x2400
000254  491c              LDR      r1,|L1.712|
000256  6048              STR      r0,[r1,#4]
;;;189    	PLL-=2;//抵消2个单位
000258  1ea0              SUBS     r0,r4,#2
00025a  b2c4              UXTB     r4,r0
;;;190    	RCC->CFGR|=PLL<<18;   //设置PLL值 2~16
00025c  4608              MOV      r0,r1
00025e  6840              LDR      r0,[r0,#4]
000260  ea404084          ORR      r0,r0,r4,LSL #18
000264  6048              STR      r0,[r1,#4]
;;;191    	RCC->CFGR|=1<<16;	  //PLLSRC ON 
000266  4608              MOV      r0,r1
000268  6840              LDR      r0,[r0,#4]
00026a  f4403080          ORR      r0,r0,#0x10000
00026e  6048              STR      r0,[r1,#4]
;;;192    	FLASH->ACR|=0x32;	  //FLASH 2个延时周期
000270  481b              LDR      r0,|L1.736|
000272  6800              LDR      r0,[r0,#0]
000274  f0400032          ORR      r0,r0,#0x32
000278  4919              LDR      r1,|L1.736|
00027a  6008              STR      r0,[r1,#0]
;;;193    
;;;194    	RCC->CR|=0x01000000;  //PLLON
00027c  4812              LDR      r0,|L1.712|
00027e  6800              LDR      r0,[r0,#0]
000280  f0407080          ORR      r0,r0,#0x1000000
000284  4910              LDR      r1,|L1.712|
000286  6008              STR      r0,[r1,#0]
;;;195    	while(!(RCC->CR>>25));//等待PLL锁定
000288  bf00              NOP      
                  |L1.650|
00028a  480f              LDR      r0,|L1.712|
00028c  6800              LDR      r0,[r0,#0]
00028e  0e40              LSRS     r0,r0,#25
000290  d0fb              BEQ      |L1.650|
;;;196    	RCC->CFGR|=0x00000002;//PLL作为系统时钟	 
000292  480d              LDR      r0,|L1.712|
000294  6840              LDR      r0,[r0,#4]
000296  f0400002          ORR      r0,r0,#2
00029a  490b              LDR      r1,|L1.712|
00029c  6048              STR      r0,[r1,#4]
;;;197    	while(temp!=0x02)     //等待PLL作为系统时钟设置成功
00029e  e005              B        |L1.684|
                  |L1.672|
;;;198    	{   
;;;199    		temp=RCC->CFGR>>2;
0002a0  4809              LDR      r0,|L1.712|
0002a2  6840              LDR      r0,[r0,#4]
0002a4  f3c00587          UBFX     r5,r0,#2,#8
;;;200    		temp&=0x03;
0002a8  f0050503          AND      r5,r5,#3
                  |L1.684|
0002ac  2d02              CMP      r5,#2                 ;197
0002ae  d1f7              BNE      |L1.672|
;;;201    	}    
;;;202    }		    
0002b0  bd30              POP      {r4,r5,pc}
;;;203    
                          ENDP

0002b2  0000              DCW      0x0000
                  |L1.692|
                          DCD      0x1fffff80
                  |L1.696|
                          DCD      0xe000ed08
                  |L1.700|
                          DCD      0x05fa0000
                  |L1.704|
                          DCD      0xe000e100
                  |L1.708|
                          DCD      0xe000e400
                  |L1.712|
                          DCD      0x40021000
                  |L1.716|
                          DCD      0x40010008
                  |L1.720|
                          DCD      0x40010400
                  |L1.724|
                          DCD      0xf8ff0000
                  |L1.728|
                          DCD      0xfef6ffff
                  |L1.732|
                          DCD      0x40007000
                  |L1.736|
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\sys\\sys.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |WFI_SET|
#line 129
|WFI_SET| PROC
#line 130

 WFI
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |INTX_DISABLE|
#line 134
|INTX_DISABLE| PROC
#line 135

 CPSID I
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |INTX_ENABLE|
#line 139
|INTX_ENABLE| PROC
#line 140

 CPSIE I
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |MSR_MSP|
#line 145
|MSR_MSP| PROC
#line 146

 MSR MSP, r0  
 BX r14
	ENDP

;*** End   embedded assembler ***
