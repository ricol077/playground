; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\tpad.o --depend=..\OBJ\tpad.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\tpad.crf ..\HARDWARE\TPAD\tpad.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TPAD_Reset PROC
;;;54     //释放电容电量，并清除定时器的计数值
;;;55     void TPAD_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;56     {				   
;;;57     	GPIOA->CRL&=0XFFFFFF0F;	//PA1  输入  
000002  4890              LDR      r0,|L1.580|
000004  6800              LDR      r0,[r0,#0]
000006  f02000f0          BIC      r0,r0,#0xf0
00000a  498f              LDR      r1,|L1.584|
00000c  f8c10800          STR      r0,[r1,#0x800]
;;;58     	GPIOA->CRL|=0X00000030;	//复用功能输出       
000010  4608              MOV      r0,r1
000012  f8d00800          LDR      r0,[r0,#0x800]
000016  f0400030          ORR      r0,r0,#0x30
00001a  f8c10800          STR      r0,[r1,#0x800]
;;;59     	GPIOA->ODR&=~(1<<1);	//输出0,放电
00001e  4608              MOV      r0,r1
000020  f8d0080c          LDR      r0,[r0,#0x80c]
000024  f0200002          BIC      r0,r0,#2
000028  f8c1080c          STR      r0,[r1,#0x80c]
;;;60     	delay_ms(5);
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       delay_ms
;;;61     	TIM5->SR=0;   			//清除标记
000032  2000              MOVS     r0,#0
000034  4985              LDR      r1,|L1.588|
000036  8008              STRH     r0,[r1,#0]
;;;62     	TIM5->CNT=0;			//归零     
000038  0689              LSLS     r1,r1,#26
00003a  f8a10c24          STRH     r0,[r1,#0xc24]
;;;63     	GPIOA->CRL&=0XFFFFFF0F;	//PA1  输入  
00003e  4882              LDR      r0,|L1.584|
000040  f8d00800          LDR      r0,[r0,#0x800]
000044  f02000f0          BIC      r0,r0,#0xf0
000048  497f              LDR      r1,|L1.584|
00004a  f8c10800          STR      r0,[r1,#0x800]
;;;64     	GPIOA->CRL|=0X00000040;	//复用功能输出       
00004e  4608              MOV      r0,r1
000050  f8d00800          LDR      r0,[r0,#0x800]
000054  f0400040          ORR      r0,r0,#0x40
000058  f8c10800          STR      r0,[r1,#0x800]
;;;65     }
00005c  bd10              POP      {r4,pc}
;;;66     //得到定时器捕获值
                          ENDP

                  TPAD_Get_Val PROC
;;;68     //返回值：捕获值/计数值（超时的情况下返回）
;;;69     u16 TPAD_Get_Val(void)
00005e  b510              PUSH     {r4,lr}
;;;70     {				   
;;;71     	TPAD_Reset();
000060  f7fffffe          BL       TPAD_Reset
;;;72     	while((TIM5->SR&0X02)==0)//等待捕获上升沿
000064  e00a              B        |L1.124|
                  |L1.102|
;;;73     	{
;;;74     		if(TIM5->CNT>TPAD_ARR_MAX_VAL-500)return TIM5->CNT;//超时了,直接返回CNT的值
000066  4879              LDR      r0,|L1.588|
000068  3014              ADDS     r0,r0,#0x14
00006a  8800              LDRH     r0,[r0,#0]
00006c  f64f610b          MOV      r1,#0xfe0b
000070  4288              CMP      r0,r1
000072  dd03              BLE      |L1.124|
000074  4875              LDR      r0,|L1.588|
000076  3014              ADDS     r0,r0,#0x14
000078  8800              LDRH     r0,[r0,#0]
                  |L1.122|
;;;75     	};	
;;;76     	return TIM5->CCR2;	  
;;;77     } 	  
00007a  bd10              POP      {r4,pc}
                  |L1.124|
00007c  4873              LDR      r0,|L1.588|
00007e  8800              LDRH     r0,[r0,#0]            ;72
000080  f0100f02          TST      r0,#2                 ;72
000084  d0ef              BEQ      |L1.102|
000086  4871              LDR      r0,|L1.588|
000088  3028              ADDS     r0,r0,#0x28           ;76
00008a  8800              LDRH     r0,[r0,#0]            ;76
00008c  e7f5              B        |L1.122|
;;;78     //读取n次,取最大值
                          ENDP

                  TIM5_CH2_Cap_Init PROC
;;;123    //psc：时钟预分频数
;;;124    void TIM5_CH2_Cap_Init(u16 arr,u16 psc)
00008e  4a70              LDR      r2,|L1.592|
;;;125    {
;;;126    	//此部分需手动修改 IO口设置  
;;;127     	RCC->APB1ENR|=1<<3;   	//TIM5 时钟使能 
000090  69d2              LDR      r2,[r2,#0x1c]
000092  f0420208          ORR      r2,r2,#8
000096  4b6e              LDR      r3,|L1.592|
000098  61da              STR      r2,[r3,#0x1c]
;;;128    	RCC->APB2ENR|=1<<2;    	//使能PORTA时钟 
00009a  461a              MOV      r2,r3
00009c  6992              LDR      r2,[r2,#0x18]
00009e  f0420204          ORR      r2,r2,#4
0000a2  619a              STR      r2,[r3,#0x18]
;;;129    
;;;130    	GPIOA->CRL&=0XFFFFFF0F;	//PA1  输入  
0000a4  4a67              LDR      r2,|L1.580|
0000a6  6812              LDR      r2,[r2,#0]
0000a8  f02202f0          BIC      r2,r2,#0xf0
0000ac  4b66              LDR      r3,|L1.584|
0000ae  f8c32800          STR      r2,[r3,#0x800]
;;;131    	GPIOA->CRL|=0X00000040;	//浮空输入     	  
0000b2  461a              MOV      r2,r3
0000b4  f8d22800          LDR      r2,[r2,#0x800]
0000b8  f0420240          ORR      r2,r2,#0x40
0000bc  f8c32800          STR      r2,[r3,#0x800]
;;;132    	  
;;;133     	TIM5->ARR=arr;  		//设定计数器自动重装值//刚好1ms    
0000c0  039a              LSLS     r2,r3,#14
0000c2  f8a20c2c          STRH     r0,[r2,#0xc2c]
;;;134    	TIM5->PSC=psc;  		//预分频器,1M的计数频率	 
0000c6  f8a21c28          STRH     r1,[r2,#0xc28]
;;;135    
;;;136    	TIM5->CCMR1|=1<<8;		//CC2S=01 	选择输入端 IC2映射到TI2上
0000ca  f8b22c18          LDRH     r2,[r2,#0xc18]
0000ce  f4427280          ORR      r2,r2,#0x100
0000d2  039b              LSLS     r3,r3,#14
0000d4  f8a32c18          STRH     r2,[r3,#0xc18]
;;;137     	TIM5->CCMR1|=0<<12; 	//IC2F=0011 配置输入滤波器 8个定时器时钟周期滤波
0000d8  461a              MOV      r2,r3
0000da  f8b22c18          LDRH     r2,[r2,#0xc18]
0000de  f8a32c18          STRH     r2,[r3,#0xc18]
;;;138     	TIM5->CCMR1|=0<<10; 	//IC2PS=00 	配置输入分频,不分频 
0000e2  461a              MOV      r2,r3
0000e4  f8b22c18          LDRH     r2,[r2,#0xc18]
0000e8  f8a32c18          STRH     r2,[r3,#0xc18]
;;;139    
;;;140    	TIM5->CCER|=0<<5; 		//CC2P=0	上升沿捕获
0000ec  461a              MOV      r2,r3
0000ee  f8b22c20          LDRH     r2,[r2,#0xc20]
0000f2  f8a32c20          STRH     r2,[r3,#0xc20]
;;;141    	TIM5->CCER|=1<<4; 		//CC2E=1 	允许捕获计数器的值到捕获寄存器中
0000f6  461a              MOV      r2,r3
0000f8  f8b22c20          LDRH     r2,[r2,#0xc20]
0000fc  f0420210          ORR      r2,r2,#0x10
000100  f8a32c20          STRH     r2,[r3,#0xc20]
;;;142    																 
;;;143    	TIM5->CR1|=0x01;    	//使能定时器5
000104  461a              MOV      r2,r3
000106  f8b22c00          LDRH     r2,[r2,#0xc00]
00010a  f0420201          ORR      r2,r2,#1
00010e  f8a32c00          STRH     r2,[r3,#0xc00]
;;;144    }
000112  4770              BX       lr
;;;145    
                          ENDP

                  TPAD_Init PROC
;;;22     //返回值:0,初始化成功;1,初始化失败
;;;23     u8 TPAD_Init(u8 systick)
000114  b5f0              PUSH     {r4-r7,lr}
;;;24     {
000116  b085              SUB      sp,sp,#0x14
000118  4604              MOV      r4,r0
;;;25     	u16 buf[10];
;;;26     	u16 temp;
;;;27     	u8 j,i;
;;;28     	TIM5_CH2_Cap_Init(TPAD_ARR_MAX_VAL,systick-1);//以1Mhz的频率计数 
00011a  1e60              SUBS     r0,r4,#1
00011c  b281              UXTH     r1,r0
00011e  f64f70ff          MOV      r0,#0xffff
000122  f7fffffe          BL       TIM5_CH2_Cap_Init
;;;29     	for(i=0;i<10;i++)//连续读取10次
000126  2700              MOVS     r7,#0
000128  e008              B        |L1.316|
                  |L1.298|
;;;30     	{				 
;;;31     		buf[i]=TPAD_Get_Val();
00012a  f7fffffe          BL       TPAD_Get_Val
00012e  f82d0017          STRH     r0,[sp,r7,LSL #1]
;;;32     		delay_ms(10);	    
000132  200a              MOVS     r0,#0xa
000134  f7fffffe          BL       delay_ms
000138  1c78              ADDS     r0,r7,#1              ;29
00013a  b2c7              UXTB     r7,r0                 ;29
                  |L1.316|
00013c  2f0a              CMP      r7,#0xa               ;29
00013e  dbf4              BLT      |L1.298|
;;;33     	}				    
;;;34     	for(i=0;i<9;i++)//排序
000140  2700              MOVS     r7,#0
000142  e016              B        |L1.370|
                  |L1.324|
;;;35     	{
;;;36     		for(j=i+1;j<10;j++)
000144  1c78              ADDS     r0,r7,#1
000146  b2c6              UXTB     r6,r0
000148  e00f              B        |L1.362|
                  |L1.330|
;;;37     		{
;;;38     			if(buf[i]>buf[j])//升序排列
00014a  f83d0017          LDRH     r0,[sp,r7,LSL #1]
00014e  f83d1016          LDRH     r1,[sp,r6,LSL #1]
000152  4288              CMP      r0,r1
000154  dd07              BLE      |L1.358|
;;;39     			{
;;;40     				temp=buf[i];
000156  f83d5017          LDRH     r5,[sp,r7,LSL #1]
;;;41     				buf[i]=buf[j];
00015a  f83d0016          LDRH     r0,[sp,r6,LSL #1]
00015e  f82d0017          STRH     r0,[sp,r7,LSL #1]
;;;42     				buf[j]=temp;
000162  f82d5016          STRH     r5,[sp,r6,LSL #1]
                  |L1.358|
000166  1c70              ADDS     r0,r6,#1              ;36
000168  b2c6              UXTB     r6,r0                 ;36
                  |L1.362|
00016a  2e0a              CMP      r6,#0xa               ;36
00016c  dbed              BLT      |L1.330|
00016e  1c78              ADDS     r0,r7,#1              ;34
000170  b2c7              UXTB     r7,r0                 ;34
                  |L1.370|
000172  2f09              CMP      r7,#9                 ;34
000174  dbe6              BLT      |L1.324|
;;;43     			}
;;;44     		}
;;;45     	}
;;;46     	temp=0;
000176  2500              MOVS     r5,#0
;;;47     	for(i=2;i<8;i++)temp+=buf[i];//取中间的8个数据进行平均
000178  2702              MOVS     r7,#2
00017a  e005              B        |L1.392|
                  |L1.380|
00017c  f83d0017          LDRH     r0,[sp,r7,LSL #1]
000180  4428              ADD      r0,r0,r5
000182  b285              UXTH     r5,r0
000184  1c78              ADDS     r0,r7,#1
000186  b2c7              UXTB     r7,r0
                  |L1.392|
000188  2f08              CMP      r7,#8
00018a  dbf7              BLT      |L1.380|
;;;48     	tpad_default_val=temp/6;
00018c  2006              MOVS     r0,#6
00018e  fb95f0f0          SDIV     r0,r5,r0
000192  4930              LDR      r1,|L1.596|
000194  8008              STRH     r0,[r1,#0]
;;;49     	printf("tpad_default_val:%d\r\n",tpad_default_val);	
000196  4608              MOV      r0,r1
000198  8801              LDRH     r1,[r0,#0]  ; tpad_default_val
00019a  a02f              ADR      r0,|L1.600|
00019c  f7fffffe          BL       __2printf
;;;50     	if(tpad_default_val>TPAD_ARR_MAX_VAL/2)return 1;//初始化遇到超过TPAD_ARR_MAX_VAL/2的数值,不正常!
0001a0  482c              LDR      r0,|L1.596|
0001a2  8800              LDRH     r0,[r0,#0]  ; tpad_default_val
0001a4  f5b04f00          CMP      r0,#0x8000
0001a8  db02              BLT      |L1.432|
0001aa  2001              MOVS     r0,#1
                  |L1.428|
;;;51     	return 0;		     	    					   
;;;52     }
0001ac  b005              ADD      sp,sp,#0x14
0001ae  bdf0              POP      {r4-r7,pc}
                  |L1.432|
0001b0  2000              MOVS     r0,#0                 ;51
0001b2  e7fb              B        |L1.428|
;;;53     //复位一次
                          ENDP

                  TPAD_Get_MaxVal PROC
;;;80     //返回值：n次读数里面读到的最大读数值
;;;81     u16 TPAD_Get_MaxVal(u8 n)
0001b4  b570              PUSH     {r4-r6,lr}
;;;82     {
0001b6  4604              MOV      r4,r0
;;;83     	u16 temp=0;
0001b8  2500              MOVS     r5,#0
;;;84     	u16 res=0;
0001ba  2600              MOVS     r6,#0
;;;85     	while(n--)
0001bc  e005              B        |L1.458|
                  |L1.446|
;;;86     	{
;;;87     		temp=TPAD_Get_Val();//得到一次值
0001be  f7fffffe          BL       TPAD_Get_Val
0001c2  4605              MOV      r5,r0
;;;88     		if(temp>res)res=temp;
0001c4  42b5              CMP      r5,r6
0001c6  dd00              BLE      |L1.458|
0001c8  462e              MOV      r6,r5
                  |L1.458|
0001ca  0020              MOVS     r0,r4                 ;85
0001cc  f1a40101          SUB      r1,r4,#1              ;85
0001d0  b2cc              UXTB     r4,r1                 ;85
0001d2  d1f4              BNE      |L1.446|
;;;89     	};
;;;90     	return res;
0001d4  4630              MOV      r0,r6
;;;91     }  
0001d6  bd70              POP      {r4-r6,pc}
;;;92     //扫描触摸按键
                          ENDP

                  TPAD_Scan PROC
;;;95     #define TPAD_GATE_VAL 	80	//触摸的门限值,也就是必须大于tpad_default_val+TPAD_GATE_VAL,才认为是有效触摸.
;;;96     u8 TPAD_Scan(u8 mode)
0001d8  e92d41f0          PUSH     {r4-r8,lr}
;;;97     {
0001dc  4604              MOV      r4,r0
;;;98     	static u8 keyen=0;	//0,可以开始检测;>0,还不能开始检测	 
;;;99     	u8 res=0;
0001de  2500              MOVS     r5,#0
;;;100    	u8 sample=3;		//默认采样次数为3次	 
0001e0  2703              MOVS     r7,#3
;;;101    	u16 rval;
;;;102    	if(mode)
0001e2  b11c              CBZ      r4,|L1.492|
;;;103    	{
;;;104    		sample=6;	//支持连按的时候，设置采样次数为6次
0001e4  2706              MOVS     r7,#6
;;;105    		keyen=0;	//支持连按	  
0001e6  2000              MOVS     r0,#0
0001e8  4921              LDR      r1,|L1.624|
0001ea  7008              STRB     r0,[r1,#0]
                  |L1.492|
;;;106    	}
;;;107    	rval=TPAD_Get_MaxVal(sample); 
0001ec  4638              MOV      r0,r7
0001ee  f7fffffe          BL       TPAD_Get_MaxVal
0001f2  4606              MOV      r6,r0
;;;108    	if(rval>(tpad_default_val+TPAD_GATE_VAL))//大于tpad_default_val+TPAD_GATE_VAL,有效
0001f4  4917              LDR      r1,|L1.596|
0001f6  8809              LDRH     r1,[r1,#0]  ; tpad_default_val
0001f8  3150              ADDS     r1,r1,#0x50
0001fa  428e              CMP      r6,r1
0001fc  dd10              BLE      |L1.544|
;;;109    	{						
;;;110      		rval=TPAD_Get_MaxVal(sample);		 
0001fe  4638              MOV      r0,r7
000200  f7fffffe          BL       TPAD_Get_MaxVal
000204  4606              MOV      r6,r0
;;;111    		if((keyen==0)&&(rval>(tpad_default_val+TPAD_GATE_VAL)))//大于tpad_default_val+TPAD_GATE_VAL,有效
000206  481a              LDR      r0,|L1.624|
000208  7800              LDRB     r0,[r0,#0]  ; keyen
00020a  b928              CBNZ     r0,|L1.536|
00020c  4811              LDR      r0,|L1.596|
00020e  8800              LDRH     r0,[r0,#0]  ; tpad_default_val
000210  3050              ADDS     r0,r0,#0x50
000212  4286              CMP      r6,r0
000214  dd00              BLE      |L1.536|
;;;112    		{
;;;113    			res=1;
000216  2501              MOVS     r5,#1
                  |L1.536|
;;;114    		}	   
;;;115    		//printf("r:%d\r\n",rval);			     	    					   
;;;116    		keyen=5;				//至少要再过5次之后才能按键有效   
000218  2005              MOVS     r0,#5
00021a  4915              LDR      r1,|L1.624|
00021c  7008              STRB     r0,[r1,#0]
00021e  e006              B        |L1.558|
                  |L1.544|
;;;117    	}else if(keyen>2)keyen=2; 	//如果检测到按键松开,则直接将次数将为2,以提高响应速度
000220  4813              LDR      r0,|L1.624|
000222  7800              LDRB     r0,[r0,#0]  ; keyen
000224  2802              CMP      r0,#2
000226  dd02              BLE      |L1.558|
000228  2002              MOVS     r0,#2
00022a  4911              LDR      r1,|L1.624|
00022c  7008              STRB     r0,[r1,#0]
                  |L1.558|
;;;118    	if(keyen)keyen--;		   							   		     	    					   
00022e  4810              LDR      r0,|L1.624|
000230  7800              LDRB     r0,[r0,#0]  ; keyen
000232  b120              CBZ      r0,|L1.574|
000234  480e              LDR      r0,|L1.624|
000236  7800              LDRB     r0,[r0,#0]  ; keyen
000238  1e40              SUBS     r0,r0,#1
00023a  490d              LDR      r1,|L1.624|
00023c  7008              STRB     r0,[r1,#0]
                  |L1.574|
;;;119    	return res;
00023e  4628              MOV      r0,r5
;;;120    }	 
000240  e8bd81f0          POP      {r4-r8,pc}
;;;121    //定时器2通道2输入捕获配置	 
                          ENDP

                  |L1.580|
                          DCD      0x40010800
                  |L1.584|
                          DCD      0x40010000
                  |L1.588|
                          DCD      0x40000c10
                  |L1.592|
                          DCD      0x40021000
                  |L1.596|
                          DCD      tpad_default_val
                  |L1.600|
000258  747061645f64656661756c745f76616c3a25640d0a00        DCB      "tpad_default_val:%d\r\n",0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L1.624|
                          DCD      ||.data||+0x2

                          AREA ||.data||, DATA, ALIGN=1

                  tpad_default_val
000000  0000              DCW      0x0000
                  keyen
000002  00                DCB      0x00
