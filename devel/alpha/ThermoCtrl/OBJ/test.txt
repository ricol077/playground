; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\test.o --depend=..\OBJ\test.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\test.crf test.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usb_port_set PROC
;;;121    
;;;122    void usb_port_set(u8 enable)
000000  49fb              LDR      r1,|L1.1008|
;;;123    {
;;;124    	RCC->APB2ENR|=1<<2;    //使能PORTA时钟	   	 
000002  6989              LDR      r1,[r1,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  4af9              LDR      r2,|L1.1008|
00000a  6191              STR      r1,[r2,#0x18]
;;;125    	if(enable)_SetCNTR(_GetCNTR()&(~(1<<1)));//退出断电模式
00000c  b140              CBZ      r0,|L1.32|
00000e  49f9              LDR      r1,|L1.1012|
000010  6809              LDR      r1,[r1,#0]
000012  b289              UXTH     r1,r1
000014  f0210102          BIC      r1,r1,#2
000018  4af7              LDR      r2,|L1.1016|
00001a  f8c21c40          STR      r1,[r2,#0xc40]
00001e  e019              B        |L1.84|
                  |L1.32|
;;;126    	else
;;;127    	{	  
;;;128    		_SetCNTR(_GetCNTR()|(1<<1));  // 断电模式
000020  49f4              LDR      r1,|L1.1012|
000022  6809              LDR      r1,[r1,#0]
000024  b289              UXTH     r1,r1
000026  f0410102          ORR      r1,r1,#2
00002a  4af3              LDR      r2,|L1.1016|
00002c  f8c21c40          STR      r1,[r2,#0xc40]
;;;129    		GPIOA->CRH&=0XFFF00FFF;
000030  49f2              LDR      r1,|L1.1020|
000032  f8d11804          LDR      r1,[r1,#0x804]
000036  f421217f          BIC      r1,r1,#0xff000
00003a  4af0              LDR      r2,|L1.1020|
00003c  f8c21804          STR      r1,[r2,#0x804]
;;;130    		GPIOA->CRH|=0X00033000;
000040  4611              MOV      r1,r2
000042  f8d11804          LDR      r1,[r1,#0x804]
000046  f441314c          ORR      r1,r1,#0x33000
00004a  4aed              LDR      r2,|L1.1024|
00004c  6011              STR      r1,[r2,#0]
;;;131    		PAout(12)=0;	    		  
00004e  2100              MOVS     r1,#0
000050  4aec              LDR      r2,|L1.1028|
000052  6011              STR      r1,[r2,#0]
                  |L1.84|
;;;132    	}
;;;133    } 
000054  4770              BX       lr
;;;134    int main(void)
                          ENDP

                  USBRes PROC
;;;1746   
;;;1747   void USBRes(u8 response, u8 command,u8 * buffer, u8 length)
000056  e92d47f0          PUSH     {r4-r10,lr}
;;;1748   {
00005a  4604              MOV      r4,r0
00005c  460d              MOV      r5,r1
00005e  4616              MOV      r6,r2
000060  461f              MOV      r7,r3
;;;1749   	u16 i, u8temp, len;
;;;1750   	Transi_Buffer[0]=HEADER;
000062  20aa              MOVS     r0,#0xaa
000064  49e8              LDR      r1,|L1.1032|
000066  7008              STRB     r0,[r1,#0]
;;;1751   	Transi_Buffer[1]=response;
000068  4608              MOV      r0,r1
00006a  7044              STRB     r4,[r0,#1]
;;;1752   	Transi_Buffer[2]=command;
00006c  7085              STRB     r5,[r0,#2]
;;;1753   	Transi_Buffer[3]=length;
00006e  70c7              STRB     r7,[r0,#3]
;;;1754   	len=4;
000070  f04f0a04          MOV      r10,#4
;;;1755   	for(i=0;i<length;i++,len++)
000074  f04f0800          MOV      r8,#0
000078  e00c              B        |L1.148|
                  |L1.122|
;;;1756   			Transi_Buffer[len]=*(buffer+i);
00007a  f8160008          LDRB     r0,[r6,r8]
00007e  49e2              LDR      r1,|L1.1032|
000080  f801000a          STRB     r0,[r1,r10]
000084  f1080001          ADD      r0,r8,#1              ;1755
000088  fa1ff880          UXTH     r8,r0                 ;1755
00008c  f10a0001          ADD      r0,r10,#1             ;1755
000090  fa1ffa80          UXTH     r10,r0                ;1755
                  |L1.148|
000094  45b8              CMP      r8,r7                 ;1755
000096  dbf0              BLT      |L1.122|
;;;1757   	u8temp=0;
000098  f04f0900          MOV      r9,#0
;;;1758   	for(i=1;i<(len-1);i++)
00009c  f04f0801          MOV      r8,#1
0000a0  e009              B        |L1.182|
                  |L1.162|
;;;1759   		u8temp+=Transi_Buffer[i];
0000a2  48d9              LDR      r0,|L1.1032|
0000a4  f8100008          LDRB     r0,[r0,r8]
0000a8  4448              ADD      r0,r0,r9
0000aa  fa1ff980          UXTH     r9,r0
0000ae  f1080001          ADD      r0,r8,#1              ;1758
0000b2  fa1ff880          UXTH     r8,r0                 ;1758
                  |L1.182|
0000b6  f1aa0001          SUB      r0,r10,#1             ;1758
0000ba  4540              CMP      r0,r8                 ;1758
0000bc  dcf1              BGT      |L1.162|
;;;1760   	if(u8temp==TAIL)
0000be  f1b90f17          CMP      r9,#0x17
0000c2  d103              BNE      |L1.204|
;;;1761   		u8temp++;
0000c4  f1090001          ADD      r0,r9,#1
0000c8  fa1ff980          UXTH     r9,r0
                  |L1.204|
;;;1762      	Transi_Buffer[len]=u8temp;
0000cc  49ce              LDR      r1,|L1.1032|
0000ce  f801900a          STRB     r9,[r1,r10]
;;;1763   	Transi_Buffer[len+1]=Transi_Buffer[len+2]=TAIL;
0000d2  2117              MOVS     r1,#0x17
0000d4  4acc              LDR      r2,|L1.1032|
0000d6  f10a0002          ADD      r0,r10,#2
0000da  5411              STRB     r1,[r2,r0]
0000dc  1e40              SUBS     r0,r0,#1
0000de  5411              STRB     r1,[r2,r0]
;;;1764   	//while((GetEPTxStatus(ENDP2) & 0x30)!=EP_TX_VALID);
;;;1765       UserToPMABufferCopy(Transi_Buffer, ENDP2_TXADDR, nReportCnt);//len+3);
0000e0  2240              MOVS     r2,#0x40
0000e2  f44f718c          MOV      r1,#0x118
0000e6  48c8              LDR      r0,|L1.1032|
0000e8  f7fffffe          BL       UserToPMABufferCopy
;;;1766   	SetEPTxCount(ENDP2, nReportCnt); 
0000ec  2140              MOVS     r1,#0x40
0000ee  2002              MOVS     r0,#2
0000f0  f7fffffe          BL       SetEPTxCount
;;;1767       SetEPTxValid(ENDP2);
0000f4  2002              MOVS     r0,#2
0000f6  f7fffffe          BL       SetEPTxValid
;;;1768   }
0000fa  e8bd87f0          POP      {r4-r10,pc}
;;;1769   
                          ENDP

                  PacketChkSum PROC
;;;1702   
;;;1703   u8 PacketChkSum(u8 *p, u8 length)
0000fe  b510              PUSH     {r4,lr}
;;;1704   {
000100  4602              MOV      r2,r0
;;;1705   	u8 i;  
;;;1706   	u8 temp=0;
000102  2400              MOVS     r4,#0
;;;1707   	for	(i=1;i<(length-2);i++)
000104  2301              MOVS     r3,#1
000106  e004              B        |L1.274|
                  |L1.264|
;;;1708   		temp+=*(p+i);
000108  5cd0              LDRB     r0,[r2,r3]
00010a  4420              ADD      r0,r0,r4
00010c  b2c4              UXTB     r4,r0
00010e  1c58              ADDS     r0,r3,#1              ;1707
000110  b2c3              UXTB     r3,r0                 ;1707
                  |L1.274|
000112  1e88              SUBS     r0,r1,#2              ;1707
000114  4298              CMP      r0,r3                 ;1707
000116  dcf7              BGT      |L1.264|
;;;1709   	if(temp==TAIL)
000118  2c17              CMP      r4,#0x17
00011a  d101              BNE      |L1.288|
;;;1710   		temp++;
00011c  1c60              ADDS     r0,r4,#1
00011e  b2c4              UXTB     r4,r0
                  |L1.288|
;;;1711   	if(temp==*(p+length-2))
000120  1850              ADDS     r0,r2,r1
000122  f8100c02          LDRB     r0,[r0,#-2]
000126  42a0              CMP      r0,r4
000128  d101              BNE      |L1.302|
;;;1712   		return TRUE;
00012a  2001              MOVS     r0,#1
                  |L1.300|
;;;1713   	else
;;;1714   		return FALSE;
;;;1715   	
;;;1716   }
00012c  bd10              POP      {r4,pc}
                  |L1.302|
00012e  2000              MOVS     r0,#0                 ;1714
000130  e7fc              B        |L1.300|
;;;1717   
                          ENDP

                  EpMsgClr PROC
;;;2434   
;;;2435   void EpMsgClr(void)
000132  2000              MOVS     r0,#0
;;;2436   {
;;;2437      UsbFlg=0;
000134  49b5              LDR      r1,|L1.1036|
000136  7008              STRB     r0,[r1,#0]
;;;2438   }
000138  4770              BX       lr
;;;2439   
                          ENDP

                  EpMsgDisable PROC
;;;2415   }
;;;2416   void EpMsgDisable(void)
00013a  b500              PUSH     {lr}
;;;2417   {
;;;2418   	EpMsgRdy=0;
00013c  2000              MOVS     r0,#0
00013e  49b3              LDR      r1,|L1.1036|
000140  1c49              ADDS     r1,r1,#1
000142  7008              STRB     r0,[r1,#0]
;;;2419   	EpMsgClr();					
000144  f7fffffe          BL       EpMsgClr
;;;2420   }
000148  bd00              POP      {pc}
;;;2421   
                          ENDP

                  EpMsgPop PROC
;;;2427   
;;;2428   MSG_TYP EpMsgPop(void)
00014a  b500              PUSH     {lr}
;;;2429   {
;;;2430   	MSG_TYP msg=UsbFlg;
00014c  48af              LDR      r0,|L1.1036|
00014e  7802              LDRB     r2,[r0,#0]  ; UsbFlg
;;;2431   	EpMsgClr();
000150  f7fffffe          BL       EpMsgClr
;;;2432   	return msg;
000154  4610              MOV      r0,r2
;;;2433   }
000156  bd00              POP      {pc}
;;;2434   
                          ENDP

                  UsbReadDone PROC
;;;2439   
;;;2440   MSG_TYP UsbReadDone(void)
000158  b510              PUSH     {r4,lr}
;;;2441   {
;;;2442   	u8 i;
;;;2443   	MSG_TYP msg=EpMsgPop();
00015a  f7fffffe          BL       EpMsgPop
00015e  4604              MOV      r4,r0
;;;2444   	if(msg==0)
000160  b944              CBNZ     r4,|L1.372|
;;;2445   	{
;;;2446   	/*
;;;2447   		for(i=0;i<USB_WAIT_TIM;i++)
;;;2448   		{
;;;2449   			delay_ms(35);
;;;2450   			msg=EpMsgPop();
;;;2451   			if(msg!=0)
;;;2452   				break;
;;;2453   			else
;;;2454   				msg=0xff;	
;;;2455   		}
;;;2456   		if(msg==0xff)
;;;2457   			msg=0xfe;
;;;2458   	*/
;;;2459   	do{			delay_ms(64);
000162  bf00              NOP      
                  |L1.356|
000164  2040              MOVS     r0,#0x40
000166  f7fffffe          BL       delay_ms
;;;2460   			msg=EpMsgPop();}while(msg==0);
00016a  f7fffffe          BL       EpMsgPop
00016e  4604              MOV      r4,r0
000170  2c00              CMP      r4,#0
000172  d0f7              BEQ      |L1.356|
                  |L1.372|
;;;2461   	}
;;;2462   	return msg;
000174  4620              MOV      r0,r4
;;;2463   }
000176  bd10              POP      {r4,pc}
;;;2464   #endif
                          ENDP

                  EpMsgEnable PROC
;;;2410   static u8 EpMsgRdy=0;
;;;2411   void EpMsgEnable(void)
000178  b500              PUSH     {lr}
;;;2412   {	
;;;2413   	EpMsgClr();	
00017a  f7fffffe          BL       EpMsgClr
;;;2414   	EpMsgRdy=1;				
00017e  2001              MOVS     r0,#1
000180  49a2              LDR      r1,|L1.1036|
000182  1c49              ADDS     r1,r1,#1
000184  7008              STRB     r0,[r1,#0]
;;;2415   }
000186  bd00              POP      {pc}
;;;2416   void EpMsgDisable(void)
                          ENDP

                  Read_Row PROC
;;;1773   #define PXL_PHASE	9
;;;1774   void Read_Row(u8 row)
000188  b570              PUSH     {r4-r6,lr}
;;;1775   {
00018a  4605              MOV      r5,r0
;;;1776   	u8 i;
;;;1777   
;;;1778    	PCRChip_Command_Send[0]=0xC3;
00018c  20c3              MOVS     r0,#0xc3
00018e  49a0              LDR      r1,|L1.1040|
000190  7008              STRB     r0,[r1,#0]
;;;1779   	PCRChip_Command_Send[1]=0x00;
000192  2000              MOVS     r0,#0
000194  7048              STRB     r0,[r1,#1]
;;;1780   	PCRChip_Command_Send[2]=0xA1;
000196  20a1              MOVS     r0,#0xa1
000198  7088              STRB     r0,[r1,#2]
;;;1781   	PCRChip_Command_Send[3]=0xB5;
00019a  20b5              MOVS     r0,#0xb5
00019c  70c8              STRB     r0,[r1,#3]
;;;1782   	PCRChip_Command_Send[4]=0x21;
00019e  2021              MOVS     r0,#0x21
0001a0  7108              STRB     r0,[r1,#4]
;;;1783   	PCRChip_Command_Send[5]=0x61;
0001a2  2061              MOVS     r0,#0x61
0001a4  7148              STRB     r0,[r1,#5]
;;;1784   	/*
;;;1785   	PCRChip_Command_Send[6]=0x2D; 
;;;1786   	PCRChip_Command_Send[7]=0x00;
;;;1787   	*/
;;;1788        //Anitoa required to change it @ 12nd Oct.
;;;1789   	PCRChip_Command_Send[6]=0x29; 
0001a6  2029              MOVS     r0,#0x29
0001a8  7188              STRB     r0,[r1,#6]
;;;1790   	PCRChip_Command_Send[7]=0x21; 
0001aa  2021              MOVS     r0,#0x21
0001ac  71c8              STRB     r0,[r1,#7]
;;;1791   	PCRChip_Command_Send[8]=0x00; 
0001ae  2000              MOVS     r0,#0
0001b0  7208              STRB     r0,[r1,#8]
;;;1792   /*
;;;1793   	PCRChip_Command_Send[9]=0xf;
;;;1794    	PCRChip_Command_Send[9]=PCR_Regs.SW_TxCtrl=TX_PACK(0x0f,PCR_Regs.SW_TxCtrl);
;;;1795   	Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[9]);
;;;1796   */
;;;1797   //LED1=0;
;;;1798     	for(i=0;i<PXL_PHASE;i++)
0001b2  2400              MOVS     r4,#0
0001b4  e028              B        |L1.520|
                  |L1.438|
;;;1799   	{
;;;1800   		if(i==2)
0001b6  2c02              CMP      r4,#2
0001b8  d109              BNE      |L1.462|
;;;1801   		{
;;;1802   			while(TMR_Int_Flag==0);
0001ba  bf00              NOP      
                  |L1.444|
0001bc  4895              LDR      r0,|L1.1044|
0001be  8800              LDRH     r0,[r0,#0]  ; TMR_Int_Flag
0001c0  2800              CMP      r0,#0
0001c2  d0fb              BEQ      |L1.444|
;;;1803   			OSC_Ctrl=OSC_ON;
0001c4  2001              MOVS     r0,#1
0001c6  4994              LDR      r1,|L1.1048|
0001c8  6008              STR      r0,[r1,#0]
;;;1804   			OSC_Status=1;
0001ca  4994              LDR      r1,|L1.1052|
0001cc  7008              STRB     r0,[r1,#0]
                  |L1.462|
;;;1805   //	LED1=0;
;;;1806   		}
;;;1807   		Send_Command(PXL_DRIVE, row, 1, &PCRChip_Command_Send[i]);
0001ce  4890              LDR      r0,|L1.1040|
0001d0  1903              ADDS     r3,r0,r4
0001d2  2201              MOVS     r2,#1
0001d4  4629              MOV      r1,r5
0001d6  2003              MOVS     r0,#3
0001d8  f7fffffe          BL       Send_Command
;;;1808   		
;;;1809   		if(i==1)
0001dc  2c01              CMP      r4,#1
0001de  d111              BNE      |L1.516|
;;;1810   		{
;;;1811   			TIM3_ARR_Update(PCR_Regs.InteCount);
0001e0  498f              LDR      r1,|L1.1056|
0001e2  8948              LDRH     r0,[r1,#0xa]  ; PCR_Regs
0001e4  f7fffffe          BL       TIM3_ARR_Update
;;;1812   			BaseCounter= PCR_Regs.InteTime;
0001e8  488d              LDR      r0,|L1.1056|
0001ea  8900              LDRH     r0,[r0,#8]  ; PCR_Regs
0001ec  498d              LDR      r1,|L1.1060|
0001ee  8008              STRH     r0,[r1,#0]
;;;1813   			TMR_Int_Flag=0;
0001f0  2000              MOVS     r0,#0
0001f2  4988              LDR      r1,|L1.1044|
0001f4  8008              STRH     r0,[r1,#0]
;;;1814   			TIM3->CR1|=0x01; 
0001f6  488c              LDR      r0,|L1.1064|
0001f8  8800              LDRH     r0,[r0,#0]
0001fa  f0400001          ORR      r0,r0,#1
0001fe  07a1              LSLS     r1,r4,#30
000200  f8a10400          STRH     r0,[r1,#0x400]
                  |L1.516|
000204  1c60              ADDS     r0,r4,#1              ;1798
000206  b2c4              UXTB     r4,r0                 ;1798
                  |L1.520|
000208  2c09              CMP      r4,#9                 ;1798
00020a  dbd4              BLT      |L1.438|
;;;1815   //	LED1=1;
;;;1816   		}
;;;1817   		
;;;1818   	}
;;;1819   	delay_ms(10);
00020c  200a              MOVS     r0,#0xa
00020e  f7fffffe          BL       delay_ms
;;;1820   	Send_Command(ADC_START, 0, 0, &PCRChip_Command_Send[0]);
000212  4b7f              LDR      r3,|L1.1040|
000214  2200              MOVS     r2,#0
000216  4611              MOV      r1,r2
000218  2004              MOVS     r0,#4
00021a  f7fffffe          BL       Send_Command
;;;1821   	PCR_ADC_Done_Flag=0;
00021e  2000              MOVS     r0,#0
000220  4982              LDR      r1,|L1.1068|
000222  7008              STRB     r0,[r1,#0]
;;;1822   	while(PCR_ADC_Done_Flag==0);
000224  bf00              NOP      
                  |L1.550|
000226  4881              LDR      r0,|L1.1068|
000228  7800              LDRB     r0,[r0,#0]  ; PCR_ADC_Done_Flag
00022a  2800              CMP      r0,#0
00022c  d0fb              BEQ      |L1.550|
;;;1823   	if(OSC_mode != OSC_ON)
00022e  4880              LDR      r0,|L1.1072|
000230  7800              LDRB     r0,[r0,#0]  ; OSC_mode
000232  2801              CMP      r0,#1
000234  d004              BEQ      |L1.576|
;;;1824   	{
;;;1825   		OSC_Ctrl=OSC_OFF;
000236  2000              MOVS     r0,#0
000238  4977              LDR      r1,|L1.1048|
00023a  6008              STR      r0,[r1,#0]
;;;1826   		OSC_Status=0;
00023c  4977              LDR      r1,|L1.1052|
00023e  7008              STRB     r0,[r1,#0]
                  |L1.576|
;;;1827   	}	 
;;;1828   	Send_Command(PCR_ADC_READ, 0, 0, &PCRChip_Command_Send[0]);
000240  4b73              LDR      r3,|L1.1040|
000242  2200              MOVS     r2,#0
000244  4611              MOV      r1,r2
000246  2005              MOVS     r0,#5
000248  f7fffffe          BL       Send_Command
;;;1829   }
00024c  bd70              POP      {r4-r6,pc}
;;;1830   
                          ENDP

                  Trim_Reset PROC
;;;2367   
;;;2368   void Trim_Reset(void)
00024e  2088              MOVS     r0,#0x88
;;;2369   {
;;;2370   	PCR_Regs.RampTrim=0x88;
000250  4973              LDR      r1,|L1.1056|
000252  7008              STRB     r0,[r1,#0]
;;;2371   	PCR_Regs.RangTrim=0x08;
000254  2008              MOVS     r0,#8
000256  7048              STRB     r0,[r1,#1]
;;;2372   	PCR_Regs.Ipix_V24Trim=0x88;
000258  2088              MOVS     r0,#0x88
00025a  7088              STRB     r0,[r1,#2]
;;;2373   	PCR_Regs.V20_V15Trim=0x88;
00025c  70c8              STRB     r0,[r1,#3]
;;;2374   	PCR_Regs.SW_TxCtrl=0x08;
00025e  2008              MOVS     r0,#8
000260  7108              STRB     r0,[r1,#4]
;;;2375   	PCR_Regs.TsTADC_AmuxCtrl=0x00;
000262  2000              MOVS     r0,#0
000264  7148              STRB     r0,[r1,#5]
;;;2376   	BaseCounter=PCR_Regs.InteTime=DEFAULT_INTE ;
000266  2001              MOVS     r0,#1
000268  8108              STRH     r0,[r1,#8]
00026a  496e              LDR      r1,|L1.1060|
00026c  8008              STRH     r0,[r1,#0]
;;;2377   
;;;2378   }	
00026e  4770              BX       lr
;;;2379   
                          ENDP

                  main PROC
;;;133    } 
;;;134    int main(void)
000270  e92d4ff0          PUSH     {r4-r11,lr}
;;;135    {
000274  b08b              SUB      sp,sp,#0x2c
;;;136       	u8 tick;
;;;137    	u16 adcx;
;;;138    	u8 u8temp;	u8 CurrentRowNum;
;;;139    
;;;140    	u8 u8temp1,u8temp2,u8temp3;
;;;141    	u16 u16temp,u16temp1;
;;;142    	float f32temp1,f32temp2;
;;;143    	u8 ResCode;
;;;144    	u8 TransLen;
;;;145    
;;;146    	u8 VideoRow;
;;;147    
;;;148    	
;;;149    		
;;;150    	u8 key,ldecoun=0;
000276  2000              MOVS     r0,#0
000278  9005              STR      r0,[sp,#0x14]
;;;151    //	u8 Key_count=0;
;;;152    	u8 test_lenth=0;
00027a  9004              STR      r0,[sp,#0x10]
;;;153    	u16 j,i=0;
00027c  4683              MOV      r11,r0
;;;154    	#ifdef VEDIO_DEBUG
;;;155    	u8 DatChange=0;				
;;;156    	#endif
;;;157    
;;;158        PCR_Cycle_Init();
00027e  f7fffffe          BL       PCR_Cycle_Init
;;;159    	KL_temp.float_num=Kl[0];
000282  486c              LDR      r0,|L1.1076|
000284  6800              LDR      r0,[r0,#0]  ; Kl
000286  496c              LDR      r1,|L1.1080|
000288  6008              STR      r0,[r1,#0]  ; KL_temp
;;;160    	KP_temp.float_num=Kp[0];
00028a  486c              LDR      r0,|L1.1084|
00028c  6800              LDR      r0,[r0,#0]  ; Kp
00028e  496c              LDR      r1,|L1.1088|
000290  6008              STR      r0,[r1,#0]  ; KP_temp
;;;161    	KI_temp.float_num=Ki[0];
000292  486c              LDR      r0,|L1.1092|
000294  6800              LDR      r0,[r0,#0]  ; Ki
000296  496c              LDR      r1,|L1.1096|
000298  6008              STR      r0,[r1,#0]  ; KI_temp
;;;162    	KD_temp.float_num=Kd[0];
00029a  486c              LDR      r0,|L1.1100|
00029c  6800              LDR      r0,[r0,#0]  ; Kd
00029e  496c              LDR      r1,|L1.1104|
0002a0  6008              STR      r0,[r1,#0]  ; KD_temp
;;;163    	tick=0;
0002a2  2400              MOVS     r4,#0
;;;164     	Stm32_Clock_Init(9);	//系统时钟设置 --72M
0002a4  2009              MOVS     r0,#9
0002a6  f7fffffe          BL       Stm32_Clock_Init
;;;165    	uart_init(36,9600);	 	//串口初始化为9600
0002aa  f44f5116          MOV      r1,#0x2580
0002ae  2024              MOVS     r0,#0x24
0002b0  f7fffffe          BL       uart_init
;;;166    	delay_init(72);	   	 	//延时初始化 
0002b4  2048              MOVS     r0,#0x48
0002b6  f7fffffe          BL       delay_init
;;;167    	LED_Init();		  		//初始化与LED连接的硬件接口
0002ba  f7fffffe          BL       LED_Init
;;;168    	LED1=1;
0002be  2001              MOVS     r0,#1
0002c0  4955              LDR      r1,|L1.1048|
0002c2  3114              ADDS     r1,r1,#0x14
0002c4  6008              STR      r0,[r1,#0]
;;;169    
;;;170        LED_CTRL=0;
0002c6  2000              MOVS     r0,#0
0002c8  4962              LDR      r1,|L1.1108|
0002ca  f8c10194          STR      r0,[r1,#0x194]
;;;171    
;;;172    	FanCtrl_Init();
0002ce  f7fffffe          BL       FanCtrl_Init
;;;173    	OSC_Ctrl=OSC_OFF;
0002d2  2000              MOVS     r0,#0
0002d4  4950              LDR      r1,|L1.1048|
0002d6  6008              STR      r0,[r1,#0]
;;;174    	OSC_mode=OSC_AUTO;
0002d8  2002              MOVS     r0,#2
0002da  4955              LDR      r1,|L1.1072|
0002dc  7008              STRB     r0,[r1,#0]
;;;175    	OSC_Status=0;
0002de  2000              MOVS     r0,#0
0002e0  494e              LDR      r1,|L1.1052|
0002e2  7008              STRB     r0,[r1,#0]
;;;176    
;;;177    	PCR_RESET_PROCESS;
0002e4  495c              LDR      r1,|L1.1112|
0002e6  f8c101a0          STR      r0,[r1,#0x1a0]
0002ea  200a              MOVS     r0,#0xa
0002ec  f7fffffe          BL       delay_us
0002f0  2001              MOVS     r0,#1
0002f2  4949              LDR      r1,|L1.1048|
0002f4  3108              ADDS     r1,r1,#8
0002f6  6008              STR      r0,[r1,#0]
;;;178    																 
;;;179    	Trim_Reset();	
0002f8  f7fffffe          BL       Trim_Reset
;;;180    	KEY_Init();				//按键初始化	
0002fc  f7fffffe          BL       KEY_Init
;;;181    	EXTIX_Init();
000300  f7fffffe          BL       EXTIX_Init
;;;182    		 		  
;;;183    	SPI2_Initializaion();
000304  f7fffffe          BL       SPI2_Initializaion
;;;184    	#if defined(USB_WAIT_MODE)
;;;185    	EpMsgDisable();
000308  f7fffffe          BL       EpMsgDisable
;;;186    	#endif
;;;187    	//PCR_Regs.InteDelayCount=INTE_DELAY_COUNT;
;;;188    	PCR_Regs.InteDelayCount=INTERVAL_DELAY_COUNT;
00030c  203c              MOVS     r0,#0x3c
00030e  4944              LDR      r1,|L1.1056|
000310  8188              STRH     r0,[r1,#0xc]
;;;189    	PCR_Regs.InteTime=DEFAULT_INTE;//(u16)INTE_CYCLE_COUNT*(u16)TIME_US_PER_CNT;
000312  2001              MOVS     r0,#1
000314  8108              STRH     r0,[r1,#8]
;;;190    	PCR_Regs.InteCount=INTE_CYCLE_COUNT;
000316  2064              MOVS     r0,#0x64
000318  8148              STRH     r0,[r1,#0xa]
;;;191    
;;;192    	SPI_2_Rx_sts=SPI_IDLE;
00031a  2000              MOVS     r0,#0
00031c  494f              LDR      r1,|L1.1116|
00031e  7008              STRB     r0,[r1,#0]
;;;193    	//InteCnt= 4999;
;;;194    	TIM3_Int_Init(PCR_Regs.InteCount,TIM3_PSC_VAL);
000320  493f              LDR      r1,|L1.1056|
000322  8948              LDRH     r0,[r1,#0xa]  ; PCR_Regs
000324  f24021cf          MOV      r1,#0x2cf
000328  f7fffffe          BL       TIM3_Int_Init
;;;195    	TMR_Int_Flag=0;
00032c  2000              MOVS     r0,#0
00032e  4939              LDR      r1,|L1.1044|
000330  8008              STRH     r0,[r1,#0]
;;;196    	TIM3->CR1|=0x01;
000332  f04f4080          MOV      r0,#0x40000000
000336  f8b00400          LDRH     r0,[r0,#0x400]
00033a  f0400001          ORR      r0,r0,#1
00033e  493a              LDR      r1,|L1.1064|
000340  8008              STRH     r0,[r1,#0]
;;;197    	while(TMR_Int_Flag==0);
000342  bf00              NOP      
                  |L1.836|
000344  4833              LDR      r0,|L1.1044|
000346  8800              LDRH     r0,[r0,#0]  ; TMR_Int_Flag
000348  2800              CMP      r0,#0
00034a  d0fb              BEQ      |L1.836|
;;;198    	TMR_Int_Flag=0;
00034c  2000              MOVS     r0,#0
00034e  4931              LDR      r1,|L1.1044|
000350  8008              STRH     r0,[r1,#0]
;;;199    
;;;200    	Adc_Init();
000352  f7fffffe          BL       Adc_Init
;;;201    	IIC_Init();
000356  f7fffffe          BL       IIC_Init
;;;202    	TempContorl_2_Init();
00035a  f7fffffe          BL       TempContorl_2_Init
;;;203    	//TempSensor_Initial();
;;;204        //TempControl_Initial(50);
;;;205    	TempCtrl_Active=0;
00035e  2000              MOVS     r0,#0
000360  493f              LDR      r1,|L1.1120|
000362  7008              STRB     r0,[r1,#0]
;;;206    	TempValid=0;
000364  493f              LDR      r1,|L1.1124|
000366  7008              STRB     r0,[r1,#0]
;;;207    	Sensor_Res_Init();
000368  f7fffffe          BL       Sensor_Res_Init
;;;208    
;;;209     	usb_port_set(0); 	//USB先断开
00036c  2000              MOVS     r0,#0
00036e  f7fffffe          BL       usb_port_set
;;;210    	delay_ms(300);
000372  f44f7096          MOV      r0,#0x12c
000376  f7fffffe          BL       delay_ms
;;;211       	usb_port_set(1);	//USB再次连接
00037a  2001              MOVS     r0,#1
00037c  f7fffffe          BL       usb_port_set
;;;212    	//USB配置
;;;213     	USB_Interrupts_Config();    
000380  f7fffffe          BL       USB_Interrupts_Config
;;;214     	Set_USBClock();   
000384  f7fffffe          BL       Set_USBClock
;;;215     	USB_Init();					
000388  f7fffffe          BL       USB_Init
;;;216    
;;;217    	while(1)
00038c  f000bf95          B.W      |L1.4794|
                  |L1.912|
;;;218    	{
;;;219    
;;;220    /*
;;;221    	   do
;;;222    	   {
;;;223    
;;;224    			
;;;225    	   		TempCurrent_2=TempSensorRead(TEMP_SENSOR_2_ADDR_WR);
;;;226    			TempCurrent=TempSensorRead(STLM75_ADDR_WR);
;;;227    			//printf("%f \n",TempCurrent_2);
;;;228    			delay_ms(200);
;;;229    	   }while(1);
;;;230    */	   
;;;231    		
;;;232     /*	
;;;233    		TempCtrl_Active_2=1;
;;;234    		TempValid=2;
;;;235    		TempSet_2=10;
;;;236    		TempTickLength_2=60;
;;;237    		TempCurrent_2=TempSensorRead(STLM75_ADDR_WR);
;;;238    		TempControl_2_Initial(TempSet_2);
;;;239    		
;;;240    	  	do
;;;241    		{
;;;242    			if(TempCtrl_Active_2==4)
;;;243    			{
;;;244    				TempCtrl_Active_2=0;
;;;245    				TempControl_2_stop();
;;;246    			}else if(TempCtrl_Active_2==1)
;;;247    					{
;;;248    						TempCtrl_Active_2=2;
;;;249    						//TempSensor_Initial(TEMP2);
;;;250    						TempControl_2_Initial(TempSet_2);
;;;251    					}
;;;252    			
;;;253    				   else if(TempCtrl_Active_2!=0)
;;;254    							TempCurrent_2=TempSensorRead(STLM75_ADDR_WR);  // new sensor		
;;;255    		} while(1);
;;;256    */		
;;;257    /*
;;;258    		TempCtrl_Active=1;
;;;259    		TempValid |=1;
;;;260    		TempSet=40;
;;;261    		TempTickLength=60;
;;;262    		TempCurrent=TempSensorRead(STLM75_ADDR_WR);
;;;263    		TempControl_Initial(TempSet);
;;;264    
;;;265    		TempCtrl_Active_2=1;
;;;266    		TempValid |=2;
;;;267    		TempSet_2=40;
;;;268    		TempTickLength_2=60;
;;;269    		TempCurrent_2=TempSensorRead(STLM75_ADDR_WR);
;;;270    		TempControl_2_Initial(TempSet_2);
;;;271    		
;;;272    	  	do
;;;273    		{
;;;274    			if(TempCtrl_Active==4)
;;;275    			{
;;;276    				TempCtrl_Active=0;
;;;277    				TempControl_stop();
;;;278    			}else if(TempCtrl_Active==1)
;;;279    					{
;;;280    						TempCtrl_Active=2;
;;;281    						//TempSensor_Initial(TEMP2);
;;;282    						TempControl_Initial(TempSet);
;;;283    					}
;;;284    			
;;;285    				   else if(TempCtrl_Active!=0)
;;;286    							TempCurrent=TempSensorRead(STLM75_ADDR_WR);  // new sensor
;;;287    							
;;;288    							
;;;289    			if(TempCtrl_Active_2==4)
;;;290    			{
;;;291    				TempCtrl_Active_2=0;
;;;292    				TempControl_2_stop();
;;;293    			}else if(TempCtrl_Active_2==1)
;;;294    					{
;;;295    						TempCtrl_Active_2=2;
;;;296    						//TempSensor_Initial(TEMP2);
;;;297    						TempControl_2_Initial(TempSet_2);
;;;298    					}
;;;299    			
;;;300    				   else if(TempCtrl_Active_2!=0)
;;;301    							TempCurrent_2=TempSensorRead(STLM75_ADDR_WR);  // new sensor
;;;302    									
;;;303    		} while(1);
;;;304    */
;;;305    		//do
;;;306    		//{
;;;307            ////2 brd branch
;;;308    		if(mst_flag==BRD_IN_TRG)
000390  4835              LDR      r0,|L1.1128|
000392  7800              LDRB     r0,[r0,#0]  ; mst_flag
000394  2801              CMP      r0,#1
000396  d105              BNE      |L1.932|
;;;309    		{
;;;310    			ResCode=0;
000398  2000              MOVS     r0,#0
00039a  9008              STR      r0,[sp,#0x20]
;;;311    			TransLen=1;
00039c  2001              MOVS     r0,#1
00039e  9007              STR      r0,[sp,#0x1c]
;;;312    			TxBuffer[0]=(0| TRG_VALID) ;
0003a0  4932              LDR      r1,|L1.1132|
0003a2  7008              STRB     r0,[r1,#0]
                  |L1.932|
;;;313    		//txc//	USBRes(ResCode, CMD_HOST_NOTIFY,TxBuffer,TransLen);
;;;314    		}
;;;315    
;;;316    /*		
;;;317    		if(mst_flag==BRD_IN_TRG)    
;;;318    		{
;;;319    			//if(TRG_IMG==1)      // new trg happen
;;;320    			{
;;;321    			   //trg_count+=1;
;;;322    			   mst_flag = BRD_IN_PROCESS; // handle this trg, & in LED ctrl
;;;323    			   TIM7_Init();
;;;324    			   LED_CTRL=1;
;;;325    			}
;;;326    		
;;;327    		}
;;;328    		else if(mst_flag == BRD_IN_PROCESS)
;;;329    		{
;;;330    			
;;;331    			{
;;;332    				if(Time_LED_Delay>=SetTm_LED_Delay)
;;;333    				{
;;;334    					TIM7_Stop();				
;;;335    
;;;336    					//UARTRes(NO_ERR, CMD_AUTO_CAPTURE,&trg_count,1);
;;;337    
;;;338    					if(PCR_Regs.InteTime>10)
;;;339    					{		
;;;340    						PixReadmMode=TYP_IMAGE;
;;;341    						ReadUpdate_Image(); 
;;;342    					}
;;;343    					else
;;;344    					{
;;;345    						PixReadmMode=TYP_ROW;
;;;346    						ResCode=NO_ERR;
;;;347    						for(CurrentRowNum=0;CurrentRowNum<PIX_TOTAL_ROW;CurrentRowNum++)
;;;348    						{
;;;349    							
;;;350    							Read_Row(CurrentRowNum);
;;;351    						    TxBuffer[0]=TYP_IMAGE;
;;;352    							TxBuffer[1]=CurrentRowNum;
;;;353    							for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;354    								TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
;;;355    	
;;;356    							TransLen=(PIX_TOTAL_COL<<1)+2;
;;;357    							UARTRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;358    						}
;;;359    				   }
;;;360    				   LED_CTRL=0;
;;;361    				   mst_flag=BRD_IN_IDLE;
;;;362    				}
;;;363    			}
;;;364    		}
;;;365    */
;;;366    		////2 brd branch
;;;367    		
;;;368    		if(TempValid & 0x1)	// Temp1 Control valid
0003a4  482f              LDR      r0,|L1.1124|
0003a6  7800              LDRB     r0,[r0,#0]  ; TempValid
0003a8  f0100f01          TST      r0,#1
0003ac  d07f              BEQ      |L1.1198|
;;;369    		{
;;;370    			if(TempCtrl_Active==4)
0003ae  482c              LDR      r0,|L1.1120|
0003b0  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active
0003b2  2804              CMP      r0,#4
0003b4  d10b              BNE      |L1.974|
;;;371    			{
;;;372    				TempCtrl_Active=0;
0003b6  2000              MOVS     r0,#0
0003b8  4929              LDR      r1,|L1.1120|
0003ba  7008              STRB     r0,[r1,#0]
;;;373    				TempValid &=~ 0x1;
0003bc  4829              LDR      r0,|L1.1124|
0003be  7800              LDRB     r0,[r0,#0]  ; TempValid
0003c0  f0200001          BIC      r0,r0,#1
0003c4  4927              LDR      r1,|L1.1124|
0003c6  7008              STRB     r0,[r1,#0]
;;;374    				TempControl_stop();
0003c8  f7fffffe          BL       TempControl_stop
0003cc  e06f              B        |L1.1198|
                  |L1.974|
;;;375    			}else if(TempCtrl_Active==1)
0003ce  4824              LDR      r0,|L1.1120|
0003d0  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active
0003d2  2801              CMP      r0,#1
0003d4  d150              BNE      |L1.1144|
;;;376    					{
;;;377    						TempCtrl_Active=2;
0003d6  2002              MOVS     r0,#2
0003d8  4921              LDR      r1,|L1.1120|
0003da  7008              STRB     r0,[r1,#0]
;;;378    						//TempSensor_Initial(TEMP1);
;;;379    						TempControl_Initial(TempSet);
0003dc  4824              LDR      r0,|L1.1136|
0003de  6800              LDR      r0,[r0,#0]  ; TempSet
0003e0  f7fffffe          BL       TempControl_Initial
;;;380    						TempCurrent=TempSensorRead(STLM75_ADDR_WR);
0003e4  2090              MOVS     r0,#0x90
0003e6  f7fffffe          BL       TempSensorRead
0003ea  4922              LDR      r1,|L1.1140|
0003ec  6008              STR      r0,[r1,#0]  ; TempCurrent
0003ee  e05e              B        |L1.1198|
                  |L1.1008|
                          DCD      0x40021000
                  |L1.1012|
                          DCD      0x40005c40
                  |L1.1016|
                          DCD      0x40005000
                  |L1.1020|
                          DCD      0x40010000
                  |L1.1024|
                          DCD      0x40010804
                  |L1.1028|
                          DCD      0x422101b0
                  |L1.1032|
                          DCD      Transi_Buffer
                  |L1.1036|
                          DCD      ||.data||+0x51
                  |L1.1040|
                          DCD      PCRChip_Command_Send
                  |L1.1044|
                          DCD      TMR_Int_Flag
                  |L1.1048|
                          DCD      0x42240198
                  |L1.1052|
                          DCD      OSC_Status
                  |L1.1056|
                          DCD      PCR_Regs
                  |L1.1060|
                          DCD      BaseCounter
                  |L1.1064|
                          DCD      0x40000400
                  |L1.1068|
                          DCD      PCR_ADC_Done_Flag
                  |L1.1072|
                          DCD      OSC_mode
                  |L1.1076|
                          DCD      ||Kl||
                  |L1.1080|
                          DCD      KL_temp
                  |L1.1084|
                          DCD      ||Kp||
                  |L1.1088|
                          DCD      KP_temp
                  |L1.1092|
                          DCD      ||Ki||
                  |L1.1096|
                          DCD      KI_temp
                  |L1.1100|
                          DCD      ||Kd||
                  |L1.1104|
                          DCD      KD_temp
                  |L1.1108|
                          DCD      0x42238000
                  |L1.1112|
                          DCD      0x42240000
                  |L1.1116|
                          DCD      SPI_2_Rx_sts
                  |L1.1120|
                          DCD      TempCtrl_Active
                  |L1.1124|
                          DCD      TempValid
                  |L1.1128|
                          DCD      mst_flag
                  |L1.1132|
                          DCD      TxBuffer
                  |L1.1136|
                          DCD      TempSet
                  |L1.1140|
                          DCD      TempCurrent
                  |L1.1144|
;;;381    					}
;;;382    			
;;;383    				   else if(TempCtrl_Active!=0)
000478  48ff              LDR      r0,|L1.2168|
00047a  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active
00047c  b1b8              CBZ      r0,|L1.1198|
;;;384    				   		{
;;;385    							//TempCurrent=TempSensorRead(STLM75_ADDR_WR);
;;;386    
;;;387    							if(TempCurrent<TempSet)
00047e  48ff              LDR      r0,|L1.2172|
000480  6801              LDR      r1,[r0,#0]  ; TempSet
000482  48ff              LDR      r0,|L1.2176|
000484  6800              LDR      r0,[r0,#0]  ; TempCurrent
000486  f7fffffe          BL       __aeabi_cfcmple
00048a  d210              BCS      |L1.1198|
;;;388    							     TempCurrent+=0.5;
00048c  48fc              LDR      r0,|L1.2176|
00048e  6800              LDR      r0,[r0,#0]  ; TempCurrent
000490  f7fffffe          BL       __aeabi_f2d
000494  e9cd0102          STRD     r0,r1,[sp,#8]
000498  a0fa              ADR      r0,|L1.2180|
00049a  c80c              LDM      r0!,{r2,r3}
00049c  9802              LDR      r0,[sp,#8]
00049e  f7fffffe          BL       __aeabi_dadd
0004a2  e9cd0100          STRD     r0,r1,[sp,#0]
0004a6  f7fffffe          BL       __aeabi_d2f
0004aa  49f5              LDR      r1,|L1.2176|
0004ac  6008              STR      r0,[r1,#0]  ; TempCurrent
                  |L1.1198|
;;;389    						}
;;;390    		}
;;;391    			
;;;392    
;;;393    		if(TempValid & 0x2)	// Temp2 Control valid
0004ae  48f7              LDR      r0,|L1.2188|
0004b0  7800              LDRB     r0,[r0,#0]  ; TempValid
0004b2  f0100f02          TST      r0,#2
0004b6  d046              BEQ      |L1.1350|
;;;394    		{
;;;395    
;;;396    			if((Peltier_Swap_Msg & SENSOR_2) !=0) // channel 2 swap msg
0004b8  48f5              LDR      r0,|L1.2192|
0004ba  7800              LDRB     r0,[r0,#0]  ; Peltier_Swap_Msg
0004bc  f0100f02          TST      r0,#2
0004c0  d002              BEQ      |L1.1224|
;;;397    				Channel_Swap(SENSOR_2);
0004c2  2002              MOVS     r0,#2
0004c4  f7fffffe          BL       Channel_Swap
                  |L1.1224|
;;;398    				
;;;399    			if(TempCtrl_Active_2==4)
0004c8  48f2              LDR      r0,|L1.2196|
0004ca  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active_2
0004cc  2804              CMP      r0,#4
0004ce  d10e              BNE      |L1.1262|
;;;400    			{
;;;401    				if(CycleSTS==READY)	  // @0607, if not in cycle mode, just stop it
0004d0  48f1              LDR      r0,|L1.2200|
0004d2  7800              LDRB     r0,[r0,#0]  ; CycleSTS
0004d4  2800              CMP      r0,#0
0004d6  d136              BNE      |L1.1350|
;;;402    				                      //        else dot not stop, MsgHandler will handle it 
;;;403    				{
;;;404    					TempCtrl_Active_2=0;
0004d8  49ee              LDR      r1,|L1.2196|
0004da  7008              STRB     r0,[r1,#0]
;;;405    					TempValid &=~ 0x2;
0004dc  48eb              LDR      r0,|L1.2188|
0004de  7800              LDRB     r0,[r0,#0]  ; TempValid
0004e0  f0200002          BIC      r0,r0,#2
0004e4  49e9              LDR      r1,|L1.2188|
0004e6  7008              STRB     r0,[r1,#0]
;;;406    					TempControl_2_stop();
0004e8  f7fffffe          BL       TempControl_2_stop
0004ec  e02b              B        |L1.1350|
                  |L1.1262|
;;;407    				}
;;;408    				#ifdef DEBUG_MSG
;;;409    					msg_debug=0;
;;;410    				#endif
;;;411    			}else if(TempCtrl_Active_2==1)
0004ee  48e9              LDR      r0,|L1.2196|
0004f0  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active_2
0004f2  2801              CMP      r0,#1
0004f4  d10c              BNE      |L1.1296|
;;;412    					{
;;;413    						TempCtrl_Active_2=2;
0004f6  2002              MOVS     r0,#2
0004f8  49e6              LDR      r1,|L1.2196|
0004fa  7008              STRB     r0,[r1,#0]
;;;414    						TempControl_2_Initial(TempSet_2);
0004fc  48e7              LDR      r0,|L1.2204|
0004fe  6800              LDR      r0,[r0,#0]  ; TempSet_2
000500  f7fffffe          BL       TempControl_2_Initial
;;;415    						TempCurrent_2=TempSensorRead(TEMP_SENSOR_2_ADDR_WR);
000504  2092              MOVS     r0,#0x92
000506  f7fffffe          BL       TempSensorRead
00050a  49e5              LDR      r1,|L1.2208|
00050c  6008              STR      r0,[r1,#0]  ; TempCurrent_2
00050e  e01a              B        |L1.1350|
                  |L1.1296|
;;;416    					}
;;;417    			
;;;418    				   else if(TempCtrl_Active_2!=0)
000510  48e0              LDR      r0,|L1.2196|
000512  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active_2
000514  b1b8              CBZ      r0,|L1.1350|
;;;419    				   		{
;;;420    							//TempCurrent_2=TempSensorRead(TEMP_SENSOR_2_ADDR_WR);  // new sensor
;;;421    
;;;422    							if(TempCurrent_2<TempSet_2)
000516  48e1              LDR      r0,|L1.2204|
000518  6801              LDR      r1,[r0,#0]  ; TempSet_2
00051a  48e1              LDR      r0,|L1.2208|
00051c  6800              LDR      r0,[r0,#0]  ; TempCurrent_2
00051e  f7fffffe          BL       __aeabi_cfcmple
000522  d210              BCS      |L1.1350|
;;;423    							     TempCurrent_2+=0.5;
000524  48de              LDR      r0,|L1.2208|
000526  6800              LDR      r0,[r0,#0]  ; TempCurrent_2
000528  f7fffffe          BL       __aeabi_f2d
00052c  e9cd0102          STRD     r0,r1,[sp,#8]
000530  a0d4              ADR      r0,|L1.2180|
000532  c80c              LDM      r0!,{r2,r3}
000534  9802              LDR      r0,[sp,#8]
000536  f7fffffe          BL       __aeabi_dadd
00053a  e9cd0100          STRD     r0,r1,[sp,#0]
00053e  f7fffffe          BL       __aeabi_d2f
000542  49d7              LDR      r1,|L1.2208|
000544  6008              STR      r0,[r1,#0]  ; TempCurrent_2
                  |L1.1350|
;;;424    						}
;;;425     
;;;426    		#ifdef DEBUG_MSG
;;;427    				if(msg_debug>4)
;;;428    				{
;;;429    					printf("%f \n",TempCurrent_2);
;;;430    				}
;;;431    		#endif
;;;432    		}
;;;433    		//}while(1);
;;;434    		if(CycleSTS != READY)
000546  48d4              LDR      r0,|L1.2200|
000548  7800              LDRB     r0,[r0,#0]  ; CycleSTS
00054a  b108              CBZ      r0,|L1.1360|
;;;435    			MsgHandler();
00054c  f7fffffe          BL       MsgHandler
                  |L1.1360|
;;;436    
;;;437    
;;;438    		if(PixReadmMode==TYP_VIDEO)
000550  48d4              LDR      r0,|L1.2212|
000552  7800              LDRB     r0,[r0,#0]  ; PixReadmMode
000554  2803              CMP      r0,#3
000556  d12f              BNE      |L1.1464|
;;;439    		{
;;;440    
;;;441    			Read_Row(VideoRow); /* access a row*/
000558  9806              LDR      r0,[sp,#0x18]
00055a  f7fffffe          BL       Read_Row
;;;442    			ResCode=NO_ERR;
00055e  2000              MOVS     r0,#0
000560  9008              STR      r0,[sp,#0x20]
;;;443    		    TxBuffer[0]=TYP_VIDEO;
000562  2003              MOVS     r0,#3
000564  49d0              LDR      r1,|L1.2216|
000566  7008              STRB     r0,[r1,#0]
;;;444    			TxBuffer[1]=VideoRow;
000568  9806              LDR      r0,[sp,#0x18]
00056a  7048              STRB     r0,[r1,#1]
;;;445    			for(i=0;i<(PIX_TOTAL_COL<<1);i++)
00056c  f04f0b00          MOV      r11,#0
000570  e009              B        |L1.1414|
                  |L1.1394|
;;;446    				TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
000572  48ce              LDR      r0,|L1.2220|
000574  f810100b          LDRB     r1,[r0,r11]
000578  4acb              LDR      r2,|L1.2216|
00057a  f10b0002          ADD      r0,r11,#2
00057e  5411              STRB     r1,[r2,r0]
000580  1e40              SUBS     r0,r0,#1              ;445
000582  fa1ffb80          UXTH     r11,r0                ;445
                  |L1.1414|
000586  f1bb0f1a          CMP      r11,#0x1a             ;445
00058a  dbf2              BLT      |L1.1394|
;;;447    			#ifdef VEDIO_DEBUG
;;;448    			for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;449    				TxBuffer[i+2]=DatChange;
;;;450    			if(VideoRow==(PIX_TOTAL_ROW-1))
;;;451    				DatChange++;				
;;;452    			#endif
;;;453    			TransLen=(PIX_TOTAL_ROW<<1)+2;
00058c  201a              MOVS     r0,#0x1a
00058e  9007              STR      r0,[sp,#0x1c]
;;;454    			USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
000590  4ac5              LDR      r2,|L1.2216|
000592  2102              MOVS     r1,#2
000594  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000598  f7fffffe          BL       USBRes
;;;455    			#if !defined(USB_WAIT_MODE)
;;;456    			delay_ms(35);
;;;457    			#else
;;;458    			EpMsgEnable();
00059c  f7fffffe          BL       EpMsgEnable
;;;459    			UsbReadDone();
0005a0  f7fffffe          BL       UsbReadDone
;;;460    			EpMsgDisable();
0005a4  f7fffffe          BL       EpMsgDisable
;;;461    			#endif	 
;;;462    			if((++VideoRow)==PIX_TOTAL_ROW)
0005a8  9806              LDR      r0,[sp,#0x18]
0005aa  1c40              ADDS     r0,r0,#1
0005ac  b2c0              UXTB     r0,r0
0005ae  9006              STR      r0,[sp,#0x18]
0005b0  280c              CMP      r0,#0xc
0005b2  d101              BNE      |L1.1464|
;;;463    				VideoRow=0;		
0005b4  2000              MOVS     r0,#0
0005b6  9006              STR      r0,[sp,#0x18]
                  |L1.1464|
;;;464    		}
;;;465    
;;;466    		if(USB_ReceiveFlg==TRUE)
0005b8  48bd              LDR      r0,|L1.2224|
0005ba  7800              LDRB     r0,[r0,#0]  ; USB_ReceiveFlg
0005bc  2801              CMP      r0,#1
0005be  d109              BNE      |L1.1492|
;;;467    		{
;;;468    			RxStage= CMPLT;
0005c0  2003              MOVS     r0,#3
0005c2  49bc              LDR      r1,|L1.2228|
0005c4  7008              STRB     r0,[r1,#0]
;;;469    			RxIdx=USB_RxIdx;
0005c6  48bc              LDR      r0,|L1.2232|
0005c8  8800              LDRH     r0,[r0,#0]  ; USB_RxIdx
0005ca  49bc              LDR      r1,|L1.2236|
0005cc  7008              STRB     r0,[r1,#0]
;;;470    			USB_ReceiveFlg=FALSE;
0005ce  2000              MOVS     r0,#0
0005d0  49b7              LDR      r1,|L1.2224|
0005d2  7008              STRB     r0,[r1,#0]
                  |L1.1492|
;;;471    		//	USBRes(0, 1,RxBuffer, 0);
;;;472    		}
;;;473    		/*
;;;474    #if defined(PIX24_DEBUG_UART_PRINT)
;;;475    		 RxStage=CMPLT;
;;;476    		 RxBuffer[0]=0xaa;
;;;477    		 RxBuffer[1]=CMD_GET;
;;;478    		 RxBuffer[2]=0x2;
;;;479    		 RxBuffer[3]=TYP_24PIXROW;
;;;480    		 RxBuffer[4]=0x0;
;;;481    		 RxBuffer[5]=0xb;
;;;482    		 RxBuffer[6]=0x17;
;;;483    		 RxBuffer[7]=0x17;
;;;484    		 RxIdx=0x7;
;;;485    #endif
;;;486    */
;;;487    	   	if(RxStage==CMPLT)
0005d4  48b7              LDR      r0,|L1.2228|
0005d6  7800              LDRB     r0,[r0,#0]  ; RxStage
0005d8  2803              CMP      r0,#3
                  |L1.1498|
0005da  d172              BNE      |L1.1730|
;;;488    		{
;;;489    			Command_Len=RxIdx;
0005dc  48b7              LDR      r0,|L1.2236|
0005de  7800              LDRB     r0,[r0,#0]  ; RxIdx
0005e0  49b7              LDR      r1,|L1.2240|
0005e2  7008              STRB     r0,[r1,#0]
;;;490    			for(i=0;i<Command_Len;i++)
0005e4  f04f0b00          MOV      r11,#0
0005e8  e009              B        |L1.1534|
                  |L1.1514|
;;;491    				Comand_Buf[i]=RxBuffer[i];
0005ea  48b6              LDR      r0,|L1.2244|
0005ec  f810000b          LDRB     r0,[r0,r11]
0005f0  49b5              LDR      r1,|L1.2248|
0005f2  f801000b          STRB     r0,[r1,r11]
0005f6  f10b0001          ADD      r0,r11,#1             ;490
0005fa  fa1ffb80          UXTH     r11,r0                ;490
                  |L1.1534|
0005fe  48b0              LDR      r0,|L1.2240|
000600  7800              LDRB     r0,[r0,#0]            ;490  ; Command_Len
000602  4583              CMP      r11,r0                ;490
000604  dbf1              BLT      |L1.1514|
;;;492    			
;;;493    			RxStage=IDLE;
000606  2000              MOVS     r0,#0
000608  49aa              LDR      r1,|L1.2228|
00060a  7008              STRB     r0,[r1,#0]
;;;494    			RxIdx=0;
00060c  49ab              LDR      r1,|L1.2236|
00060e  7008              STRB     r0,[r1,#0]
;;;495    			
;;;496    			if(PacketChkSum(Comand_Buf, Command_Len)==TRUE)
000610  48ab              LDR      r0,|L1.2240|
000612  7801              LDRB     r1,[r0,#0]  ; Command_Len
000614  48ac              LDR      r0,|L1.2248|
000616  f7fffffe          BL       PacketChkSum
00061a  2801              CMP      r0,#1
00061c  d1dd              BNE      |L1.1498|
;;;497    			{
;;;498    					
;;;499    				switch(Comand_Buf[CMD_BYTE_NUM])
00061e  48aa              LDR      r0,|L1.2248|
000620  7840              LDRB     r0,[r0,#1]  ; Comand_Buf
000622  2810              CMP      r0,#0x10
000624  d07e              BEQ      |L1.1828|
000626  dc08              BGT      |L1.1594|
000628  2801              CMP      r0,#1
00062a  d010              BEQ      |L1.1614|
00062c  2802              CMP      r0,#2
00062e  d00d              BEQ      |L1.1612|
000630  2804              CMP      r0,#4
000632  d078              BEQ      |L1.1830|
000634  2808              CMP      r0,#8
                  |L1.1590|
000636  d177              BNE      |L1.1832|
000638  e0f9              B        |L1.2094|
                  |L1.1594|
00063a  2811              CMP      r0,#0x11
00063c  d075              BEQ      |L1.1834|
00063e  2812              CMP      r0,#0x12
000640  d074              BEQ      |L1.1836|
000642  2813              CMP      r0,#0x13
000644  d073              BEQ      |L1.1838|
000646  2814              CMP      r0,#0x14
000648  d1f5              BNE      |L1.1590|
00064a  e3fe              B        |L1.3658|
                  |L1.1612|
;;;500    				{
;;;501    					case CMD_GET:
;;;502    							/*
;;;503    					txc
;;;504    							switch(Comand_Buf[TYP_BYTE_NUM])
;;;505    								{
;;;506    									case TYP_ROW:
;;;507    										
;;;508    										PixReadmMode=TYP_ROW;	  
;;;509    										CurrentRowNum=Comand_Buf[TYP_BYTE_NUM+1];
;;;510    										if(CurrentRowNum > PIX_TOTAL_ROW)  
;;;511    										{	//LPG:  invalid row number
;;;512    											ResCode=ERR_ROW;
;;;513    											TxBuffer[0]= TYP_ROW;
;;;514    											TransLen=1;
;;;515    										}	
;;;516    										else
;;;517    										{
;;;518    										Read_Row(CurrentRowNum); /* access a row*txc/
;;;519    										ResCode=NO_ERR;
;;;520    									    TxBuffer[0]=TYP_ROW;
;;;521    										TxBuffer[1]=CurrentRowNum;
;;;522    										for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;523    											TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
;;;524    
;;;525    										TransLen=(PIX_TOTAL_COL<<1)+2;
;;;526    										}
;;;527    										USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;528    										//PixReadmMode=DISABLE;
;;;529    										#if !defined(USB_WAIT_MODE)
;;;530    										delay_ms(35);
;;;531    										#else
;;;532    										EpMsgEnable();
;;;533    										UsbReadDone();
;;;534    										EpMsgDisable();
;;;535    										#endif	 
;;;536    										break;
;;;537    
;;;538    									 case TYP_IMAGE:
;;;539    
;;;540    									    //modify @ 140301:
;;;541    										//required by Anitoa @140218, if inteTime ,10ms, use row mode
;;;542    										if(PCR_Regs.InteTime>10)
;;;543    										{		
;;;544    											PixReadmMode=TYP_IMAGE;
;;;545    											ReadUpdate_Image(); /* access a image*txc/
;;;546    										}
;;;547    										else
;;;548    										{
;;;549    											PixReadmMode=TYP_ROW;
;;;550    											ResCode=NO_ERR;
;;;551    											for(CurrentRowNum=0;CurrentRowNum<PIX_TOTAL_ROW;CurrentRowNum++)
;;;552    											{
;;;553    												
;;;554    												Read_Row(CurrentRowNum);
;;;555    											    TxBuffer[0]=TYP_IMAGE;
;;;556    												TxBuffer[1]=CurrentRowNum;
;;;557    												for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;558    													TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
;;;559    		
;;;560    												TransLen=(PIX_TOTAL_COL<<1)+2;
;;;561    												USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;562    												#if !defined(USB_WAIT_MODE)
;;;563    												delay_ms(35);
;;;564    												#else
;;;565    												EpMsgEnable();
;;;566    												UsbReadDone();
;;;567    												EpMsgDisable();
;;;568    												#endif	 
;;;569    											}	
;;;570    										}
;;;571    									 	break;
;;;572    
;;;573    									 case TYP_VIDEO:
;;;574    									 	if(Comand_Buf[TYP_BYTE_NUM+1]==ENABLE)
;;;575    										{
;;;576    											PixReadmMode=TYP_VIDEO;
;;;577    											VideoRow=0;
;;;578    										}
;;;579    										else
;;;580    										{
;;;581    											PixReadmMode=DISABLE; /* stop reading image*txc/ 
;;;582    											VideoRow=0;
;;;583    										}
;;;584    										break;
;;;585    
;;;586    
;;;587    									case TYP_DEBUG_1:	  // XinChuang required to debug @ 13-10-22
;;;588    
;;;589    										Send_Command(PCR_ADC_READ, 0, 0, &PCRChip_Command_Send[0]);	
;;;590    										ResCode=NO_ERR;
;;;591    									    TxBuffer[0]=TYP_ROW;
;;;592    										TxBuffer[1]=CurrentRowNum;
;;;593    										for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;594    											TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
;;;595    
;;;596    										TransLen=(PIX_TOTAL_COL<<1)+2;
;;;597    										USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;598    										
;;;599    										break;
;;;600    
;;;601    									case TYP_DEBUG_2:
;;;602     										PixReadmMode=TYP_ROW;
;;;603    										Read_Row_Debug_2();	
;;;604    										ResCode=NO_ERR;
;;;605    									    TxBuffer[0]=TYP_ROW;
;;;606    										TxBuffer[1]=CurrentRowNum;
;;;607    										for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;608    											TxBuffer[i+2]= SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
;;;609    
;;;610    										TransLen=(PIX_TOTAL_COL<<1)+2;
;;;611    										USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;612    										break;
;;;613    
;;;614    									case TYP_24PIXROW:  //row
;;;615    
;;;616    										//PixReadmMode=TYP_24PIXROW;
;;;617    										PixReadmMode=TYP_24PIXIMAG;		  
;;;618    										CurrentRowNum=Comand_Buf[TYP_BYTE_NUM+1];
;;;619    										if(CurrentRowNum > 24)  
;;;620    										{	/*LPG:  invalid row number*txc/
;;;621    											ResCode=ERR_ROW;
;;;622    											TransLen=0;
;;;623    											USBRes(ResCode, CMD_GET,TxBuffer,TransLen);
;;;624    										}	
;;;625    										else
;;;626    										{
;;;627    											if(PCR_Regs.InteTime>10)
;;;628    										 		ReadUpdate_Image24_XC(TYP_24PIXROW,CurrentRowNum);
;;;629    											else
;;;630    												ReadUpdate_Image24_slow(TYP_24PIXROW,CurrentRowNum);
;;;631    										}
;;;632    										break;
;;;633    										 
;;;634    									case TYP_24PIXIMAG:  //frame
;;;635    
;;;636    										ResCode=NO_ERR;
;;;637    										PixReadmMode=TYP_24PIXIMAG;
;;;638    									    CurrentRowNum=Comand_Buf[TYP_BYTE_NUM+1];
;;;639    
;;;640    										if(PCR_Regs.InteTime>10)
;;;641    											ReadUpdate_Image24_XC(TYP_24PIXIMAG,IMAGE_24); /* access a image*txc/
;;;642    										else
;;;643    											ReadUpdate_Image24_slow(TYP_24PIXIMAG,IMAGE_24);
;;;644    										PixReadmMode=DISABLE;
;;;645    										break;
;;;646    
;;;647    
;;;648    									default:
;;;649    										break;
;;;650    									txc
;;;651    									
;;;652    								
;;;653    								}*/
;;;654    							
;;;655    						break;
00064c  e349              B        |L1.3298|
                  |L1.1614|
;;;656    	
;;;657    
;;;658    					case  CMD_SET:
;;;659    							if(Comand_Buf[LEN_BYTE_NUM]<MIN_PACKET_LENGTH)
00064e  489e              LDR      r0,|L1.2248|
000650  7880              LDRB     r0,[r0,#2]  ; Comand_Buf
000652  2801              CMP      r0,#1
000654  da04              BGE      |L1.1632|
;;;660    							 {
;;;661    							 	ResCode=ERR_LENGTH;
000656  2001              MOVS     r0,#1
000658  9008              STR      r0,[sp,#0x20]
;;;662    								TransLen=0;
00065a  2000              MOVS     r0,#0
00065c  9007              STR      r0,[sp,#0x1c]
00065e  e086              B        |L1.1902|
                  |L1.1632|
;;;663    							 }
;;;664    							 else
;;;665    							 {
;;;666    								 switch (Comand_Buf[TYP_BYTE_NUM])
000660  4899              LDR      r0,|L1.2248|
000662  78c0              LDRB     r0,[r0,#3]  ; Comand_Buf
000664  2821              CMP      r0,#0x21
000666  d004              BEQ      |L1.1650|
000668  2822              CMP      r0,#0x22
00066a  d033              BEQ      |L1.1748|
00066c  2823              CMP      r0,#0x23
00066e  d175              BNE      |L1.1884|
000670  e066              B        |L1.1856|
                  |L1.1650|
;;;667    								 {
;;;668    								  	/*
;;;669    									// txc
;;;670    									 case RAMP_TRIM:	// 0x1	
;;;671    	  										ResCode=NO_ERR;
;;;672    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;673    											PCRChip_Command_Send[0]=PCR_Regs.RampTrim=RAMP_PACK(u8temp,PCR_Regs.RampTrim);
;;;674    											Send_Command(REG_WRITE, RAMP_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);
;;;675    											TxBuffer[0]= RAMP_TRIM;
;;;676    											TransLen=1;
;;;677    										break;
;;;678    	
;;;679    	
;;;680    									case RANG_TRIM: // 0x2
;;;681    	  										ResCode=NO_ERR;
;;;682    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;683    											PCRChip_Command_Send[0]=PCR_Regs.RangTrim=RANG_PACK(u8temp,PCR_Regs.RangTrim);
;;;684    											Send_Command(REG_WRITE, RANG_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);
;;;685    											TxBuffer[0]= RANG_TRIM;
;;;686    											TransLen=1;
;;;687    										break;
;;;688    	
;;;689    									case V24_TRIM:	//0x3
;;;690    	  										ResCode=NO_ERR;
;;;691    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;692    											PCRChip_Command_Send[0]=PCR_Regs.Ipix_V24Trim=V24_PACK(u8temp,PCR_Regs.Ipix_V24Trim);
;;;693    											Send_Command(REG_WRITE, V24_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);											
;;;694    											TxBuffer[0]= V24_TRIM;
;;;695    											TransLen=1;							
;;;696    										break;
;;;697    										
;;;698    									case V20_TRIM:	//0x4
;;;699    	  										ResCode=NO_ERR;
;;;700    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;701    											PCRChip_Command_Send[0]=PCR_Regs.V20_V15Trim=V20_PACK(u8temp,PCR_Regs.V20_V15Trim);
;;;702    											Send_Command(REG_WRITE, V20_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);
;;;703    											TxBuffer[0]= V20_TRIM;
;;;704    											TransLen=1;									
;;;705    										break;
;;;706    										
;;;707    									case V15_TRIM:	//0x5
;;;708    	  										ResCode=NO_ERR;
;;;709    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;710    											PCRChip_Command_Send[0]=PCR_Regs.V20_V15Trim=V15_PACK(u8temp,PCR_Regs.V20_V15Trim);
;;;711    											Send_Command(REG_WRITE, V15_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);
;;;712    											TxBuffer[0]= V15_TRIM;
;;;713    											TransLen=1;	
;;;714    										break;
;;;715    	
;;;716    									case IPIX_TRIM: //0x6
;;;717    	  										ResCode=NO_ERR;
;;;718    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;719    											PCRChip_Command_Send[0]=PCR_Regs.Ipix_V24Trim=IPIX_PACK(u8temp,PCR_Regs.Ipix_V24Trim);
;;;720    											Send_Command(REG_WRITE, IPIX_TRIM_ADDR, 1, &PCRChip_Command_Send[0]);
;;;721    											TxBuffer[0]= IPIX_TRIM;
;;;722    											TransLen=1;									
;;;723    											break;
;;;724    	
;;;725    									case SWITCH_BIT:	//0x7
;;;726    	  										ResCode=NO_ERR;
;;;727    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;728    											PCRChip_Command_Send[0]=PCR_Regs.SW_TxCtrl=SW_PACK(u8temp,PCR_Regs.SW_TxCtrl);
;;;729    											Send_Command(REG_WRITE, SWITCH_ADDR, 1, &PCRChip_Command_Send[0]);
;;;730    											TxBuffer[0]= SWITCH_BIT;
;;;731    											TransLen=1;											
;;;732    										break;
;;;733    	
;;;734    									case TX_PATTERN:	//0x8
;;;735    	  										ResCode=NO_ERR;
;;;736    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;737    											PCRChip_Command_Send[0]=PCR_Regs.SW_TxCtrl=TX_PACK(u8temp,PCR_Regs.SW_TxCtrl);
;;;738    											Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[0]);
;;;739    											TxBuffer[0]= TX_PATTERN;
;;;740    											TransLen=1;
;;;741    										break;
;;;742    	
;;;743    									case AMUX_CONTROL:	//0x9
;;;744    	  										ResCode=NO_ERR;
;;;745    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;746    											PCRChip_Command_Send[0]=PCR_Regs.TsTADC_AmuxCtrl=AMUX_PACK(u8temp,PCR_Regs.TsTADC_AmuxCtrl);
;;;747    											Send_Command(REG_WRITE, AMUX_CONTROL_ADDR, 1, &PCRChip_Command_Send[0]);
;;;748    											TxBuffer[0]= AMUX_CONTROL;
;;;749    											TransLen=1;
;;;750    										break;
;;;751    	
;;;752    
;;;753    									case TEST_ADC:		//0xA
;;;754    											#if !defined(BETA_VER)
;;;755    	  										ResCode=NO_ERR;
;;;756    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;757    											PCR_Regs.TsTADC_AmuxCtrl=TSTADC_PACK(u8temp,PCR_Regs.TsTADC_AmuxCtrl);
;;;758    											TransLen=0;
;;;759    											#else
;;;760    	  										ResCode=ERR_CMD;   /*LPG: no test adc in beta version, return error// *txc/
;;;761    											TxBuffer[0]= TEST_ADC;
;;;762    											TransLen=1;
;;;763    											#endif
;;;764    										break;
;;;765    	
;;;766    									case SPI_PULSE:		//0x10
;;;767    	  										ResCode=NO_ERR;
;;;768    											PCR_Regs.SpiInsertion=Comand_Buf[TYP_BYTE_NUM+1];
;;;769    											TxBuffer[0]= SPI_PULSE;
;;;770    											TransLen=1;
;;;771    										break;
;;;772    	
;;;773    									case INTE_TIME:		//0x20
;;;774    	      									ResCode=NO_ERR;
;;;775    											u16temp=0;
;;;776    											u16temp = Comand_Buf[TYP_BYTE_NUM+2];
;;;777    											u16temp= ((u16temp <<8) |Comand_Buf[TYP_BYTE_NUM+1]);  // LSB byte before MSB
;;;778    									//		if(u16temp!=0)
;;;779    											//PCR_Regs.InteCount=	(u16temp*1000)/(u16)TIME_US_PER_CNT -1; /txc*calculate the count for timer*txc/
;;;780    									//		  PCR_Regs.InteTime= u16temp;
;;;781    											//u16temp=(u16temp * 1000);  /*LPG: cvert to us*txc/
;;;782    											//if(u16temp>PCR_Regs.InteTime)
;;;783    											//	PCR_Regs.InteDelayCount=(u16temp-PCR_Regs.InteTime)/TIME_US_PER_CNT;
;;;784    											//else if(u16temp<PCR_Regs.InteTime)
;;;785    											//		PCR_Regs.InteDelayCount=(PCR_Regs.InteTime-u16temp)/TIME_US_PER_CNT;
;;;786    											//PCR_Regs.InteTime=u16temp;
;;;787    											//.InteCount=u16temp/TIME_US_PER_CNT;
;;;788    
;;;789    											UnionTemp.tempd.byte0= Comand_Buf[TYP_BYTE_NUM+1];
;;;790    											UnionTemp.tempd.byte1= Comand_Buf[TYP_BYTE_NUM+2];
;;;791    											UnionTemp.tempd.byte2= Comand_Buf[TYP_BYTE_NUM+3];
;;;792    											UnionTemp.tempd.byte3= Comand_Buf[TYP_BYTE_NUM+4];
;;;793    											if(UnionTemp.float_num!=0)
;;;794    												PCR_Regs.InteTime=UnionTemp.float_num;
;;;795    											else
;;;796    												ResCode=BAD_DATA;	
;;;797    
;;;798    											TxBuffer[0]= INTE_TIME;
;;;799    											TransLen=1;
;;;800    										break;
;;;801    	
;;;802    									case PCR_RESET:	  // 0xF
;;;803    										  	ResCode=NO_ERR;
;;;804    										    PCR_RESET_PROCESS;
;;;805    											
;;;806    											Trim_Reset();
;;;807    											TxBuffer[0]= PCR_RESET;
;;;808    											TransLen=1;
;;;809    
;;;810    										break;
;;;811    
;;;812    									case OSC_CONTROL:   // 0xE
;;;813    											ResCode=NO_ERR;
;;;814    											u8temp=Comand_Buf[TYP_BYTE_NUM+1];
;;;815    											u8temp &= 0x3;
;;;816    											OSC_mode= u8temp;
;;;817    											if(u8temp==1)	 // ON
;;;818    											{
;;;819    												OSC_Ctrl=OSC_ON;
;;;820    												OSC_Status=1;
;;;821    											}
;;;822    											else if (u8temp==0)	// Off
;;;823    													 
;;;824    												{
;;;825    													//if(OSC_Busy != 1)	 // customer insure not to disable OSC during ADC
;;;826    													OSC_Ctrl=OSC_OFF;
;;;827    													OSC_Status=0;
;;;828    												}
;;;829    												else // 0x2: auto
;;;830    													 // 0x3: invalid mode, force to auto				  
;;;831    													OSC_mode=0x1; 	
;;;832    											TxBuffer[0]= OSC_CONTROL;
;;;833    											TransLen=1;
;;;834    										break;
;;;835    		    			//txc
;;;836    									*/        
;;;837    
;;;838    									case LED_PRO_TIME:
;;;839    	      									ResCode=NO_ERR;
000672  2000              MOVS     r0,#0
000674  9008              STR      r0,[sp,#0x20]
;;;840    											u16temp=0;
000676  4681              MOV      r9,r0
;;;841    											u16temp = Comand_Buf[TYP_BYTE_NUM+2];
000678  4893              LDR      r0,|L1.2248|
00067a  f8909005          LDRB     r9,[r0,#5]  ; Comand_Buf
;;;842    											u16temp= ((u16temp <<8) |Comand_Buf[TYP_BYTE_NUM+1]);  // LSB byte before MSB
00067e  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000680  ea402909          ORR      r9,r0,r9,LSL #8
;;;843    											
;;;844     											UnionTemp.tempd.byte0= Comand_Buf[TYP_BYTE_NUM+1];
000684  4890              LDR      r0,|L1.2248|
000686  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000688  4990              LDR      r1,|L1.2252|
00068a  7008              STRB     r0,[r1,#0]
;;;845    											UnionTemp.tempd.byte1= Comand_Buf[TYP_BYTE_NUM+2];
00068c  488e              LDR      r0,|L1.2248|
00068e  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000690  7048              STRB     r0,[r1,#1]
;;;846    											UnionTemp.tempd.byte2= Comand_Buf[TYP_BYTE_NUM+3];
000692  488d              LDR      r0,|L1.2248|
000694  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000696  7088              STRB     r0,[r1,#2]
;;;847    											UnionTemp.tempd.byte3= Comand_Buf[TYP_BYTE_NUM+4];
000698  488b              LDR      r0,|L1.2248|
00069a  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
00069c  70c8              STRB     r0,[r1,#3]
;;;848    
;;;849    											if((UnionTemp.float_num>0)&&(UnionTemp.float_num<2000))
00069e  6808              LDR      r0,[r1,#0]  ; UnionTemp
0006a0  2100              MOVS     r1,#0
0006a2  f7fffffe          BL       __aeabi_cfrcmple
0006a6  d20d              BCS      |L1.1732|
0006a8  4988              LDR      r1,|L1.2252|
0006aa  6808              LDR      r0,[r1,#0]  ; UnionTemp
0006ac  4988              LDR      r1,|L1.2256|
0006ae  f7fffffe          BL       __aeabi_cfcmple
0006b2  d207              BCS      |L1.1732|
;;;850    												SetTm_LED_Delay=UnionTemp.float_num;
0006b4  4985              LDR      r1,|L1.2252|
0006b6  6808              LDR      r0,[r1,#0]  ; UnionTemp
0006b8  f7fffffe          BL       __aeabi_f2uiz
0006bc  4985              LDR      r1,|L1.2260|
0006be  8008              STRH     r0,[r1,#0]
0006c0  e002              B        |L1.1736|
                  |L1.1730|
0006c2  e3fd              B        |L1.3776|
                  |L1.1732|
;;;851    											else
;;;852    												ResCode=OUT_RANGE;
0006c4  2007              MOVS     r0,#7
0006c6  9008              STR      r0,[sp,#0x20]
                  |L1.1736|
;;;853    
;;;854    											TxBuffer[0]= LED_PRO_TIME;
0006c8  2021              MOVS     r0,#0x21
0006ca  4977              LDR      r1,|L1.2216|
0006cc  7008              STRB     r0,[r1,#0]
;;;855    											TransLen=1;
0006ce  2001              MOVS     r0,#1
0006d0  9007              STR      r0,[sp,#0x1c]
;;;856    										break;
0006d2  e04b              B        |L1.1900|
                  |L1.1748|
;;;857    
;;;858    
;;;859     									case LED_HOLD_TIME:
;;;860    	      									ResCode=NO_ERR;
0006d4  2000              MOVS     r0,#0
0006d6  9008              STR      r0,[sp,#0x20]
;;;861    											u16temp=0;
0006d8  4681              MOV      r9,r0
;;;862    											u16temp = Comand_Buf[TYP_BYTE_NUM+2];
0006da  487b              LDR      r0,|L1.2248|
0006dc  f8909005          LDRB     r9,[r0,#5]  ; Comand_Buf
;;;863    											u16temp= ((u16temp <<8) |Comand_Buf[TYP_BYTE_NUM+1]);  // LSB byte before MSB
0006e0  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
0006e2  ea402909          ORR      r9,r0,r9,LSL #8
;;;864    										
;;;865     											UnionTemp.tempd.byte0= Comand_Buf[TYP_BYTE_NUM+1];
0006e6  4878              LDR      r0,|L1.2248|
0006e8  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
0006ea  4978              LDR      r1,|L1.2252|
0006ec  7008              STRB     r0,[r1,#0]
;;;866    											UnionTemp.tempd.byte1= Comand_Buf[TYP_BYTE_NUM+2];
0006ee  4876              LDR      r0,|L1.2248|
0006f0  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
0006f2  7048              STRB     r0,[r1,#1]
;;;867    											UnionTemp.tempd.byte2= Comand_Buf[TYP_BYTE_NUM+3];
0006f4  4874              LDR      r0,|L1.2248|
0006f6  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
0006f8  7088              STRB     r0,[r1,#2]
;;;868    											UnionTemp.tempd.byte3= Comand_Buf[TYP_BYTE_NUM+4];
0006fa  4873              LDR      r0,|L1.2248|
0006fc  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
0006fe  70c8              STRB     r0,[r1,#3]
;;;869    
;;;870    											if((UnionTemp.float_num>0)&&(UnionTemp.float_num<2000))
000700  6808              LDR      r0,[r1,#0]  ; UnionTemp
000702  2100              MOVS     r1,#0
000704  f7fffffe          BL       __aeabi_cfrcmple
000708  d212              BCS      |L1.1840|
00070a  4970              LDR      r1,|L1.2252|
00070c  6808              LDR      r0,[r1,#0]  ; UnionTemp
00070e  4970              LDR      r1,|L1.2256|
000710  f7fffffe          BL       __aeabi_cfcmple
000714  d20c              BCS      |L1.1840|
;;;871    												HoldTm_LED_Delay=UnionTemp.float_num;
000716  496d              LDR      r1,|L1.2252|
000718  6808              LDR      r0,[r1,#0]  ; UnionTemp
00071a  f7fffffe          BL       __aeabi_f2uiz
00071e  496e              LDR      r1,|L1.2264|
000720  8008              STRH     r0,[r1,#0]
000722  e007              B        |L1.1844|
                  |L1.1828|
000724  e084              B        |L1.2096|
                  |L1.1830|
000726  e029              B        |L1.1916|
                  |L1.1832|
000728  e3f0              B        |L1.3852|
                  |L1.1834|
00072a  e1b7              B        |L1.2716|
                  |L1.1836|
00072c  e304              B        |L1.3384|
                  |L1.1838|
00072e  e3cb              B        |L1.3784|
                  |L1.1840|
;;;872    											else
;;;873    												ResCode=OUT_RANGE;
000730  2007              MOVS     r0,#7
000732  9008              STR      r0,[sp,#0x20]
                  |L1.1844|
;;;874    
;;;875    											TxBuffer[0]= LED_HOLD_TIME;
000734  2022              MOVS     r0,#0x22
000736  495c              LDR      r1,|L1.2216|
000738  7008              STRB     r0,[r1,#0]
;;;876    											TransLen=1;
00073a  2001              MOVS     r0,#1
00073c  9007              STR      r0,[sp,#0x1c]
;;;877    
;;;878    										break;
00073e  e015              B        |L1.1900|
                  |L1.1856|
;;;879    
;;;880    									 case LED_SWITCH:
;;;881    											ResCode=NO_ERR;
000740  2000              MOVS     r0,#0
000742  9008              STR      r0,[sp,#0x20]
;;;882    											TransLen=0;
000744  9007              STR      r0,[sp,#0x1c]
;;;883    									 		u8temp3=Comand_Buf[TYP_BYTE_NUM+1];
000746  4860              LDR      r0,|L1.2248|
000748  f8908004          LDRB     r8,[r0,#4]  ; Comand_Buf
;;;884    									     	LED_CTRL=led_mode=(u8temp3 & 0x1);
00074c  f0080001          AND      r0,r8,#1
000750  4962              LDR      r1,|L1.2268|
000752  7008              STRB     r0,[r1,#0]
000754  4962              LDR      r1,|L1.2272|
000756  6008              STR      r0,[r1,#0]
;;;885    
;;;886    										break;									 	
000758  e008              B        |L1.1900|
00075a  e7ff              B        |L1.1884|
                  |L1.1884|
;;;887    
;;;888    									default:  			// invalid type 
;;;889    										ResCode=ERR_TYP;
00075c  2005              MOVS     r0,#5
00075e  9008              STR      r0,[sp,#0x20]
;;;890    											TxBuffer[0]= LED_HOLD_TIME;
000760  2022              MOVS     r0,#0x22
000762  4951              LDR      r1,|L1.2216|
000764  7008              STRB     r0,[r1,#0]
;;;891    											TransLen=1;
000766  2001              MOVS     r0,#1
000768  9007              STR      r0,[sp,#0x1c]
;;;892    										break;
00076a  bf00              NOP      
                  |L1.1900|
00076c  bf00              NOP                            ;856
                  |L1.1902|
;;;893    								 }
;;;894    							 }
;;;895    							 USBRes(ResCode, CMD_SET, TxBuffer, TransLen);
00076e  4a4e              LDR      r2,|L1.2216|
000770  2101              MOVS     r1,#1
000772  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000776  f7fffffe          BL       USBRes
;;;896    						break;
00077a  e767              B        |L1.1612|
                  |L1.1916|
;;;897    
;;;898    
;;;899    					case CMD_READ:	
;;;900    							if(Comand_Buf[LEN_BYTE_NUM]<MIN_PACKET_LENGTH)
00077c  4852              LDR      r0,|L1.2248|
00077e  7880              LDRB     r0,[r0,#2]  ; Comand_Buf
000780  2801              CMP      r0,#1
000782  da07              BGE      |L1.1940|
;;;901    							 {
;;;902    							 	ResCode=ERR_LENGTH;
000784  2001              MOVS     r0,#1
000786  9008              STR      r0,[sp,#0x20]
;;;903    											TxBuffer[0]= CMD_READ;
000788  2004              MOVS     r0,#4
00078a  4947              LDR      r1,|L1.2216|
00078c  7008              STRB     r0,[r1,#0]
;;;904    											TransLen=1;
00078e  2001              MOVS     r0,#1
000790  9007              STR      r0,[sp,#0x1c]
000792  e045              B        |L1.2080|
                  |L1.1940|
;;;905    							 }
;;;906    							 else
;;;907    							 {
;;;908    								 switch (Comand_Buf[TYP_BYTE_NUM])
000794  484c              LDR      r0,|L1.2248|
000796  78c0              LDRB     r0,[r0,#3]  ; Comand_Buf
000798  2821              CMP      r0,#0x21
00079a  d002              BEQ      |L1.1954|
00079c  2822              CMP      r0,#0x22
00079e  d136              BNE      |L1.2062|
0007a0  e01a              B        |L1.2008|
                  |L1.1954|
;;;909    								 {
;;;910    								  	/*
;;;911    									 txc
;;;912    									 case RAMP_TRIM:	// 0x1
;;;913    	
;;;914    	  										ResCode=NO_ERR;
;;;915    										    TxBuffer[0]=RAMP_TRIM;
;;;916    											TxBuffer[1]=RAMP_ALGN(PCR_Regs.RampTrim);
;;;917    											TransLen=2;
;;;918    										break;
;;;919    	
;;;920    	
;;;921    									case RANG_TRIM: // 0x2
;;;922    	  										ResCode=NO_ERR;
;;;923    										    TxBuffer[0]=RANG_TRIM;
;;;924    											TxBuffer[1]=RANG_ALGN(PCR_Regs.RangTrim);
;;;925    											TransLen=2;
;;;926    										break;
;;;927    	
;;;928    									case V24_TRIM:	//0x3
;;;929    	  										ResCode=NO_ERR;
;;;930    										    TxBuffer[0]=V24_TRIM;
;;;931    											TxBuffer[1]=V24_ALGN(PCR_Regs.Ipix_V24Trim);
;;;932    											TransLen=2;								
;;;933    										break;
;;;934    										
;;;935    									case V20_TRIM:	//0x4
;;;936    	  										ResCode=NO_ERR;
;;;937    										    TxBuffer[0]=V20_TRIM;
;;;938    											TxBuffer[1]=V20_ALGN(PCR_Regs.V20_V15Trim);
;;;939    											TransLen=2;								
;;;940    										break;
;;;941    										
;;;942    									case V15_TRIM:	//0x5
;;;943    	  										ResCode=NO_ERR;
;;;944    										    TxBuffer[0]=V15_TRIM;
;;;945    											TxBuffer[1]=V15_ALGN(PCR_Regs.V20_V15Trim);
;;;946    											TransLen=2;	
;;;947    										break;
;;;948    	
;;;949    									case IPIX_TRIM: //0x6
;;;950    	  										ResCode=NO_ERR;
;;;951    										    TxBuffer[0]=IPIX_TRIM;
;;;952    											TxBuffer[1]=IPIX_ALGN(PCR_Regs.Ipix_V24Trim);
;;;953    											TransLen=2;									break;
;;;954    	
;;;955    									case SWITCH_BIT:	//0x7
;;;956    	   										ResCode=NO_ERR;
;;;957    										    TxBuffer[0]=SWITCH_BIT;
;;;958    											TxBuffer[1]=SW_ALGN(PCR_Regs.SW_TxCtrl);
;;;959    											TransLen=2;	
;;;960    										break;
;;;961    	
;;;962    									case TX_PATTERN:	//0x8
;;;963    	    									ResCode=NO_ERR;
;;;964    										    TxBuffer[0]=TX_PATTERN;
;;;965    											TxBuffer[1]=TX_ALGN(PCR_Regs.SW_TxCtrl);
;;;966    											TransLen=2;
;;;967    										break;
;;;968    	
;;;969    									case AMUX_CONTROL:	//0x9
;;;970    	    									ResCode=NO_ERR;
;;;971    										    TxBuffer[0]=AMUX_CONTROL;
;;;972    											TxBuffer[1]=AMUX_ALGN(PCR_Regs.TsTADC_AmuxCtrl);
;;;973    											TransLen=2;
;;;974    										break;
;;;975    	
;;;976    									case TEST_ADC:		//0xA
;;;977    											#if !defined(BETA_VER) 
;;;978    	    									ResCode=NO_ERR;
;;;979    										    TxBuffer[0]=TEST_ADC;
;;;980    											TxBuffer[1]=TSTADC_ALGN(PCR_Regs.TsTADC_AmuxCtrl);
;;;981    											TransLen=2;
;;;982    											#else
;;;983    	  										ResCode=ERR_CMD;   /*LPG: no test adc in beta version, return error txc*txc/
;;;984    											TransLen=0;
;;;985    											#endif
;;;986    										break;
;;;987    	
;;;988    
;;;989    									case OSC_CONTROL:
;;;990    	    									ResCode=NO_ERR;
;;;991    										    TxBuffer[0]=OSC_CONTROL;
;;;992    											TxBuffer[1]=OSC_Status;
;;;993    											TransLen=2;										
;;;994    											break;
;;;995    
;;;996    									case SPI_PULSE:		//0x10
;;;997    	     									ResCode=NO_ERR;
;;;998    										    TxBuffer[0]=SPI_PULSE;
;;;999    											TxBuffer[1]=PCR_Regs.SpiInsertion;
;;;1000   											TransLen=2;
;;;1001   										break;
;;;1002   	
;;;1003   									case INTE_TIME:		//0x20
;;;1004   	      									ResCode=NO_ERR;
;;;1005   										    TxBuffer[0]=INTE_TIME;
;;;1006   
;;;1007   											UnionTemp.float_num= PCR_Regs.InteTime;
;;;1008   											TxBuffer[1]= UnionTemp.tempd.byte0;
;;;1009   											TxBuffer[2]= UnionTemp.tempd.byte1;
;;;1010   											TxBuffer[3]= UnionTemp.tempd.byte2;
;;;1011   											TxBuffer[4]= UnionTemp.tempd.byte3;
;;;1012   											TransLen=5;
;;;1013   										break;
;;;1014   	
;;;1015   
;;;1016   									case  AMUX_OUT:
;;;1017   									   	adcx=Get_Adc_Average(ADC_CH1,10);
;;;1018   										//temp=(float)adcx*(3.3/4096);
;;;1019   										//adcx=temp;
;;;1020         									ResCode=NO_ERR;
;;;1021   									    TxBuffer[0]=AMUX_OUT;
;;;1022   										TxBuffer[1]= (u8)adcx;
;;;1023   										TxBuffer[2]= (u8)(adcx>>8);
;;;1024   										TransLen=3;										
;;;1025   										break;
;;;1026   
;;;1027   									case PCR_TEMP:  
;;;1028   
;;;1029   										if(Comand_Buf[TYP_BYTE_NUM+2]== CH_INDEX_0)
;;;1030   									   		adcx=Get_Adc(ADC_CH14);
;;;1031   										else if(Comand_Buf[TYP_BYTE_NUM+2]== CH_INDEX_1)
;;;1032   											adcx=Get_Adc(ADC_CH15);
;;;1033   									    	
;;;1034   										UnionTemp.float_num=(float)adcx*(3.3/4096);
;;;1035   										TxBuffer[0]= PCR_TEMP;
;;;1036   										TxBuffer[1]= UnionTemp.tempd.byte0;
;;;1037   										TxBuffer[2]= UnionTemp.tempd.byte1;
;;;1038   										TxBuffer[3]= UnionTemp.tempd.byte2;
;;;1039   										TxBuffer[4]= UnionTemp.tempd.byte3;
;;;1040   										TransLen=5;	
;;;1041   
;;;1042   										break;
;;;1043   txc
;;;1044   */
;;;1045    									case LED_PRO_TIME:
;;;1046   
;;;1047    	      									ResCode=NO_ERR;
0007a2  2000              MOVS     r0,#0
0007a4  9008              STR      r0,[sp,#0x20]
;;;1048   										    TxBuffer[0]=LED_PRO_TIME;
0007a6  2021              MOVS     r0,#0x21
0007a8  493f              LDR      r1,|L1.2216|
0007aa  7008              STRB     r0,[r1,#0]
;;;1049   										
;;;1050   											UnionTemp.float_num= SetTm_LED_Delay;
0007ac  4849              LDR      r0,|L1.2260|
0007ae  8800              LDRH     r0,[r0,#0]  ; SetTm_LED_Delay
0007b0  f7fffffe          BL       __aeabi_ui2f
0007b4  4945              LDR      r1,|L1.2252|
0007b6  6008              STR      r0,[r1,#0]  ; UnionTemp
;;;1051   											TxBuffer[1]= UnionTemp.tempd.byte0;
0007b8  4608              MOV      r0,r1
0007ba  7800              LDRB     r0,[r0,#0]  ; UnionTemp
0007bc  493a              LDR      r1,|L1.2216|
0007be  7048              STRB     r0,[r1,#1]
;;;1052   											TxBuffer[2]= UnionTemp.tempd.byte1;
0007c0  4842              LDR      r0,|L1.2252|
0007c2  7840              LDRB     r0,[r0,#1]  ; UnionTemp
0007c4  7088              STRB     r0,[r1,#2]
;;;1053   											TxBuffer[3]= UnionTemp.tempd.byte2;
0007c6  4841              LDR      r0,|L1.2252|
0007c8  7880              LDRB     r0,[r0,#2]  ; UnionTemp
0007ca  70c8              STRB     r0,[r1,#3]
;;;1054   											TxBuffer[4]= UnionTemp.tempd.byte3;
0007cc  483f              LDR      r0,|L1.2252|
0007ce  78c0              LDRB     r0,[r0,#3]  ; UnionTemp
0007d0  7108              STRB     r0,[r1,#4]
;;;1055   											TransLen=5;
0007d2  2005              MOVS     r0,#5
0007d4  9007              STR      r0,[sp,#0x1c]
;;;1056   										break;
0007d6  e022              B        |L1.2078|
                  |L1.2008|
;;;1057   
;;;1058    									case LED_HOLD_TIME:
;;;1059   
;;;1060    	      									ResCode=NO_ERR;
0007d8  2000              MOVS     r0,#0
0007da  9008              STR      r0,[sp,#0x20]
;;;1061   										    TxBuffer[0]=LED_HOLD_TIME;
0007dc  2022              MOVS     r0,#0x22
0007de  4932              LDR      r1,|L1.2216|
0007e0  7008              STRB     r0,[r1,#0]
;;;1062   										
;;;1063   											UnionTemp.float_num= HoldTm_LED_Delay;
0007e2  483d              LDR      r0,|L1.2264|
0007e4  8800              LDRH     r0,[r0,#0]  ; HoldTm_LED_Delay
0007e6  f7fffffe          BL       __aeabi_ui2f
0007ea  4938              LDR      r1,|L1.2252|
0007ec  6008              STR      r0,[r1,#0]  ; UnionTemp
;;;1064   											TxBuffer[1]= UnionTemp.tempd.byte0;
0007ee  4608              MOV      r0,r1
0007f0  7800              LDRB     r0,[r0,#0]  ; UnionTemp
0007f2  492d              LDR      r1,|L1.2216|
0007f4  7048              STRB     r0,[r1,#1]
;;;1065   											TxBuffer[2]= UnionTemp.tempd.byte1;
0007f6  4835              LDR      r0,|L1.2252|
0007f8  7840              LDRB     r0,[r0,#1]  ; UnionTemp
0007fa  7088              STRB     r0,[r1,#2]
;;;1066   											TxBuffer[3]= UnionTemp.tempd.byte2;
0007fc  4833              LDR      r0,|L1.2252|
0007fe  7880              LDRB     r0,[r0,#2]  ; UnionTemp
000800  70c8              STRB     r0,[r1,#3]
;;;1067   											TxBuffer[4]= UnionTemp.tempd.byte3;
000802  4832              LDR      r0,|L1.2252|
000804  78c0              LDRB     r0,[r0,#3]  ; UnionTemp
000806  7108              STRB     r0,[r1,#4]
;;;1068   											TransLen=5;
000808  2005              MOVS     r0,#5
00080a  9007              STR      r0,[sp,#0x1c]
;;;1069   										break;
00080c  e007              B        |L1.2078|
                  |L1.2062|
;;;1070   
;;;1071   									default:  			// invalid type 
;;;1072   										ResCode=ERR_TYP;
00080e  2005              MOVS     r0,#5
000810  9008              STR      r0,[sp,#0x20]
;;;1073   											TxBuffer[0]= CMD_READ;
000812  2004              MOVS     r0,#4
000814  4924              LDR      r1,|L1.2216|
000816  7008              STRB     r0,[r1,#0]
;;;1074   											TransLen=1;
000818  2001              MOVS     r0,#1
00081a  9007              STR      r0,[sp,#0x1c]
;;;1075   										break;
00081c  bf00              NOP      
                  |L1.2078|
00081e  bf00              NOP                            ;1056
                  |L1.2080|
;;;1076   								 }
;;;1077   							 }
;;;1078   							 USBRes(ResCode, CMD_READ, TxBuffer, TransLen);
000820  4a21              LDR      r2,|L1.2216|
000822  2104              MOVS     r1,#4
000824  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000828  f7fffffe          BL       USBRes
;;;1079   
;;;1080   						break;
00082c  e70e              B        |L1.1612|
                  |L1.2094|
;;;1081   
;;;1082   					case CMD_MEASURE:
;;;1083   
;;;1084   						break;
00082e  e70d              B        |L1.1612|
                  |L1.2096|
;;;1085     					
;;;1086   					case CMD_TEMP_SET: // control temperature
;;;1087   							/*
;;;1088   							if(Comand_Buf[LEN_BYTE_NUM]<MIN_PACKET_LENGTH)
;;;1089   							 {
;;;1090   							 	ResCode=ERR_LENGTH;
;;;1091   								TransLen=0;
;;;1092   							 }
;;;1093   							 else
;;;1094   							 */
;;;1095   							 {
;;;1096   								 switch (Comand_Buf[TYP_BYTE_NUM])  // modify @ 140326, add sensor number at byte 1
000830  4825              LDR      r0,|L1.2248|
000832  78c0              LDRB     r0,[r0,#3]  ; Comand_Buf
000834  2802              CMP      r0,#2
000836  d07e              BEQ      |L1.2358|
000838  dc04              BGT      |L1.2116|
00083a  2800              CMP      r0,#0
00083c  d07c              BEQ      |L1.2360|
00083e  2801              CMP      r0,#1
                  |L1.2112|
000840  d17b              BNE      |L1.2362|
000842  e004              B        |L1.2126|
                  |L1.2116|
000844  2803              CMP      r0,#3
000846  d079              BEQ      |L1.2364|
000848  280a              CMP      r0,#0xa
00084a  d1f9              BNE      |L1.2112|
00084c  e10c              B        |L1.2664|
                  |L1.2126|
;;;1097   								 {
;;;1098   								  	case TEMP_SET_ON:	// float	
;;;1099   	      									ResCode=NO_ERR;
00084e  2000              MOVS     r0,#0
000850  9008              STR      r0,[sp,#0x20]
;;;1100   											u8temp3=Comand_Buf[TYP_BYTE_NUM+1];	 // #sensor 
000852  481d              LDR      r0,|L1.2248|
000854  f8908004          LDRB     r8,[r0,#4]  ; Comand_Buf
;;;1101   											UnionTemp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1+1];
000858  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
00085a  491c              LDR      r1,|L1.2252|
00085c  7008              STRB     r0,[r1,#0]
;;;1102   											UnionTemp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2+1];
00085e  481a              LDR      r0,|L1.2248|
000860  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000862  7048              STRB     r0,[r1,#1]
;;;1103   											UnionTemp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3+1];
000864  4818              LDR      r0,|L1.2248|
000866  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000868  7088              STRB     r0,[r1,#2]
;;;1104   											UnionTemp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4+1];
00086a  4817              LDR      r0,|L1.2248|
00086c  7a00              LDRB     r0,[r0,#8]  ; Comand_Buf
00086e  70c8              STRB     r0,[r1,#3]
;;;1105   
;;;1106   											f32temp1=UnionTemp.float_num;
000870  4608              MOV      r0,r1
000872  6800              LDR      r0,[r0,#0]  ; UnionTemp
000874  9009              STR      r0,[sp,#0x24]
;;;1107   											if((f32temp1>0)&& (f32temp1<150))
000876  e035              B        |L1.2276|
                  |L1.2168|
                          DCD      TempCtrl_Active
                  |L1.2172|
                          DCD      TempSet
                  |L1.2176|
                          DCD      TempCurrent
                  |L1.2180|
000884  00000000
000888  3fe00000          DCFD     0x3fe0000000000000 ; 0.5
                  |L1.2188|
                          DCD      TempValid
                  |L1.2192|
                          DCD      Peltier_Swap_Msg
                  |L1.2196|
                          DCD      TempCtrl_Active_2
                  |L1.2200|
                          DCD      CycleSTS
                  |L1.2204|
                          DCD      TempSet_2
                  |L1.2208|
                          DCD      TempCurrent_2
                  |L1.2212|
                          DCD      PixReadmMode
                  |L1.2216|
                          DCD      TxBuffer
                  |L1.2220|
                          DCD      SPI_2_RcvBuf
                  |L1.2224|
                          DCD      USB_ReceiveFlg
                  |L1.2228|
                          DCD      RxStage
                  |L1.2232|
                          DCD      USB_RxIdx
                  |L1.2236|
                          DCD      RxIdx
                  |L1.2240|
                          DCD      Command_Len
                  |L1.2244|
                          DCD      RxBuffer
                  |L1.2248|
                          DCD      Comand_Buf
                  |L1.2252|
                          DCD      UnionTemp
                  |L1.2256|
                          DCD      0x44fa0000
                  |L1.2260|
                          DCD      SetTm_LED_Delay
                  |L1.2264|
                          DCD      HoldTm_LED_Delay
                  |L1.2268|
                          DCD      led_mode
                  |L1.2272|
                          DCD      0x42238194
                  |L1.2276|
0008e4  2100              MOVS     r1,#0
0008e6  9809              LDR      r0,[sp,#0x24]
0008e8  f7fffffe          BL       __aeabi_cfrcmple
0008ec  d243              BCS      |L1.2422|
0008ee  49fd              LDR      r1,|L1.3300|
0008f0  9809              LDR      r0,[sp,#0x24]
0008f2  f7fffffe          BL       __aeabi_cfcmple
0008f6  d23e              BCS      |L1.2422|
;;;1108   											{
;;;1109   	
;;;1110   												u8temp1 = Comand_Buf[TYP_BYTE_NUM+5+1];
0008f8  48fb              LDR      r0,|L1.3304|
0008fa  7a46              LDRB     r6,[r0,#9]  ; Comand_Buf
;;;1111   											    u8temp2 = Comand_Buf[TYP_BYTE_NUM+6+1];
0008fc  7a87              LDRB     r7,[r0,#0xa]  ; Comand_Buf
;;;1112   												switch (u8temp3)
0008fe  f1b80f01          CMP      r8,#1
000902  d02a              BEQ      |L1.2394|
000904  f1b80f02          CMP      r8,#2
000908  d12e              BNE      |L1.2408|
;;;1113   												{
;;;1114   												/*
;;;1115   												 	case SENSOR_1:
;;;1116   														   TempCtrlTime_Sec= u8temp1;  // xxxx second @ 4,5 byte
;;;1117   															TempCtrlTime_Sec<<=8;
;;;1118   															TempCtrlTime_Sec|=u8temp2;
;;;1119   															TempTickLength=  TempCtrlTime_Sec * TICK_PER_SEC;
;;;1120   															TempSet= f32temp1;
;;;1121   															TempCtrl_Active=1;
;;;1122   															TempValid |= 1;
;;;1123   											       TxBuffer[0]= TEMP_SET_ON;//txc
;;;1124   									   			 */
;;;1125   														break;
;;;1126   													case SENSOR_2:
;;;1127   														  TempCtrlTime_Sec_2= u8temp1;  // xxxx second @ 4,5 byte
00090a  48f8              LDR      r0,|L1.3308|
00090c  8006              STRH     r6,[r0,#0]
;;;1128   															TempCtrlTime_Sec_2<<=8;
00090e  8800              LDRH     r0,[r0,#0]  ; TempCtrlTime_Sec_2
000910  0600              LSLS     r0,r0,#24
000912  0c00              LSRS     r0,r0,#16
000914  49f5              LDR      r1,|L1.3308|
000916  8008              STRH     r0,[r1,#0]
;;;1129   															TempCtrlTime_Sec_2|=u8temp2;
000918  4608              MOV      r0,r1
00091a  8800              LDRH     r0,[r0,#0]  ; TempCtrlTime_Sec_2
00091c  4338              ORRS     r0,r0,r7
00091e  8008              STRH     r0,[r1,#0]
;;;1130   															TempTickLength_2=  TempCtrlTime_Sec_2 * TICK_PER_SEC;
000920  4608              MOV      r0,r1
000922  8800              LDRH     r0,[r0,#0]  ; TempCtrlTime_Sec_2
000924  eb000040          ADD      r0,r0,r0,LSL #1
000928  0440              LSLS     r0,r0,#17
00092a  0c00              LSRS     r0,r0,#16
00092c  49f0              LDR      r1,|L1.3312|
00092e  8008              STRH     r0,[r1,#0]
;;;1131   															TempSet_2= f32temp1;
000930  49f0              LDR      r1,|L1.3316|
000932  9809              LDR      r0,[sp,#0x24]
000934  e003              B        |L1.2366|
                  |L1.2358|
000936  e054              B        |L1.2530|
                  |L1.2360|
000938  e025              B        |L1.2438|
                  |L1.2362|
00093a  e09f              B        |L1.2684|
                  |L1.2364|
00093c  e086              B        |L1.2636|
                  |L1.2366|
00093e  6008              STR      r0,[r1,#0]  ; TempSet_2
;;;1132   															TempCtrl_Active_2=1;
000940  2001              MOVS     r0,#1
000942  49ed              LDR      r1,|L1.3320|
000944  7008              STRB     r0,[r1,#0]
;;;1133   															TempValid |= 2;
000946  48ed              LDR      r0,|L1.3324|
000948  7800              LDRB     r0,[r0,#0]  ; TempValid
00094a  f0400002          ORR      r0,r0,#2
00094e  49eb              LDR      r1,|L1.3324|
000950  7008              STRB     r0,[r1,#0]
;;;1134   													    TxBuffer[0]= TEMP_SET_ON;//txc   
000952  2001              MOVS     r0,#1
000954  49ea              LDR      r1,|L1.3328|
000956  7008              STRB     r0,[r1,#0]
;;;1135   									      
;;;1136   														break;
000958  e00c              B        |L1.2420|
                  |L1.2394|
;;;1137   
;;;1138   													case SENSOR_1:        //SENSOR_PUMP:  // set the pump temperature for cycle control//txc
;;;1139   															TempPumpSet= f32temp1;	
00095a  49ea              LDR      r1,|L1.3332|
00095c  9809              LDR      r0,[sp,#0x24]
00095e  6008              STR      r0,[r1,#0]  ; TempPumpSet
;;;1140   													    TxBuffer[0]= TEMP_SET_ON;//txc
000960  2001              MOVS     r0,#1
000962  49e7              LDR      r1,|L1.3328|
000964  7008              STRB     r0,[r1,#0]
;;;1141   														break;
000966  e005              B        |L1.2420|
                  |L1.2408|
;;;1142   
;;;1143   													default:
;;;1144   															ResCode=BAD_DATA;
000968  2006              MOVS     r0,#6
00096a  9008              STR      r0,[sp,#0x20]
;;;1145                          		    TxBuffer[0]= TEMP_SET_ON;//txc
00096c  2001              MOVS     r0,#1
00096e  49e4              LDR      r1,|L1.3328|
000970  7008              STRB     r0,[r1,#0]
;;;1146   														break;
000972  bf00              NOP      
                  |L1.2420|
000974  e004              B        |L1.2432|
                  |L1.2422|
;;;1147   												}
;;;1148   
;;;1149   											}
;;;1150   											else
;;;1151   											{
;;;1152   												ResCode=BAD_DATA;
000976  2006              MOVS     r0,#6
000978  9008              STR      r0,[sp,#0x20]
;;;1153                   		    TxBuffer[0]= TEMP_SET_ON;//txc
00097a  2001              MOVS     r0,#1
00097c  49e0              LDR      r1,|L1.3328|
00097e  7008              STRB     r0,[r1,#0]
                  |L1.2432|
;;;1154   											}
;;;1155   											TransLen=1;
000980  2001              MOVS     r0,#1
000982  9007              STR      r0,[sp,#0x1c]
;;;1156   										break;
000984  e082              B        |L1.2700|
                  |L1.2438|
;;;1157   
;;;1158   									case TEMP_SET_OFF:	 		// modify @ 140326, add sensor number at byte 1
;;;1159   											u8temp3=Comand_Buf[TYP_BYTE_NUM+1];	 // #sensor 
000986  48d8              LDR      r0,|L1.3304|
000988  f8908004          LDRB     r8,[r0,#4]  ; Comand_Buf
;;;1160   											ResCode=NO_ERR;
00098c  2000              MOVS     r0,#0
00098e  9008              STR      r0,[sp,#0x20]
;;;1161    											switch (u8temp3)
000990  f1b80f01          CMP      r8,#1
000994  d003              BEQ      |L1.2462|
000996  f1b80f02          CMP      r8,#2
00099a  d118              BNE      |L1.2510|
00099c  e00b              B        |L1.2486|
                  |L1.2462|
;;;1162   											{
;;;1163   											 	case SENSOR_1:
;;;1164   														TempCtrl_Active=0;
00099e  2000              MOVS     r0,#0
0009a0  49d9              LDR      r1,|L1.3336|
0009a2  7008              STRB     r0,[r1,#0]
;;;1165   														TempValid &= ~0x1;
0009a4  48d5              LDR      r0,|L1.3324|
0009a6  7800              LDRB     r0,[r0,#0]  ; TempValid
0009a8  f0200001          BIC      r0,r0,#1
0009ac  49d3              LDR      r1,|L1.3324|
0009ae  7008              STRB     r0,[r1,#0]
;;;1166   														TempControl_stop();
0009b0  f7fffffe          BL       TempControl_stop
;;;1167   													break;
0009b4  e00e              B        |L1.2516|
                  |L1.2486|
;;;1168   												case SENSOR_2:
;;;1169   														TempCtrl_Active_2=0;
0009b6  2000              MOVS     r0,#0
0009b8  49cf              LDR      r1,|L1.3320|
0009ba  7008              STRB     r0,[r1,#0]
;;;1170   														TempValid &= ~0x2;
0009bc  48cf              LDR      r0,|L1.3324|
0009be  7800              LDRB     r0,[r0,#0]  ; TempValid
0009c0  f0200002          BIC      r0,r0,#2
0009c4  49cd              LDR      r1,|L1.3324|
0009c6  7008              STRB     r0,[r1,#0]
;;;1171   														TempControl_2_stop();
0009c8  f7fffffe          BL       TempControl_2_stop
;;;1172   													break;
0009cc  e002              B        |L1.2516|
                  |L1.2510|
;;;1173   												default:
;;;1174   														ResCode=BAD_DATA;
0009ce  2006              MOVS     r0,#6
0009d0  9008              STR      r0,[sp,#0x20]
;;;1175   													break;
0009d2  bf00              NOP      
                  |L1.2516|
0009d4  bf00              NOP                            ;1167
;;;1176   											}
;;;1177                  		    TxBuffer[0]= TEMP_SET_OFF;//txc
0009d6  2000              MOVS     r0,#0
0009d8  49c9              LDR      r1,|L1.3328|
0009da  7008              STRB     r0,[r1,#0]
;;;1178   											TransLen=1;
0009dc  2001              MOVS     r0,#1
0009de  9007              STR      r0,[sp,#0x1c]
;;;1179   										break;
0009e0  e054              B        |L1.2700|
                  |L1.2530|
;;;1180   
;;;1181   									case TEMP_READ_SENSOR:   // modify @ 140326, add sensor number at byte 1
;;;1182   											u8temp3=Comand_Buf[TYP_BYTE_NUM+1];	 // #sensor 
0009e2  48c1              LDR      r0,|L1.3304|
0009e4  f8908004          LDRB     r8,[r0,#4]  ; Comand_Buf
;;;1183    	  										ResCode=NO_ERR;
0009e8  2000              MOVS     r0,#0
0009ea  9008              STR      r0,[sp,#0x20]
;;;1184   											TransLen=5;
0009ec  2005              MOVS     r0,#5
0009ee  9007              STR      r0,[sp,#0x1c]
;;;1185    											switch (u8temp3)
0009f0  f1b80f01          CMP      r8,#1
0009f4  d003              BEQ      |L1.2558|
0009f6  f1b80f02          CMP      r8,#2
0009fa  d10c              BNE      |L1.2582|
0009fc  e005              B        |L1.2570|
                  |L1.2558|
;;;1186   											{
;;;1187   											 	case SENSOR_1:
;;;1188   														UnionTemp.float_num= TempSensorRead(STLM75_ADDR_WR);
0009fe  2090              MOVS     r0,#0x90
000a00  f7fffffe          BL       TempSensorRead
000a04  49c1              LDR      r1,|L1.3340|
000a06  6008              STR      r0,[r1,#0]  ; UnionTemp
;;;1189   													break;
000a08  e00d              B        |L1.2598|
                  |L1.2570|
;;;1190   												case SENSOR_2:
;;;1191   														UnionTemp.float_num= TempSensorRead(TEMP_SENSOR_2_ADDR_WR);
000a0a  2092              MOVS     r0,#0x92
000a0c  f7fffffe          BL       TempSensorRead
000a10  49be              LDR      r1,|L1.3340|
000a12  6008              STR      r0,[r1,#0]  ; UnionTemp
;;;1192   													break;
000a14  e007              B        |L1.2598|
                  |L1.2582|
;;;1193   												default:
;;;1194   														ResCode=BAD_DATA;
000a16  2006              MOVS     r0,#6
000a18  9008              STR      r0,[sp,#0x20]
;;;1195   												    TxBuffer[0]= TEMP_READ_SENSOR;
000a1a  2002              MOVS     r0,#2
000a1c  49b8              LDR      r1,|L1.3328|
000a1e  7008              STRB     r0,[r1,#0]
;;;1196   														TransLen=1;
000a20  2001              MOVS     r0,#1
000a22  9007              STR      r0,[sp,#0x1c]
;;;1197   													break;
000a24  bf00              NOP      
                  |L1.2598|
000a26  bf00              NOP                            ;1189
;;;1198   											}
;;;1199   											if(ResCode==NO_ERR)
000a28  9808              LDR      r0,[sp,#0x20]
000a2a  b970              CBNZ     r0,|L1.2634|
;;;1200   											{
;;;1201   							
;;;1202   												TxBuffer[0]= TEMP_READ_SENSOR;//txc//u8temp3;
000a2c  2002              MOVS     r0,#2
000a2e  49b4              LDR      r1,|L1.3328|
000a30  7008              STRB     r0,[r1,#0]
;;;1203   												TxBuffer[1]= UnionTemp.tempd.byte0;
000a32  48b6              LDR      r0,|L1.3340|
000a34  7800              LDRB     r0,[r0,#0]  ; UnionTemp
000a36  7048              STRB     r0,[r1,#1]
;;;1204   												TxBuffer[2]= UnionTemp.tempd.byte1;
000a38  48b4              LDR      r0,|L1.3340|
000a3a  7840              LDRB     r0,[r0,#1]  ; UnionTemp
000a3c  7088              STRB     r0,[r1,#2]
;;;1205   												TxBuffer[3]= UnionTemp.tempd.byte2;
000a3e  48b3              LDR      r0,|L1.3340|
000a40  7880              LDRB     r0,[r0,#2]  ; UnionTemp
000a42  70c8              STRB     r0,[r1,#3]
;;;1206   												TxBuffer[4]= UnionTemp.tempd.byte3;
000a44  48b1              LDR      r0,|L1.3340|
000a46  78c0              LDRB     r0,[r0,#3]  ; UnionTemp
000a48  7108              STRB     r0,[r1,#4]
                  |L1.2634|
;;;1207   		
;;;1208   											}											
;;;1209   										break;
000a4a  e01f              B        |L1.2700|
                  |L1.2636|
;;;1210   
;;;1211   									case TYP_FAN_CTRL:   // fan control, feature @0512, output on PC5
;;;1212   
;;;1213   											u8temp3=Comand_Buf[TYP_BYTE_NUM+1];
000a4c  48a6              LDR      r0,|L1.3304|
000a4e  f8908004          LDRB     r8,[r0,#4]  ; Comand_Buf
;;;1214   										    if(u8temp3 & FAN_MODE_MSK)
000a52  f0180f02          TST      r8,#2
000a56  d002              BEQ      |L1.2654|
;;;1215   												FanMode_Clear();
000a58  f7fffffe          BL       FanMode_Clear
000a5c  e003              B        |L1.2662|
                  |L1.2654|
;;;1216   											else
;;;1217   												FanCtrl_Force((u8temp3 & FAN_CTRL_MSK));
000a5e  f0080001          AND      r0,r8,#1
000a62  f7fffffe          BL       FanCtrl_Force
                  |L1.2662|
;;;1218   																								  
;;;1219   										break;
000a66  e011              B        |L1.2700|
                  |L1.2664|
;;;1220   
;;;1221   								   case TYP_FAN_READ:
;;;1222   										  TxBuffer[0]= TYP_FAN_READ;
000a68  200a              MOVS     r0,#0xa
000a6a  49a5              LDR      r1,|L1.3328|
000a6c  7008              STRB     r0,[r1,#0]
;;;1223   									    TxBuffer[1]= FanCSR_Read();
000a6e  f7fffffe          BL       FanCSR_Read
000a72  49a3              LDR      r1,|L1.3328|
000a74  7048              STRB     r0,[r1,#1]
;;;1224   											TransLen=2;
000a76  2002              MOVS     r0,#2
000a78  9007              STR      r0,[sp,#0x1c]
;;;1225   								   		break;
000a7a  e007              B        |L1.2700|
                  |L1.2684|
;;;1226   
;;;1227   									default:
;;;1228   											ResCode=ERR_TYP;
000a7c  2005              MOVS     r0,#5
000a7e  9008              STR      r0,[sp,#0x20]
;;;1229   								      TxBuffer[0]= TYP_FAN_CTRL;										 
000a80  2003              MOVS     r0,#3
000a82  499f              LDR      r1,|L1.3328|
000a84  7008              STRB     r0,[r1,#0]
;;;1230   											TransLen=1;
000a86  2001              MOVS     r0,#1
000a88  9007              STR      r0,[sp,#0x1c]
;;;1231   										break;
000a8a  bf00              NOP      
                  |L1.2700|
000a8c  bf00              NOP                            ;1156
;;;1232   								}
;;;1233   							}
;;;1234   							USBRes(ResCode, CMD_TEMP_SET, TxBuffer, TransLen);
000a8e  4a9c              LDR      r2,|L1.3328|
000a90  2110              MOVS     r1,#0x10
000a92  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000a96  f7fffffe          BL       USBRes
;;;1235   						break;					
000a9a  e39d              B        |L1.4568|
                  |L1.2716|
;;;1236   
;;;1237   					case  CMD_PID_CFG: // modify @2014-12-03
;;;1238   									   // Comand_Buf[TYP_BYTE_NUM]	will insert segment index at bit7..bit4
;;;1239   									   // bit3..bit0 still be type
;;;1240   						    ResCode=NO_ERR;
000a9c  2000              MOVS     r0,#0
000a9e  9008              STR      r0,[sp,#0x20]
;;;1241   							TransLen=0;
000aa0  9007              STR      r0,[sp,#0x1c]
;;;1242   
;;;1243   							u8temp3= (Comand_Buf[TYP_BYTE_NUM]>>4);
000aa2  4891              LDR      r0,|L1.3304|
000aa4  78c0              LDRB     r0,[r0,#3]  ; Comand_Buf
000aa6  ea4f1820          ASR      r8,r0,#4
;;;1244   							if (u8temp3>=PID_SLOP_SEG_MAX)
000aaa  f1b80f02          CMP      r8,#2
000aae  db02              BLT      |L1.2742|
;;;1245   								ResCode=OUT_RANGE;	
000ab0  2007              MOVS     r0,#7
000ab2  9008              STR      r0,[sp,#0x20]
000ab4  e0f7              B        |L1.3238|
                  |L1.2742|
;;;1246   							else
;;;1247   							{
;;;1248   								u8temp2=(Comand_Buf[TYP_BYTE_NUM] & 0xf);
000ab6  488c              LDR      r0,|L1.3304|
000ab8  78c0              LDRB     r0,[r0,#3]  ; Comand_Buf
000aba  f000070f          AND      r7,r0,#0xf
;;;1249   								u8temp1=Comand_Buf[LEN_BYTE_NUM];
000abe  488a              LDR      r0,|L1.3304|
000ac0  7886              LDRB     r6,[r0,#2]  ; Comand_Buf
;;;1250   								
;;;1251   								switch(u8temp2)
000ac2  2f0a              CMP      r7,#0xa
000ac4  d271              BCS      |L1.2986|
000ac6  e8dff007          TBB      [pc,r7]
000aca  ea23              DCB      0xea,0x23
000acc  3b6b53ea          DCB      0x3b,0x6b,0x53,0xea
000ad0  ea96d205          DCB      0xea,0x96,0xd2,0x05
;;;1252   								{
;;;1253   									case TYP_PID_KTM:
;;;1254   									        if(u8temp3 !=0)
000ad4  f1b80f00          CMP      r8,#0
000ad8  d002              BEQ      |L1.2784|
;;;1255   											{
;;;1256   											  ResCode=OUT_RANGE; // just only support one point now.
000ada  2007              MOVS     r0,#7
000adc  9008              STR      r0,[sp,#0x20]
000ade  e016              B        |L1.2830|
                  |L1.2784|
;;;1257   											}
;;;1258   											else
;;;1259   											{
;;;1260   	 											if(u8temp1 < 4)
000ae0  2e04              CMP      r6,#4
000ae2  da02              BGE      |L1.2794|
;;;1261   													ResCode=ERR_LENGTH;
000ae4  2001              MOVS     r0,#1
000ae6  9008              STR      r0,[sp,#0x20]
000ae8  e011              B        |L1.2830|
                  |L1.2794|
;;;1262   												else
;;;1263   												{
;;;1264   													KP_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000aea  487f              LDR      r0,|L1.3304|
000aec  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000aee  4988              LDR      r1,|L1.3344|
000af0  7008              STRB     r0,[r1,#0]
;;;1265   													KP_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000af2  487d              LDR      r0,|L1.3304|
000af4  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000af6  7048              STRB     r0,[r1,#1]
;;;1266   													KP_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000af8  487b              LDR      r0,|L1.3304|
000afa  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000afc  7088              STRB     r0,[r1,#2]
;;;1267   													KP_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000afe  487a              LDR      r0,|L1.3304|
000b00  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000b02  70c8              STRB     r0,[r1,#3]
;;;1268   													Ktm[u8temp3] = KP_temp.float_num;
000b04  4608              MOV      r0,r1
000b06  6800              LDR      r0,[r0,#0]  ; KP_temp
000b08  4982              LDR      r1,|L1.3348|
000b0a  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.2830|
;;;1269   												}
;;;1270   											}
;;;1271   										break;
000b0e  e0c9              B        |L1.3236|
;;;1272   
;;;1273   									case TYP_PID_KP:
;;;1274   											if(u8temp1 < 4)
000b10  2e04              CMP      r6,#4
000b12  da02              BGE      |L1.2842|
;;;1275   												ResCode=ERR_LENGTH;
000b14  2001              MOVS     r0,#1
000b16  9008              STR      r0,[sp,#0x20]
000b18  e011              B        |L1.2878|
                  |L1.2842|
;;;1276   											else
;;;1277   											{
;;;1278   												KP_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000b1a  4873              LDR      r0,|L1.3304|
000b1c  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000b1e  497c              LDR      r1,|L1.3344|
000b20  7008              STRB     r0,[r1,#0]
;;;1279   												KP_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000b22  4871              LDR      r0,|L1.3304|
000b24  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000b26  7048              STRB     r0,[r1,#1]
;;;1280   												KP_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000b28  486f              LDR      r0,|L1.3304|
000b2a  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000b2c  7088              STRB     r0,[r1,#2]
;;;1281   												KP_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000b2e  486e              LDR      r0,|L1.3304|
000b30  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000b32  70c8              STRB     r0,[r1,#3]
;;;1282   												Kp[u8temp3] = KP_temp.float_num;
000b34  4608              MOV      r0,r1
000b36  6800              LDR      r0,[r0,#0]  ; KP_temp
000b38  4977              LDR      r1,|L1.3352|
000b3a  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.2878|
;;;1283   											}
;;;1284   											break;
000b3e  e0b1              B        |L1.3236|
;;;1285   	
;;;1286   									case TYP_PID_KI:
;;;1287   											if(u8temp1 < 4)
000b40  2e04              CMP      r6,#4
000b42  da02              BGE      |L1.2890|
;;;1288   												ResCode=ERR_LENGTH;
000b44  2001              MOVS     r0,#1
000b46  9008              STR      r0,[sp,#0x20]
000b48  e011              B        |L1.2926|
                  |L1.2890|
;;;1289   											else
;;;1290   											{
;;;1291   												KI_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000b4a  4867              LDR      r0,|L1.3304|
000b4c  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000b4e  4973              LDR      r1,|L1.3356|
000b50  7008              STRB     r0,[r1,#0]
;;;1292   												KI_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000b52  4865              LDR      r0,|L1.3304|
000b54  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000b56  7048              STRB     r0,[r1,#1]
;;;1293   												KI_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000b58  4863              LDR      r0,|L1.3304|
000b5a  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000b5c  7088              STRB     r0,[r1,#2]
;;;1294   												KI_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000b5e  4862              LDR      r0,|L1.3304|
000b60  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000b62  70c8              STRB     r0,[r1,#3]
;;;1295   												Ki[u8temp3] = KI_temp.float_num;
000b64  4608              MOV      r0,r1
000b66  6800              LDR      r0,[r0,#0]  ; KI_temp
000b68  496d              LDR      r1,|L1.3360|
000b6a  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.2926|
;;;1296   											}
;;;1297   											break;
000b6e  e099              B        |L1.3236|
;;;1298   	
;;;1299   	
;;;1300   									case TYP_PID_KD:
;;;1301   											if(u8temp1 < 4)
000b70  2e04              CMP      r6,#4
000b72  da02              BGE      |L1.2938|
;;;1302   												ResCode=ERR_LENGTH;
000b74  2001              MOVS     r0,#1
000b76  9008              STR      r0,[sp,#0x20]
000b78  e011              B        |L1.2974|
                  |L1.2938|
;;;1303   											else
;;;1304   											{
;;;1305   												KD_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000b7a  485b              LDR      r0,|L1.3304|
000b7c  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000b7e  4969              LDR      r1,|L1.3364|
000b80  7008              STRB     r0,[r1,#0]
;;;1306   												KD_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000b82  4859              LDR      r0,|L1.3304|
000b84  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000b86  7048              STRB     r0,[r1,#1]
;;;1307   												KD_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000b88  4857              LDR      r0,|L1.3304|
000b8a  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000b8c  7088              STRB     r0,[r1,#2]
;;;1308   												KD_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000b8e  4856              LDR      r0,|L1.3304|
000b90  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000b92  70c8              STRB     r0,[r1,#3]
;;;1309   												Kd[u8temp3] = KD_temp.float_num;
000b94  4608              MOV      r0,r1
000b96  6800              LDR      r0,[r0,#0]  ; KD_temp
000b98  4963              LDR      r1,|L1.3368|
000b9a  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.2974|
;;;1310   											}
;;;1311   											break;
000b9e  e081              B        |L1.3236|
;;;1312   	
;;;1313   	
;;;1314   									case TYP_PID_KP_KI:
;;;1315   											if(u8temp1 < 8)
000ba0  2e08              CMP      r6,#8
000ba2  da03              BGE      |L1.2988|
;;;1316   												ResCode=ERR_LENGTH;
000ba4  2001              MOVS     r0,#1
000ba6  9008              STR      r0,[sp,#0x20]
000ba8  e024              B        |L1.3060|
                  |L1.2986|
000baa  e078              B        |L1.3230|
                  |L1.2988|
;;;1317   											else
;;;1318   											{
;;;1319   												KP_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000bac  484e              LDR      r0,|L1.3304|
000bae  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000bb0  4957              LDR      r1,|L1.3344|
000bb2  7008              STRB     r0,[r1,#0]
;;;1320   												KP_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000bb4  484c              LDR      r0,|L1.3304|
000bb6  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000bb8  7048              STRB     r0,[r1,#1]
;;;1321   												KP_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000bba  484b              LDR      r0,|L1.3304|
000bbc  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000bbe  7088              STRB     r0,[r1,#2]
;;;1322   												KP_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000bc0  4849              LDR      r0,|L1.3304|
000bc2  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000bc4  70c8              STRB     r0,[r1,#3]
;;;1323   												Kp[u8temp3] = KP_temp.float_num;
000bc6  4608              MOV      r0,r1
000bc8  6800              LDR      r0,[r0,#0]  ; KP_temp
000bca  4953              LDR      r1,|L1.3352|
000bcc  f8410028          STR      r0,[r1,r8,LSL #2]
;;;1324   	
;;;1325   	 											KI_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+5];
000bd0  4845              LDR      r0,|L1.3304|
000bd2  7a00              LDRB     r0,[r0,#8]  ; Comand_Buf
000bd4  4951              LDR      r1,|L1.3356|
000bd6  7008              STRB     r0,[r1,#0]
;;;1326   												KI_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+6];
000bd8  4843              LDR      r0,|L1.3304|
000bda  7a40              LDRB     r0,[r0,#9]  ; Comand_Buf
000bdc  7048              STRB     r0,[r1,#1]
;;;1327   												KI_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+7];
000bde  4842              LDR      r0,|L1.3304|
000be0  7a80              LDRB     r0,[r0,#0xa]  ; Comand_Buf
000be2  7088              STRB     r0,[r1,#2]
;;;1328   												KI_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+8];
000be4  4840              LDR      r0,|L1.3304|
000be6  7ac0              LDRB     r0,[r0,#0xb]  ; Comand_Buf
000be8  70c8              STRB     r0,[r1,#3]
;;;1329   												Ki[u8temp3] = KI_temp.float_num;
000bea  4608              MOV      r0,r1
000bec  6800              LDR      r0,[r0,#0]  ; KI_temp
000bee  494c              LDR      r1,|L1.3360|
000bf0  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.3060|
;;;1330   	
;;;1331   											}
;;;1332   											break;
000bf4  e056              B        |L1.3236|
;;;1333   	
;;;1334   	
;;;1335   									case TYP_PID_KP_KI_KD:
;;;1336   											if(u8temp1 < 12)
000bf6  2e0c              CMP      r6,#0xc
000bf8  da02              BGE      |L1.3072|
;;;1337   												ResCode=ERR_LENGTH;
000bfa  2001              MOVS     r0,#1
000bfc  9008              STR      r0,[sp,#0x20]
000bfe  e035              B        |L1.3180|
                  |L1.3072|
;;;1338   											else
;;;1339   											{
;;;1340   												KP_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000c00  4839              LDR      r0,|L1.3304|
000c02  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000c04  4942              LDR      r1,|L1.3344|
000c06  7008              STRB     r0,[r1,#0]
;;;1341   												KP_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000c08  4837              LDR      r0,|L1.3304|
000c0a  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000c0c  7048              STRB     r0,[r1,#1]
;;;1342   												KP_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000c0e  4836              LDR      r0,|L1.3304|
000c10  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000c12  7088              STRB     r0,[r1,#2]
;;;1343   												KP_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000c14  4834              LDR      r0,|L1.3304|
000c16  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000c18  70c8              STRB     r0,[r1,#3]
;;;1344   												Kp[u8temp3] = KP_temp.float_num;
000c1a  4608              MOV      r0,r1
000c1c  6800              LDR      r0,[r0,#0]  ; KP_temp
000c1e  493e              LDR      r1,|L1.3352|
000c20  f8410028          STR      r0,[r1,r8,LSL #2]
;;;1345   	
;;;1346   	 											KI_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+5];
000c24  4830              LDR      r0,|L1.3304|
000c26  7a00              LDRB     r0,[r0,#8]  ; Comand_Buf
000c28  493c              LDR      r1,|L1.3356|
000c2a  7008              STRB     r0,[r1,#0]
;;;1347   												KI_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+6];
000c2c  482e              LDR      r0,|L1.3304|
000c2e  7a40              LDRB     r0,[r0,#9]  ; Comand_Buf
000c30  7048              STRB     r0,[r1,#1]
;;;1348   												KI_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+7];
000c32  482d              LDR      r0,|L1.3304|
000c34  7a80              LDRB     r0,[r0,#0xa]  ; Comand_Buf
000c36  7088              STRB     r0,[r1,#2]
;;;1349   												KI_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+8];
000c38  482b              LDR      r0,|L1.3304|
000c3a  7ac0              LDRB     r0,[r0,#0xb]  ; Comand_Buf
000c3c  70c8              STRB     r0,[r1,#3]
;;;1350   												Ki[u8temp3] = KI_temp.float_num;
000c3e  4608              MOV      r0,r1
000c40  6800              LDR      r0,[r0,#0]  ; KI_temp
000c42  4937              LDR      r1,|L1.3360|
000c44  f8410028          STR      r0,[r1,r8,LSL #2]
;;;1351   	
;;;1352   												KD_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+9];
000c48  4827              LDR      r0,|L1.3304|
000c4a  7b00              LDRB     r0,[r0,#0xc]  ; Comand_Buf
000c4c  4935              LDR      r1,|L1.3364|
000c4e  7008              STRB     r0,[r1,#0]
;;;1353   												KD_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+10];
000c50  4825              LDR      r0,|L1.3304|
000c52  7b40              LDRB     r0,[r0,#0xd]  ; Comand_Buf
000c54  7048              STRB     r0,[r1,#1]
;;;1354   												KD_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+11];
000c56  4824              LDR      r0,|L1.3304|
000c58  7b80              LDRB     r0,[r0,#0xe]  ; Comand_Buf
000c5a  7088              STRB     r0,[r1,#2]
;;;1355   												KD_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+12];
000c5c  4822              LDR      r0,|L1.3304|
000c5e  7bc0              LDRB     r0,[r0,#0xf]  ; Comand_Buf
000c60  70c8              STRB     r0,[r1,#3]
;;;1356   												Kd[u8temp3] = KD_temp.float_num;
000c62  4608              MOV      r0,r1
000c64  6800              LDR      r0,[r0,#0]  ; KD_temp
000c66  4930              LDR      r1,|L1.3368|
000c68  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.3180|
;;;1357   	
;;;1358   											}
;;;1359   											break;
000c6c  e01a              B        |L1.3236|
;;;1360   	
;;;1361   									case TYP_PID_KL:
;;;1362   												if(u8temp1 < 4)
000c6e  2e04              CMP      r6,#4
000c70  da02              BGE      |L1.3192|
;;;1363   													ResCode=ERR_LENGTH;
000c72  2001              MOVS     r0,#1
000c74  9008              STR      r0,[sp,#0x20]
000c76  e011              B        |L1.3228|
                  |L1.3192|
;;;1364   												else
;;;1365   												{
;;;1366   													KL_temp.tempd.byte0 = Comand_Buf[TYP_BYTE_NUM+1];
000c78  481b              LDR      r0,|L1.3304|
000c7a  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
000c7c  492b              LDR      r1,|L1.3372|
000c7e  7008              STRB     r0,[r1,#0]
;;;1367   													KL_temp.tempd.byte1 = Comand_Buf[TYP_BYTE_NUM+2];
000c80  4819              LDR      r0,|L1.3304|
000c82  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000c84  7048              STRB     r0,[r1,#1]
;;;1368   													KL_temp.tempd.byte2 = Comand_Buf[TYP_BYTE_NUM+3];
000c86  4818              LDR      r0,|L1.3304|
000c88  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000c8a  7088              STRB     r0,[r1,#2]
;;;1369   													KL_temp.tempd.byte3 = Comand_Buf[TYP_BYTE_NUM+4];
000c8c  4816              LDR      r0,|L1.3304|
000c8e  79c0              LDRB     r0,[r0,#7]  ; Comand_Buf
000c90  70c8              STRB     r0,[r1,#3]
;;;1370   													Kl[u8temp3] = KL_temp.float_num;
000c92  4608              MOV      r0,r1
000c94  6800              LDR      r0,[r0,#0]  ; KL_temp
000c96  4926              LDR      r1,|L1.3376|
000c98  f8410028          STR      r0,[r1,r8,LSL #2]
                  |L1.3228|
;;;1371   												}
;;;1372   											break;
000c9c  e002              B        |L1.3236|
                  |L1.3230|
;;;1373   									default:
;;;1374   											ResCode=ERR_TYP;
000c9e  2005              MOVS     r0,#5
000ca0  9008              STR      r0,[sp,#0x20]
;;;1375   										break;
000ca2  bf00              NOP      
                  |L1.3236|
000ca4  bf00              NOP                            ;1271
                  |L1.3238|
;;;1376   								}
;;;1377   							}
;;;1378   							if(USB_ReceiveFlg==TRUE)
000ca6  4823              LDR      r0,|L1.3380|
000ca8  7800              LDRB     r0,[r0,#0]  ; USB_ReceiveFlg
000caa  2801              CMP      r0,#1
000cac  d10e              BNE      |L1.3276|
;;;1379   							{
;;;1380   							    TxBuffer[0]= CMD_PID_CFG;									
000cae  2011              MOVS     r0,#0x11
000cb0  4913              LDR      r1,|L1.3328|
000cb2  7008              STRB     r0,[r1,#0]
;;;1381                    	TransLen=1;
000cb4  2001              MOVS     r0,#1
000cb6  9007              STR      r0,[sp,#0x1c]
;;;1382   							    USB_ReceiveFlg=FALSE;
000cb8  2000              MOVS     r0,#0
000cba  491e              LDR      r1,|L1.3380|
000cbc  7008              STRB     r0,[r1,#0]
;;;1383   							    USBRes(ResCode, CMD_PID_CFG, TxBuffer, TransLen);
000cbe  4a10              LDR      r2,|L1.3328|
000cc0  2111              MOVS     r1,#0x11
000cc2  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000cc6  f7fffffe          BL       USBRes
000cca  e002              B        |L1.3282|
                  |L1.3276|
;;;1384   							}
;;;1385   							else
;;;1386   							  TxBuffer[0]= CMD_PID_CFG;									
000ccc  2011              MOVS     r0,#0x11
000cce  490c              LDR      r1,|L1.3328|
000cd0  7008              STRB     r0,[r1,#0]
                  |L1.3282|
;;;1387                  	TransLen=1;
000cd2  2001              MOVS     r0,#1
000cd4  9007              STR      r0,[sp,#0x1c]
;;;1388   								USBRes(ResCode, CMD_PID_CFG, TxBuffer, TransLen);
000cd6  4a0a              LDR      r2,|L1.3328|
000cd8  2111              MOVS     r1,#0x11
000cda  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000cde  f7fffffe          BL       USBRes
                  |L1.3298|
;;;1389   						break; 
000ce2  e279              B        |L1.4568|
                  |L1.3300|
                          DCD      0x43160000
                  |L1.3304|
                          DCD      Comand_Buf
                  |L1.3308|
                          DCD      TempCtrlTime_Sec_2
                  |L1.3312|
                          DCD      TempTickLength_2
                  |L1.3316|
                          DCD      TempSet_2
                  |L1.3320|
                          DCD      TempCtrl_Active_2
                  |L1.3324|
                          DCD      TempValid
                  |L1.3328|
                          DCD      TxBuffer
                  |L1.3332|
                          DCD      TempPumpSet
                  |L1.3336|
                          DCD      TempCtrl_Active
                  |L1.3340|
                          DCD      UnionTemp
                  |L1.3344|
                          DCD      KP_temp
                  |L1.3348|
                          DCD      Ktm
                  |L1.3352|
                          DCD      ||Kp||
                  |L1.3356|
                          DCD      KI_temp
                  |L1.3360|
                          DCD      ||Ki||
                  |L1.3364|
                          DCD      KD_temp
                  |L1.3368|
                          DCD      ||Kd||
                  |L1.3372|
                          DCD      KL_temp
                  |L1.3376|
                          DCD      ||Kl||
                  |L1.3380|
                          DCD      USB_ReceiveFlg
                  |L1.3384|
;;;1390   					
;;;1391   					case  CMD_PID_READ:
;;;1392   					/*
;;;1393   						  	TransLen=12;
;;;1394   							ResCode=NO_ERR;
;;;1395   							TxBuffer[0]=KP_temp.tempd.byte0;
;;;1396   							TxBuffer[1]=KP_temp.tempd.byte1;
;;;1397   							TxBuffer[2]=KP_temp.tempd.byte2;
;;;1398   							TxBuffer[3]=KP_temp.tempd.byte3;
;;;1399   
;;;1400   							TxBuffer[4]=KI_temp.tempd.byte0;
;;;1401   							TxBuffer[5]=KI_temp.tempd.byte1;
;;;1402   							TxBuffer[6]=KI_temp.tempd.byte2;
;;;1403   							TxBuffer[7]=KI_temp.tempd.byte3;
;;;1404   
;;;1405   							TxBuffer[8]=KL_temp.tempd.byte0;
;;;1406   							TxBuffer[9]=KL_temp.tempd.byte1;
;;;1407   							TxBuffer[10]=KL_temp.tempd.byte2;
;;;1408   							TxBuffer[11]=KL_temp.tempd.byte3;
;;;1409   							USBRes(ResCode, CMD_PID_READ, TxBuffer, TransLen);
;;;1410   					*/
;;;1411   							ResCode=NO_ERR;
000d38  2000              MOVS     r0,#0
000d3a  9008              STR      r0,[sp,#0x20]
;;;1412                 TxBuffer[0] = 0x1;//txc add
000d3c  2001              MOVS     r0,#1
000d3e  49fc              LDR      r1,|L1.4400|
000d40  7008              STRB     r0,[r1,#0]
;;;1413   							TxBuffer[1]=PID_SLOP_SEG_MAX;
000d42  2002              MOVS     r0,#2
000d44  7048              STRB     r0,[r1,#1]
;;;1414   							KP_temp.float_num=Ktm[0];
000d46  48fb              LDR      r0,|L1.4404|
000d48  6800              LDR      r0,[r0,#0]  ; Ktm
000d4a  49fb              LDR      r1,|L1.4408|
000d4c  6008              STR      r0,[r1,#0]  ; KP_temp
;;;1415    							TxBuffer[2]=KP_temp.tempd.byte0;
000d4e  4608              MOV      r0,r1
000d50  7800              LDRB     r0,[r0,#0]  ; KP_temp
000d52  49f7              LDR      r1,|L1.4400|
000d54  7088              STRB     r0,[r1,#2]
;;;1416   							TxBuffer[3]=KP_temp.tempd.byte1;
000d56  48f8              LDR      r0,|L1.4408|
000d58  7840              LDRB     r0,[r0,#1]  ; KP_temp
000d5a  70c8              STRB     r0,[r1,#3]
;;;1417   							TxBuffer[4]=KP_temp.tempd.byte2;
000d5c  48f6              LDR      r0,|L1.4408|
000d5e  7880              LDRB     r0,[r0,#2]  ; KP_temp
000d60  7108              STRB     r0,[r1,#4]
;;;1418   							TxBuffer[5]=KP_temp.tempd.byte3;
000d62  48f5              LDR      r0,|L1.4408|
000d64  78c0              LDRB     r0,[r0,#3]  ; KP_temp
000d66  7148              STRB     r0,[r1,#5]
;;;1419   
;;;1420   							j=6;
000d68  f04f0a06          MOV      r10,#6
;;;1421   							for(i=0;i<PID_SLOP_SEG_MAX;i++)
000d6c  f04f0b00          MOV      r11,#0
000d70  e099              B        |L1.3750|
                  |L1.3442|
;;;1422   							{
;;;1423   							
;;;1424   							KP_temp.float_num=Kp[i];
000d72  48f2              LDR      r0,|L1.4412|
000d74  f850002b          LDR      r0,[r0,r11,LSL #2]
000d78  49ef              LDR      r1,|L1.4408|
000d7a  6008              STR      r0,[r1,#0]  ; KP_temp
;;;1425   							TxBuffer[j++]=KP_temp.tempd.byte0;
000d7c  4608              MOV      r0,r1
000d7e  7802              LDRB     r2,[r0,#0]  ; KP_temp
000d80  4650              MOV      r0,r10
000d82  1c41              ADDS     r1,r0,#1
000d84  fa1ffa81          UXTH     r10,r1
000d88  49e9              LDR      r1,|L1.4400|
000d8a  540a              STRB     r2,[r1,r0]
;;;1426   							TxBuffer[j++]=KP_temp.tempd.byte1;
000d8c  48ea              LDR      r0,|L1.4408|
000d8e  7842              LDRB     r2,[r0,#1]  ; KP_temp
000d90  4650              MOV      r0,r10
000d92  1c41              ADDS     r1,r0,#1
000d94  fa1ffa81          UXTH     r10,r1
000d98  49e5              LDR      r1,|L1.4400|
000d9a  540a              STRB     r2,[r1,r0]
;;;1427   							TxBuffer[j++]=KP_temp.tempd.byte2;
000d9c  48e6              LDR      r0,|L1.4408|
000d9e  7882              LDRB     r2,[r0,#2]  ; KP_temp
000da0  4650              MOV      r0,r10
000da2  1c41              ADDS     r1,r0,#1
000da4  fa1ffa81          UXTH     r10,r1
000da8  49e1              LDR      r1,|L1.4400|
000daa  540a              STRB     r2,[r1,r0]
;;;1428   							TxBuffer[j++]=KP_temp.tempd.byte3;
000dac  48e2              LDR      r0,|L1.4408|
000dae  78c2              LDRB     r2,[r0,#3]  ; KP_temp
000db0  4650              MOV      r0,r10
000db2  1c41              ADDS     r1,r0,#1
000db4  fa1ffa81          UXTH     r10,r1
000db8  49dd              LDR      r1,|L1.4400|
000dba  540a              STRB     r2,[r1,r0]
;;;1429   
;;;1430    							KP_temp.float_num=Ki[i];
000dbc  48e0              LDR      r0,|L1.4416|
000dbe  f850002b          LDR      r0,[r0,r11,LSL #2]
000dc2  49dd              LDR      r1,|L1.4408|
000dc4  6008              STR      r0,[r1,#0]  ; KP_temp
;;;1431   							TxBuffer[j++]=KP_temp.tempd.byte0;
000dc6  4608              MOV      r0,r1
000dc8  7802              LDRB     r2,[r0,#0]  ; KP_temp
000dca  4650              MOV      r0,r10
000dcc  1c41              ADDS     r1,r0,#1
000dce  fa1ffa81          UXTH     r10,r1
000dd2  49d7              LDR      r1,|L1.4400|
000dd4  540a              STRB     r2,[r1,r0]
;;;1432   							TxBuffer[j++]=KP_temp.tempd.byte1;
000dd6  48d8              LDR      r0,|L1.4408|
000dd8  7842              LDRB     r2,[r0,#1]  ; KP_temp
000dda  4650              MOV      r0,r10
000ddc  1c41              ADDS     r1,r0,#1
000dde  fa1ffa81          UXTH     r10,r1
000de2  49d3              LDR      r1,|L1.4400|
000de4  540a              STRB     r2,[r1,r0]
;;;1433   							TxBuffer[j++]=KP_temp.tempd.byte2;
000de6  48d4              LDR      r0,|L1.4408|
000de8  7882              LDRB     r2,[r0,#2]  ; KP_temp
000dea  4650              MOV      r0,r10
000dec  1c41              ADDS     r1,r0,#1
000dee  fa1ffa81          UXTH     r10,r1
000df2  49cf              LDR      r1,|L1.4400|
000df4  540a              STRB     r2,[r1,r0]
;;;1434   							TxBuffer[j++]=KP_temp.tempd.byte3;
000df6  48d0              LDR      r0,|L1.4408|
000df8  78c2              LDRB     r2,[r0,#3]  ; KP_temp
000dfa  4650              MOV      r0,r10
000dfc  1c41              ADDS     r1,r0,#1
000dfe  fa1ffa81          UXTH     r10,r1
000e02  49cb              LDR      r1,|L1.4400|
000e04  540a              STRB     r2,[r1,r0]
;;;1435   
;;;1436    							KP_temp.float_num=Kd[i];
000e06  48cf              LDR      r0,|L1.4420|
000e08  f850002b          LDR      r0,[r0,r11,LSL #2]
000e0c  49ca              LDR      r1,|L1.4408|
000e0e  6008              STR      r0,[r1,#0]  ; KP_temp
;;;1437   							TxBuffer[j++]=KP_temp.tempd.byte0;
000e10  4608              MOV      r0,r1
000e12  7802              LDRB     r2,[r0,#0]  ; KP_temp
000e14  4650              MOV      r0,r10
000e16  1c41              ADDS     r1,r0,#1
000e18  fa1ffa81          UXTH     r10,r1
000e1c  49c4              LDR      r1,|L1.4400|
000e1e  540a              STRB     r2,[r1,r0]
;;;1438   							TxBuffer[j++]=KP_temp.tempd.byte1;
000e20  48c5              LDR      r0,|L1.4408|
000e22  7842              LDRB     r2,[r0,#1]  ; KP_temp
000e24  4650              MOV      r0,r10
000e26  1c41              ADDS     r1,r0,#1
000e28  fa1ffa81          UXTH     r10,r1
000e2c  49c0              LDR      r1,|L1.4400|
000e2e  540a              STRB     r2,[r1,r0]
;;;1439   							TxBuffer[j++]=KP_temp.tempd.byte2;
000e30  48c1              LDR      r0,|L1.4408|
000e32  7882              LDRB     r2,[r0,#2]  ; KP_temp
000e34  4650              MOV      r0,r10
000e36  1c41              ADDS     r1,r0,#1
000e38  fa1ffa81          UXTH     r10,r1
000e3c  49bc              LDR      r1,|L1.4400|
000e3e  540a              STRB     r2,[r1,r0]
;;;1440   							TxBuffer[j++]=KP_temp.tempd.byte3;
000e40  48bd              LDR      r0,|L1.4408|
000e42  78c2              LDRB     r2,[r0,#3]  ; KP_temp
000e44  4650              MOV      r0,r10
000e46  1c41              ADDS     r1,r0,#1
000e48  e000              B        |L1.3660|
                  |L1.3658|
000e4a  e148              B        |L1.4318|
                  |L1.3660|
000e4c  fa1ffa81          UXTH     r10,r1
000e50  49b7              LDR      r1,|L1.4400|
000e52  540a              STRB     r2,[r1,r0]
;;;1441   
;;;1442   							KP_temp.float_num=Kl[i];
000e54  48bc              LDR      r0,|L1.4424|
000e56  f850002b          LDR      r0,[r0,r11,LSL #2]
000e5a  49b7              LDR      r1,|L1.4408|
000e5c  6008              STR      r0,[r1,#0]  ; KP_temp
;;;1443   							TxBuffer[j++]=KP_temp.tempd.byte0;
000e5e  4608              MOV      r0,r1
000e60  7802              LDRB     r2,[r0,#0]  ; KP_temp
000e62  4650              MOV      r0,r10
000e64  1c41              ADDS     r1,r0,#1
000e66  fa1ffa81          UXTH     r10,r1
000e6a  49b1              LDR      r1,|L1.4400|
000e6c  540a              STRB     r2,[r1,r0]
;;;1444   							TxBuffer[j++]=KP_temp.tempd.byte1;
000e6e  48b2              LDR      r0,|L1.4408|
000e70  7842              LDRB     r2,[r0,#1]  ; KP_temp
000e72  4650              MOV      r0,r10
000e74  1c41              ADDS     r1,r0,#1
000e76  fa1ffa81          UXTH     r10,r1
000e7a  49ad              LDR      r1,|L1.4400|
000e7c  540a              STRB     r2,[r1,r0]
;;;1445   							TxBuffer[j++]=KP_temp.tempd.byte2;
000e7e  48ae              LDR      r0,|L1.4408|
000e80  7882              LDRB     r2,[r0,#2]  ; KP_temp
000e82  4650              MOV      r0,r10
000e84  1c41              ADDS     r1,r0,#1
000e86  fa1ffa81          UXTH     r10,r1
000e8a  49a9              LDR      r1,|L1.4400|
000e8c  540a              STRB     r2,[r1,r0]
;;;1446   							TxBuffer[j++]=KP_temp.tempd.byte3;
000e8e  48aa              LDR      r0,|L1.4408|
000e90  78c2              LDRB     r2,[r0,#3]  ; KP_temp
000e92  4650              MOV      r0,r10
000e94  1c41              ADDS     r1,r0,#1
000e96  fa1ffa81          UXTH     r10,r1
000e9a  49a5              LDR      r1,|L1.4400|
000e9c  540a              STRB     r2,[r1,r0]
000e9e  f10b0001          ADD      r0,r11,#1             ;1421
000ea2  fa1ffb80          UXTH     r11,r0                ;1421
                  |L1.3750|
000ea6  f1bb0f02          CMP      r11,#2                ;1421
000eaa  f6ffaf62          BLT      |L1.3442|
;;;1447   							}
;;;1448   							TransLen=j+1;
000eae  f10a0001          ADD      r0,r10,#1
000eb2  b2c0              UXTB     r0,r0
000eb4  9007              STR      r0,[sp,#0x1c]
;;;1449   							USBRes(ResCode, CMD_PID_READ, TxBuffer, TransLen);
000eb6  4a9e              LDR      r2,|L1.4400|
000eb8  2112              MOVS     r1,#0x12
000eba  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000ebe  e000              B        |L1.3778|
                  |L1.3776|
000ec0  e18b              B        |L1.4570|
                  |L1.3778|
000ec2  f7fffffe          BL       USBRes
;;;1450   
;;;1451   
;;;1452   						break;
000ec6  e187              B        |L1.4568|
                  |L1.3784|
;;;1453   
;;;1454   
;;;1455   					////////////////// 2014-05-20 //////////////
;;;1456   											   
;;;1457   					case CMD_CYCLE_CTRL:
;;;1458   							TxBuffer[0]= CMD_CYCLE_CTRL;	//txc							
000ec8  2013              MOVS     r0,#0x13
000eca  4999              LDR      r1,|L1.4400|
000ecc  7008              STRB     r0,[r1,#0]
;;;1459   					    TransLen=1;
000ece  2001              MOVS     r0,#1
000ed0  9007              STR      r0,[sp,#0x1c]
;;;1460   							u8temp2=Comand_Buf[TYP_BYTE_NUM];
000ed2  489e              LDR      r0,|L1.4428|
000ed4  78c7              LDRB     r7,[r0,#3]  ; Comand_Buf
;;;1461   							u8temp1=Comand_Buf[LEN_BYTE_NUM];
000ed6  7886              LDRB     r6,[r0,#2]  ; Comand_Buf
;;;1462   							ResCode=NO_ERR;
000ed8  2000              MOVS     r0,#0
000eda  9008              STR      r0,[sp,#0x20]
;;;1463   							switch(u8temp2)
000edc  2f03              CMP      r7,#3
000ede  d002              BEQ      |L1.3814|
000ee0  2f04              CMP      r7,#4
000ee2  d16f              BNE      |L1.4036|
000ee4  e06f              B        |L1.4038|
                  |L1.3814|
;;;1464   							{
;;;1465   								case TYP_CYCLE_LOAD:
;;;1466   					
;;;1467   									if((Comand_Buf[SECT_BYTE]<1) || (Comand_Buf[STAGE_BYTE]<1))
000ee6  4899              LDR      r0,|L1.4428|
000ee8  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
000eea  2801              CMP      r0,#1
000eec  db03              BLT      |L1.3830|
000eee  4897              LDR      r0,|L1.4428|
000ef0  7980              LDRB     r0,[r0,#6]  ; Comand_Buf
000ef2  2801              CMP      r0,#1
000ef4  da02              BGE      |L1.3836|
                  |L1.3830|
;;;1468   									 	ResCode=OUT_RANGE;
000ef6  2007              MOVS     r0,#7
000ef8  9008              STR      r0,[sp,#0x20]
000efa  e05c              B        |L1.4022|
                  |L1.3836|
;;;1469   									else
;;;1470   									{
;;;1471   										//Buffer_Cycle_Control.TotalSect=Comand_Buf[SECT_BYTE]-1;
;;;1472   										u8temp=Comand_Buf[STAGE_BYTE];
000efc  4893              LDR      r0,|L1.4428|
000efe  7985              LDRB     r5,[r0,#6]  ; Comand_Buf
;;;1473   										Buffer_Cycle_Control.TotalStage= u8temp-1;
000f00  1e68              SUBS     r0,r5,#1
000f02  4993              LDR      r1,|L1.4432|
000f04  70c8              STRB     r0,[r1,#3]
;;;1474   									
;;;1475   										for(i=0;i<u8temp;i++)	
000f06  f04f0b00          MOV      r11,#0
000f0a  e036              B        |L1.3962|
                  |L1.3852|
000f0c  e163              B        |L1.4566|
                  |L1.3854|
;;;1476   										{
;;;1477   											u8temp1=i*BYTE_PER_STAGE;
000f0e  eb0b004b          ADD      r0,r11,r11,LSL #1
000f12  0640              LSLS     r0,r0,#25
000f14  0e06              LSRS     r6,r0,#24
;;;1478   											Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte0=Comand_Buf[SET_START_BYTE+u8temp1];
000f16  1df0              ADDS     r0,r6,#7
000f18  498c              LDR      r1,|L1.4428|
000f1a  5c08              LDRB     r0,[r1,r0]
000f1c  498d              LDR      r1,|L1.4436|
000f1e  f801003b          STRB     r0,[r1,r11,LSL #3]
;;;1479   											Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte1=Comand_Buf[SET_START_BYTE+u8temp1+1];
000f22  f1060008          ADD      r0,r6,#8
000f26  4989              LDR      r1,|L1.4428|
000f28  5c08              LDRB     r0,[r1,r0]
000f2a  498a              LDR      r1,|L1.4436|
000f2c  eb0101cb          ADD      r1,r1,r11,LSL #3
000f30  7048              STRB     r0,[r1,#1]
;;;1480   											Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte2=Comand_Buf[SET_START_BYTE+u8temp1+2];
000f32  f1060009          ADD      r0,r6,#9
000f36  4985              LDR      r1,|L1.4428|
000f38  5c08              LDRB     r0,[r1,r0]
000f3a  4986              LDR      r1,|L1.4436|
000f3c  eb0101cb          ADD      r1,r1,r11,LSL #3
000f40  7088              STRB     r0,[r1,#2]
;;;1481   											Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte3=Comand_Buf[SET_START_BYTE+u8temp1+3];
000f42  f106000a          ADD      r0,r6,#0xa
000f46  4981              LDR      r1,|L1.4428|
000f48  5c08              LDRB     r0,[r1,r0]
000f4a  4982              LDR      r1,|L1.4436|
000f4c  eb0101cb          ADD      r1,r1,r11,LSL #3
000f50  70c8              STRB     r0,[r1,#3]
;;;1482   			
;;;1483   											Buffer_Cycle_SetPoint[i].SetTime_Union.tempw.byte1=Comand_Buf[SET_START_BYTE+u8temp1+4];
000f52  f106000b          ADD      r0,r6,#0xb
000f56  497d              LDR      r1,|L1.4428|
000f58  5c09              LDRB     r1,[r1,r0]
000f5a  487e              LDR      r0,|L1.4436|
000f5c  eb0000cb          ADD      r0,r0,r11,LSL #3
000f60  7141              STRB     r1,[r0,#5]
;;;1484   											Buffer_Cycle_SetPoint[i].SetTime_Union.tempw.byte0=Comand_Buf[SET_START_BYTE+u8temp1+5];
000f62  f106000c          ADD      r0,r6,#0xc
000f66  4979              LDR      r1,|L1.4428|
000f68  5c08              LDRB     r0,[r1,r0]
000f6a  497a              LDR      r1,|L1.4436|
000f6c  eb0101cb          ADD      r1,r1,r11,LSL #3
000f70  7108              STRB     r0,[r1,#4]
000f72  f10b0001          ADD      r0,r11,#1             ;1475
000f76  fa1ffb80          UXTH     r11,r0                ;1475
                  |L1.3962|
000f7a  45ab              CMP      r11,r5                ;1475
000f7c  dbc7              BLT      |L1.3854|
;;;1485   			
;;;1486   										}
;;;1487   										if(SetPoint_Check(u8temp,Buffer_Cycle_SetPoint)!= VALID)
000f7e  4975              LDR      r1,|L1.4436|
000f80  4628              MOV      r0,r5
000f82  f7fffffe          BL       SetPoint_Check
000f86  2801              CMP      r0,#1
000f88  d002              BEQ      |L1.3984|
;;;1488   											ResCode=OUT_RANGE;	
000f8a  2007              MOVS     r0,#7
000f8c  9008              STR      r0,[sp,#0x20]
000f8e  e012              B        |L1.4022|
                  |L1.3984|
;;;1489   										else
;;;1490   										{
;;;1491   			
;;;1492   											PCR_Cycle_Control.CycleValid=INVALID;
000f90  2000              MOVS     r0,#0
000f92  4971              LDR      r1,|L1.4440|
000f94  7008              STRB     r0,[r1,#0]
;;;1493   											TempControl_2_stop();		
000f96  f7fffffe          BL       TempControl_2_stop
;;;1494   											PID_Clear(SENSOR2_INDEX);
000f9a  2001              MOVS     r0,#1
000f9c  f7fffffe          BL       PID_Clear
;;;1495   											SetPoint_Copy(u8temp,Buffer_Cycle_SetPoint, PCR_Cycle_SetPoint);
000fa0  4a6e              LDR      r2,|L1.4444|
000fa2  496c              LDR      r1,|L1.4436|
000fa4  4628              MOV      r0,r5
000fa6  f7fffffe          BL       SetPoint_Copy
;;;1496   											//PCR_Cycle_Control.TotalSect= Buffer_Cycle_Control.TatalSect;
;;;1497   											PCR_Cycle_Control.TotalStage= Buffer_Cycle_Control.TotalStage;
000faa  4869              LDR      r0,|L1.4432|
000fac  78c0              LDRB     r0,[r0,#3]  ; Buffer_Cycle_Control
000fae  496a              LDR      r1,|L1.4440|
000fb0  70c8              STRB     r0,[r1,#3]
;;;1498   											PCR_Cycle_Control.CycleValid=VALID;
000fb2  2001              MOVS     r0,#1
000fb4  7008              STRB     r0,[r1,#0]
                  |L1.4022|
;;;1499   											//SetPoint_Cycle_Start(PCR_Cycle_SetPoint);
;;;1500   										}
;;;1501   									}
;;;1502   									USBRes(ResCode, CMD_CYCLE_CTRL, TxBuffer, TransLen);
000fb6  4a5e              LDR      r2,|L1.4400|
000fb8  2113              MOVS     r1,#0x13
000fba  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
000fbe  f7fffffe          BL       USBRes
;;;1503   
;;;1504   									break;
000fc2  e08a              B        |L1.4314|
                  |L1.4036|
000fc4  e088              B        |L1.4312|
                  |L1.4038|
;;;1505   
;;;1506   
;;;1507   								case TYP_PE_LOAD: // pump, ext, start inforamtion
;;;1508   
;;;1509   									ResCode=NO_ERR;
000fc6  2000              MOVS     r0,#0
000fc8  9008              STR      r0,[sp,#0x20]
;;;1510   							    TxBuffer[0]= TYP_PE_LOAD;	//txc	
000fca  2004              MOVS     r0,#4
000fcc  4958              LDR      r1,|L1.4400|
000fce  7008              STRB     r0,[r1,#0]
;;;1511   									TransLen=1;
000fd0  2001              MOVS     r0,#1
000fd2  9007              STR      r0,[sp,#0x1c]
;;;1512   									for(i=0;i<2;i++)
000fd4  f04f0b00          MOV      r11,#0
000fd8  e035              B        |L1.4166|
                  |L1.4058|
;;;1513   									{
;;;1514   										u8temp1=i*BYTE_PER_STAGE;  
000fda  eb0b004b          ADD      r0,r11,r11,LSL #1
000fde  0640              LSLS     r0,r0,#25
000fe0  0e06              LSRS     r6,r0,#24
;;;1515   										Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte0=Comand_Buf[SET_START_BYTE+u8temp1];
000fe2  1df0              ADDS     r0,r6,#7
000fe4  4959              LDR      r1,|L1.4428|
000fe6  5c08              LDRB     r0,[r1,r0]
000fe8  495a              LDR      r1,|L1.4436|
000fea  f801003b          STRB     r0,[r1,r11,LSL #3]
;;;1516   										Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte1=Comand_Buf[SET_START_BYTE+u8temp1+1];
000fee  f1060008          ADD      r0,r6,#8
000ff2  4956              LDR      r1,|L1.4428|
000ff4  5c08              LDRB     r0,[r1,r0]
000ff6  4957              LDR      r1,|L1.4436|
000ff8  eb0101cb          ADD      r1,r1,r11,LSL #3
000ffc  7048              STRB     r0,[r1,#1]
;;;1517   										Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte2=Comand_Buf[SET_START_BYTE+u8temp1+2];
000ffe  f1060009          ADD      r0,r6,#9
001002  4952              LDR      r1,|L1.4428|
001004  5c08              LDRB     r0,[r1,r0]
001006  4953              LDR      r1,|L1.4436|
001008  eb0101cb          ADD      r1,r1,r11,LSL #3
00100c  7088              STRB     r0,[r1,#2]
;;;1518   										Buffer_Cycle_SetPoint[i].SetPoint.tempd.byte3=Comand_Buf[SET_START_BYTE+u8temp1+3];
00100e  f106000a          ADD      r0,r6,#0xa
001012  494e              LDR      r1,|L1.4428|
001014  5c08              LDRB     r0,[r1,r0]
001016  494f              LDR      r1,|L1.4436|
001018  eb0101cb          ADD      r1,r1,r11,LSL #3
00101c  70c8              STRB     r0,[r1,#3]
;;;1519   		
;;;1520   										Buffer_Cycle_SetPoint[i].SetTime_Union.tempw.byte1=Comand_Buf[SET_START_BYTE+u8temp1+4];
00101e  f106000b          ADD      r0,r6,#0xb
001022  494a              LDR      r1,|L1.4428|
001024  5c09              LDRB     r1,[r1,r0]
001026  484b              LDR      r0,|L1.4436|
001028  eb0000cb          ADD      r0,r0,r11,LSL #3
00102c  7141              STRB     r1,[r0,#5]
;;;1521   										Buffer_Cycle_SetPoint[i].SetTime_Union.tempw.byte0=Comand_Buf[SET_START_BYTE+u8temp1+5];
00102e  f106000c          ADD      r0,r6,#0xc
001032  4946              LDR      r1,|L1.4428|
001034  5c08              LDRB     r0,[r1,r0]
001036  4947              LDR      r1,|L1.4436|
001038  eb0101cb          ADD      r1,r1,r11,LSL #3
00103c  7108              STRB     r0,[r1,#4]
00103e  f10b0001          ADD      r0,r11,#1             ;1512
001042  fa1ffb80          UXTH     r11,r0                ;1512
                  |L1.4166|
001046  f1bb0f02          CMP      r11,#2                ;1512
00104a  dbc6              BLT      |L1.4058|
;;;1522   									}
;;;1523   
;;;1524   									if(SetPoint_Check(2,Buffer_Cycle_SetPoint)!= VALID)
00104c  4941              LDR      r1,|L1.4436|
00104e  2002              MOVS     r0,#2
001050  f7fffffe          BL       SetPoint_Check
001054  2801              CMP      r0,#1
001056  d002              BEQ      |L1.4190|
;;;1525   											ResCode=OUT_RANGE;	
001058  2007              MOVS     r0,#7
00105a  9008              STR      r0,[sp,#0x20]
00105c  e027              B        |L1.4270|
                  |L1.4190|
;;;1526   									else
;;;1527   									{
;;;1528   										SetPoint_Copy(2,Buffer_Cycle_SetPoint, PE_Cycle_SetPoint);
00105e  4a40              LDR      r2,|L1.4448|
001060  493c              LDR      r1,|L1.4436|
001062  2002              MOVS     r0,#2
001064  f7fffffe          BL       SetPoint_Copy
;;;1529   	                       
;;;1530   										if(Comand_Buf[CYCLE_SET_BYTE]==1) // comand to start cycle
001068  4838              LDR      r0,|L1.4428|
00106a  7900              LDRB     r0,[r0,#4]  ; Comand_Buf
00106c  2801              CMP      r0,#1
00106e  d11e              BNE      |L1.4270|
;;;1531   										{
;;;1532   												
;;;1533   												if(PCR_Cycle_Control.CycleValid==VALID)
001070  4839              LDR      r0,|L1.4440|
001072  7800              LDRB     r0,[r0,#0]  ; PCR_Cycle_Control
001074  2801              CMP      r0,#1
001076  d118              BNE      |L1.4266|
;;;1534   												{
;;;1535   													if(CycleSTS != READY)
001078  483a              LDR      r0,|L1.4452|
00107a  7800              LDRB     r0,[r0,#0]  ; CycleSTS
00107c  b168              CBZ      r0,|L1.4250|
;;;1536   													{
;;;1537   										 				TempCtrl_Active=TempCtrl_Active_2=0;
00107e  2000              MOVS     r0,#0
001080  4939              LDR      r1,|L1.4456|
001082  7008              STRB     r0,[r1,#0]
001084  4939              LDR      r1,|L1.4460|
001086  7008              STRB     r0,[r1,#0]
;;;1538   														TempValid =0;
001088  4939              LDR      r1,|L1.4464|
00108a  7008              STRB     r0,[r1,#0]
;;;1539   														TempControl_stop();
00108c  f7fffffe          BL       TempControl_stop
;;;1540   														TempControl_2_stop();
001090  f7fffffe          BL       TempControl_2_stop
;;;1541   														CycleSTS=READY;												
001094  2000              MOVS     r0,#0
001096  4933              LDR      r1,|L1.4452|
001098  7008              STRB     r0,[r1,#0]
                  |L1.4250|
;;;1542   													}
;;;1543   													PCR_Cycle_Control.TotalCycle=Comand_Buf[CYCLE_NUM_BYTE]-1;  // @0607, new cmd
00109a  482c              LDR      r0,|L1.4428|
00109c  7940              LDRB     r0,[r0,#5]  ; Comand_Buf
00109e  1e40              SUBS     r0,r0,#1
0010a0  492d              LDR      r1,|L1.4440|
0010a2  7048              STRB     r0,[r1,#1]
;;;1544   													Cycle_Control_Start();
0010a4  f7fffffe          BL       Cycle_Control_Start
0010a8  e001              B        |L1.4270|
                  |L1.4266|
;;;1545   												}
;;;1546   												else
;;;1547   													ResCode=ERR_UNDEF;	// @0607 user did not define data
0010aa  2008              MOVS     r0,#8
0010ac  9008              STR      r0,[sp,#0x20]
                  |L1.4270|
;;;1548   															
;;;1549   										}
;;;1550   									}
;;;1551   									if(USB_ReceiveFlg==TRUE)
0010ae  4831              LDR      r0,|L1.4468|
0010b0  7800              LDRB     r0,[r0,#0]  ; USB_ReceiveFlg
0010b2  2801              CMP      r0,#1
0010b4  d109              BNE      |L1.4298|
;;;1552   									{
;;;1553   										USB_ReceiveFlg=FALSE;
0010b6  2000              MOVS     r0,#0
0010b8  492e              LDR      r1,|L1.4468|
0010ba  7008              STRB     r0,[r1,#0]
;;;1554   									 	USBRes(ResCode, CMD_CYCLE_CTRL, TxBuffer, TransLen);
0010bc  4a1c              LDR      r2,|L1.4400|
0010be  2113              MOVS     r1,#0x13
0010c0  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
0010c4  f7fffffe          BL       USBRes
0010c8  e005              B        |L1.4310|
                  |L1.4298|
;;;1555   									}
;;;1556   									else
;;;1557   										USBRes(ResCode, CMD_CYCLE_CTRL, TxBuffer, TransLen);
0010ca  4a19              LDR      r2,|L1.4400|
0010cc  2113              MOVS     r1,#0x13
0010ce  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
0010d2  f7fffffe          BL       USBRes
                  |L1.4310|
;;;1558   										
;;;1559   									break;
0010d6  e000              B        |L1.4314|
                  |L1.4312|
;;;1560   
;;;1561   								default:
;;;1562   									break;
0010d8  bf00              NOP      
                  |L1.4314|
0010da  bf00              NOP                            ;1504
;;;1563   							 }
;;;1564   							
;;;1565   						break;
0010dc  e07c              B        |L1.4568|
                  |L1.4318|
;;;1566   
;;;1567   					/////////////////////////////////////////
;;;1568   				   	case CMD_CYCLE_CTRL_READ:   // add @ 2014-11-30, read out cycle number
;;;1569    						  	TransLen=2;
0010de  2002              MOVS     r0,#2
0010e0  9007              STR      r0,[sp,#0x1c]
;;;1570   							ResCode=NO_ERR;
0010e2  2000              MOVS     r0,#0
0010e4  9008              STR      r0,[sp,#0x20]
;;;1571   
;;;1572                               u8temp2=Comand_Buf[TYP_BYTE_NUM];
0010e6  4819              LDR      r0,|L1.4428|
0010e8  78c7              LDRB     r7,[r0,#3]  ; Comand_Buf
;;;1573   							switch(u8temp2)
0010ea  2f01              CMP      r7,#1
0010ec  d002              BEQ      |L1.4340|
0010ee  2f02              CMP      r7,#2
0010f0  d164              BNE      |L1.4540|
0010f2  e00d              B        |L1.4368|
                  |L1.4340|
;;;1574   							{
;;;1575   								case TYP_CYCLE_READ:
;;;1576   									TxBuffer[0]=TYP_CYCLE_READ;
0010f4  2001              MOVS     r0,#1
0010f6  490e              LDR      r1,|L1.4400|
0010f8  7008              STRB     r0,[r1,#0]
;;;1577   		 							TxBuffer[1]=Cycle_Check();  //current cycle
0010fa  f7fffffe          BL       Cycle_Check
0010fe  490c              LDR      r1,|L1.4400|
001100  7048              STRB     r0,[r1,#1]
;;;1578   								    TxBuffer[2]=Stage_Check();  // current stage
001102  f7fffffe          BL       Stage_Check
001106  490a              LDR      r1,|L1.4400|
001108  7088              STRB     r0,[r1,#2]
;;;1579   									TransLen=2;
00110a  2002              MOVS     r0,#2
00110c  9007              STR      r0,[sp,#0x1c]
;;;1580   									break;
00110e  e05a              B        |L1.4550|
                  |L1.4368|
;;;1581   
;;;1582   								case TYP_PWM_READ:
;;;1583   									TxBuffer[0]=TYP_PWM_READ;
001110  2002              MOVS     r0,#2
001112  4907              LDR      r1,|L1.4400|
001114  7008              STRB     r0,[r1,#0]
;;;1584   										TxBuffer[1]=TempValid;  //sensor 1,2 valid
001116  4816              LDR      r0,|L1.4464|
001118  7800              LDRB     r0,[r0,#0]  ; TempValid
00111a  7048              STRB     r0,[r1,#1]
;;;1585   										if(Control_2_Dir==NEG_DIR)
00111c  4816              LDR      r0,|L1.4472|
00111e  7800              LDRB     r0,[r0,#0]  ; Control_2_Dir
001120  2802              CMP      r0,#2
001122  d12d              BNE      |L1.4480|
;;;1586   										{
;;;1587   											u8temp=1;
001124  2501              MOVS     r5,#1
;;;1588   											u16temp1=TIM8->CCR1;
001126  4815              LDR      r0,|L1.4476|
001128  8800              LDRH     r0,[r0,#0]
00112a  900a              STR      r0,[sp,#0x28]
00112c  e02c              B        |L1.4488|
00112e  0000              DCW      0x0000
                  |L1.4400|
                          DCD      TxBuffer
                  |L1.4404|
                          DCD      Ktm
                  |L1.4408|
                          DCD      KP_temp
                  |L1.4412|
                          DCD      ||Kp||
                  |L1.4416|
                          DCD      ||Ki||
                  |L1.4420|
                          DCD      ||Kd||
                  |L1.4424|
                          DCD      ||Kl||
                  |L1.4428|
                          DCD      Comand_Buf
                  |L1.4432|
                          DCD      Buffer_Cycle_Control
                  |L1.4436|
                          DCD      Buffer_Cycle_SetPoint
                  |L1.4440|
                          DCD      PCR_Cycle_Control
                  |L1.4444|
                          DCD      PCR_Cycle_SetPoint
                  |L1.4448|
                          DCD      PE_Cycle_SetPoint
                  |L1.4452|
                          DCD      CycleSTS
                  |L1.4456|
                          DCD      TempCtrl_Active_2
                  |L1.4460|
                          DCD      TempCtrl_Active
                  |L1.4464|
                          DCD      TempValid
                  |L1.4468|
                          DCD      USB_ReceiveFlg
                  |L1.4472|
                          DCD      Control_2_Dir
                  |L1.4476|
                          DCD      0x40013434
                  |L1.4480|
;;;1589   										}
;;;1590   										else
;;;1591   										{
;;;1592   											u8temp=0;
001180  2500              MOVS     r5,#0
;;;1593   										    u16temp1=TIM1->CCR1;
001182  48ff              LDR      r0,|L1.5504|
001184  8800              LDRH     r0,[r0,#0]
001186  900a              STR      r0,[sp,#0x28]
                  |L1.4488|
;;;1594   										}
;;;1595   			
;;;1596   										TxBuffer[2]=((TempCtrl_Active<<4) | (u8temp<<3)|(TempCtrl_Active_2)); // active status
001188  48fe              LDR      r0,|L1.5508|
00118a  7800              LDRB     r0,[r0,#0]  ; TempCtrl_Active
00118c  0100              LSLS     r0,r0,#4
00118e  ea4000c5          ORR      r0,r0,r5,LSL #3
001192  49fd              LDR      r1,|L1.5512|
001194  7809              LDRB     r1,[r1,#0]  ; TempCtrl_Active_2
001196  4308              ORRS     r0,r0,r1
001198  49fc              LDR      r1,|L1.5516|
00119a  7088              STRB     r0,[r1,#2]
;;;1597   										u16temp= TIM4->CCR3;
00119c  48fc              LDR      r0,|L1.5520|
00119e  f8b09000          LDRH     r9,[r0,#0]
;;;1598   										TxBuffer[3]= (u8)(u16temp>>8);	  //PWM
0011a2  ea4f2029          ASR      r0,r9,#8
0011a6  70c8              STRB     r0,[r1,#3]
;;;1599   										TxBuffer[4]= (u8)u16temp;
0011a8  f8819004          STRB     r9,[r1,#4]
;;;1600   										TxBuffer[5]= (u8)(u16temp1>>8);
0011ac  980a              LDR      r0,[sp,#0x28]
0011ae  1200              ASRS     r0,r0,#8
0011b0  7148              STRB     r0,[r1,#5]
;;;1601   										TxBuffer[6]= (u8)u16temp1;
0011b2  980a              LDR      r0,[sp,#0x28]
0011b4  7188              STRB     r0,[r1,#6]
;;;1602   										TransLen=7;
0011b6  2007              MOVS     r0,#7
0011b8  9007              STR      r0,[sp,#0x1c]
;;;1603   									break;
0011ba  e004              B        |L1.4550|
                  |L1.4540|
;;;1604   
;;;1605   								default:
;;;1606   										ResCode=ERR_TYP;
0011bc  2005              MOVS     r0,#5
0011be  9008              STR      r0,[sp,#0x20]
;;;1607   										TransLen=0;
0011c0  2000              MOVS     r0,#0
0011c2  9007              STR      r0,[sp,#0x1c]
;;;1608   									break;
0011c4  bf00              NOP      
                  |L1.4550|
0011c6  bf00              NOP                            ;1580
;;;1609   							}
;;;1610   						   USBRes(ResCode, CMD_CYCLE_CTRL_READ, TxBuffer, TransLen);
0011c8  4af0              LDR      r2,|L1.5516|
0011ca  2114              MOVS     r1,#0x14
0011cc  e9dd3007          LDRD     r3,r0,[sp,#0x1c]
0011d0  f7fffffe          BL       USBRes
;;;1611   						break;
0011d4  e000              B        |L1.4568|
                  |L1.4566|
;;;1612    /*
;;;1613   					case CMD_PWM_READ:  //add @2014-11-30 read PWM, peltier status, direction
;;;1614    						  	TransLen=6;
;;;1615   
;;;1616   							ResCode=NO_ERR;
;;;1617   							TxBuffer[0]=TempValid;  //sensor 1,2 valid
;;;1618   							if(Control_2_Dir==NEG_DIR)
;;;1619   							{
;;;1620   								u8temp=1;
;;;1621   								u16temp1=TIM8->CCR1;
;;;1622   							}
;;;1623   							else
;;;1624   							{
;;;1625   								u8temp=0;
;;;1626   							    u16temp1=TIM1->CCR1;
;;;1627   							}
;;;1628   
;;;1629   							TxBuffer[1]=((TempCtrl_Active<<4) | (u8temp<<3)|(TempCtrl_Active_2)); // active status
;;;1630   							u16temp= TIM4->CCR3;
;;;1631   							TxBuffer[2]= (u8)(u16temp>>8);	  //PWM
;;;1632   							TxBuffer[3]= (u8)u16temp;
;;;1633   							TxBuffer[4]= (u8)(u16temp1>>8);
;;;1634   							TxBuffer[5]= (u8)u16temp1;
;;;1635   							USBRes(ResCode, CMD_PID_READ, TxBuffer, TransLen);
;;;1636   						break;
;;;1637    */
;;;1638   					default:
;;;1639   						break;
0011d6  bf00              NOP      
                  |L1.4568|
0011d8  bf00              NOP                            ;655
                  |L1.4570|
;;;1640   				
;;;1641   				}
;;;1642   			}		
;;;1643   		}
;;;1644   
;;;1645   
;;;1646   		tick++;
0011da  1c60              ADDS     r0,r4,#1
0011dc  b2c4              UXTB     r4,r0
;;;1647   		delay_ms(10);
0011de  200a              MOVS     r0,#0xa
0011e0  f7fffffe          BL       delay_ms
;;;1648   
;;;1649   		if(SPI_2_Rx_sts==SPI_CMPLT)
0011e4  48eb              LDR      r0,|L1.5524|
0011e6  7800              LDRB     r0,[r0,#0]  ; SPI_2_Rx_sts
0011e8  2802              CMP      r0,#2
0011ea  d112              BNE      |L1.4626|
;;;1650   		{
;;;1651   			for(i=0;i<test_lenth;i++)
0011ec  f04f0b00          MOV      r11,#0
0011f0  e009              B        |L1.4614|
                  |L1.4594|
;;;1652   				u8buff[i]=SPI_2_RcvBuf[i];
0011f2  48e9              LDR      r0,|L1.5528|
0011f4  f810000b          LDRB     r0,[r0,r11]
0011f8  49e8              LDR      r1,|L1.5532|
0011fa  f801000b          STRB     r0,[r1,r11]
0011fe  f10b0001          ADD      r0,r11,#1             ;1651
001202  fa1ffb80          UXTH     r11,r0                ;1651
                  |L1.4614|
001206  9804              LDR      r0,[sp,#0x10]         ;1651
001208  4583              CMP      r11,r0                ;1651
00120a  dbf2              BLT      |L1.4594|
;;;1653   			SPI_2_Rx_sts=SPI_IDLE;
00120c  2000              MOVS     r0,#0
00120e  49e1              LDR      r1,|L1.5524|
001210  7008              STRB     r0,[r1,#0]
                  |L1.4626|
;;;1654   		}
;;;1655   		
;;;1656   	if(tick==5)
001212  2c05              CMP      r4,#5
001214  d151              BNE      |L1.4794|
;;;1657   		{
;;;1658          ldecoun++;
001216  9805              LDR      r0,[sp,#0x14]
001218  1c40              ADDS     r0,r0,#1
00121a  b2c0              UXTB     r0,r0
00121c  9005              STR      r0,[sp,#0x14]
;;;1659   			//LED0=!LED0;//提示系统正在运行	
;;;1660   		  	if(ldecoun==0)
00121e  9805              LDR      r0,[sp,#0x14]
001220  b938              CBNZ     r0,|L1.4658|
;;;1661   					LED0=!LED0;
001222  48df              LDR      r0,|L1.5536|
001224  6800              LDR      r0,[r0,#0]
001226  b908              CBNZ     r0,|L1.4652|
001228  2001              MOVS     r0,#1
00122a  e000              B        |L1.4654|
                  |L1.4652|
00122c  2000              MOVS     r0,#0
                  |L1.4654|
00122e  49dc              LDR      r1,|L1.5536|
001230  6008              STR      r0,[r1,#0]
                  |L1.4658|
;;;1662           if(ldecoun==1)
001232  9805              LDR      r0,[sp,#0x14]
001234  2801              CMP      r0,#1
001236  d109              BNE      |L1.4684|
;;;1663   					LED1=!LED1;
001238  48d9              LDR      r0,|L1.5536|
00123a  1d00              ADDS     r0,r0,#4
00123c  6800              LDR      r0,[r0,#0]
00123e  b908              CBNZ     r0,|L1.4676|
001240  2001              MOVS     r0,#1
001242  e000              B        |L1.4678|
                  |L1.4676|
001244  2000              MOVS     r0,#0
                  |L1.4678|
001246  49d6              LDR      r1,|L1.5536|
001248  1d09              ADDS     r1,r1,#4
00124a  6008              STR      r0,[r1,#0]
                  |L1.4684|
;;;1664           if(ldecoun==2)
00124c  9805              LDR      r0,[sp,#0x14]
00124e  2802              CMP      r0,#2
001250  d109              BNE      |L1.4710|
;;;1665   					LED2=!LED2;
001252  48d3              LDR      r0,|L1.5536|
001254  3008              ADDS     r0,r0,#8
001256  6800              LDR      r0,[r0,#0]
001258  b908              CBNZ     r0,|L1.4702|
00125a  2001              MOVS     r0,#1
00125c  e000              B        |L1.4704|
                  |L1.4702|
00125e  2000              MOVS     r0,#0
                  |L1.4704|
001260  49cf              LDR      r1,|L1.5536|
001262  3108              ADDS     r1,r1,#8
001264  6008              STR      r0,[r1,#0]
                  |L1.4710|
;;;1666          if(ldecoun==3)
001266  9805              LDR      r0,[sp,#0x14]
001268  2803              CMP      r0,#3
00126a  d109              BNE      |L1.4736|
;;;1667   			  LED3=!LED3;
00126c  48cc              LDR      r0,|L1.5536|
00126e  300c              ADDS     r0,r0,#0xc
001270  6800              LDR      r0,[r0,#0]
001272  b908              CBNZ     r0,|L1.4728|
001274  2001              MOVS     r0,#1
001276  e000              B        |L1.4730|
                  |L1.4728|
001278  2000              MOVS     r0,#0
                  |L1.4730|
00127a  49c9              LDR      r1,|L1.5536|
00127c  310c              ADDS     r1,r1,#0xc
00127e  6008              STR      r0,[r1,#0]
                  |L1.4736|
;;;1668          if(ldecoun==4)
001280  9805              LDR      r0,[sp,#0x14]
001282  2804              CMP      r0,#4
001284  d109              BNE      |L1.4762|
;;;1669   			  LED4=!LED4;
001286  48c6              LDR      r0,|L1.5536|
001288  3010              ADDS     r0,r0,#0x10
00128a  6800              LDR      r0,[r0,#0]
00128c  b908              CBNZ     r0,|L1.4754|
00128e  2001              MOVS     r0,#1
001290  e000              B        |L1.4756|
                  |L1.4754|
001292  2000              MOVS     r0,#0
                  |L1.4756|
001294  49c2              LDR      r1,|L1.5536|
001296  3110              ADDS     r1,r1,#0x10
001298  6008              STR      r0,[r1,#0]
                  |L1.4762|
;;;1670          if(ldecoun==5)
00129a  9805              LDR      r0,[sp,#0x14]
00129c  2805              CMP      r0,#5
00129e  d10b              BNE      |L1.4792|
;;;1671   			 { 
;;;1672   			   LED5=!LED5;
0012a0  48bf              LDR      r0,|L1.5536|
0012a2  3014              ADDS     r0,r0,#0x14
0012a4  6800              LDR      r0,[r0,#0]
0012a6  b908              CBNZ     r0,|L1.4780|
0012a8  2001              MOVS     r0,#1
0012aa  e000              B        |L1.4782|
                  |L1.4780|
0012ac  2000              MOVS     r0,#0
                  |L1.4782|
0012ae  49bc              LDR      r1,|L1.5536|
0012b0  3114              ADDS     r1,r1,#0x14
0012b2  6008              STR      r0,[r1,#0]
;;;1673   				 ldecoun=0;
0012b4  2000              MOVS     r0,#0
0012b6  9005              STR      r0,[sp,#0x14]
                  |L1.4792|
;;;1674   			 }
;;;1675    		 
;;;1676   			tick=0;
0012b8  2400              MOVS     r4,#0
                  |L1.4794|
0012ba  f7ffb869          B        |L1.912|
;;;1677   		}
;;;1678   			   	   
;;;1679   	}
;;;1680   }
;;;1681   
                          ENDP

                  UARTRes PROC
;;;1721   /*		function format the packet & cal checksum, send out  */
;;;1722   void UARTRes(u8 response, u8 command,u8 * buffer, u8 length)
0012be  e92d47f0          PUSH     {r4-r10,lr}
;;;1723   {
0012c2  4604              MOV      r4,r0
0012c4  460d              MOV      r5,r1
0012c6  4616              MOV      r6,r2
0012c8  461f              MOV      r7,r3
;;;1724   	u8 i, u8temp, len;
;;;1725   	buf[0]=HEADER;
0012ca  20aa              MOVS     r0,#0xaa
0012cc  49b5              LDR      r1,|L1.5540|
0012ce  7008              STRB     r0,[r1,#0]
;;;1726   	buf[1]=response;
0012d0  4608              MOV      r0,r1
0012d2  7044              STRB     r4,[r0,#1]
;;;1727   	buf[2]=command;
0012d4  7085              STRB     r5,[r0,#2]
;;;1728   	buf[3]=length;
0012d6  70c7              STRB     r7,[r0,#3]
;;;1729   	len=4;
0012d8  f04f0a04          MOV      r10,#4
;;;1730   	for(i=0;i<length;i++,len++)
0012dc  f04f0800          MOV      r8,#0
0012e0  e00c              B        |L1.4860|
                  |L1.4834|
;;;1731   			buf[len]=*(buffer+i);
0012e2  f8160008          LDRB     r0,[r6,r8]
0012e6  49af              LDR      r1,|L1.5540|
0012e8  f801000a          STRB     r0,[r1,r10]
0012ec  f1080001          ADD      r0,r8,#1              ;1730
0012f0  f00008ff          AND      r8,r0,#0xff           ;1730
0012f4  f10a0001          ADD      r0,r10,#1             ;1730
0012f8  f0000aff          AND      r10,r0,#0xff          ;1730
                  |L1.4860|
0012fc  45b8              CMP      r8,r7                 ;1730
0012fe  dbf0              BLT      |L1.4834|
;;;1732   	u8temp=0;
001300  f04f0900          MOV      r9,#0
;;;1733   	for(i=1;i<(len-1);i++)
001304  f04f0801          MOV      r8,#1
001308  e009              B        |L1.4894|
                  |L1.4874|
;;;1734   		u8temp+=buf[i];
00130a  48a6              LDR      r0,|L1.5540|
00130c  f8100008          LDRB     r0,[r0,r8]
001310  4448              ADD      r0,r0,r9
001312  f00009ff          AND      r9,r0,#0xff
001316  f1080001          ADD      r0,r8,#1              ;1733
00131a  f00008ff          AND      r8,r0,#0xff           ;1733
                  |L1.4894|
00131e  f1aa0001          SUB      r0,r10,#1             ;1733
001322  4540              CMP      r0,r8                 ;1733
001324  dcf1              BGT      |L1.4874|
;;;1735   	if(u8temp==TAIL)
001326  f1b90f17          CMP      r9,#0x17
00132a  d103              BNE      |L1.4916|
;;;1736   		u8temp++;
00132c  f1090001          ADD      r0,r9,#1
001330  f00009ff          AND      r9,r0,#0xff
                  |L1.4916|
;;;1737      	buf[len]=u8temp;
001334  489b              LDR      r0,|L1.5540|
001336  f800900a          STRB     r9,[r0,r10]
;;;1738   	buf[len+1]=buf[len+2]=TAIL;
00133a  2117              MOVS     r1,#0x17
00133c  4602              MOV      r2,r0
00133e  f10a0002          ADD      r0,r10,#2
001342  5411              STRB     r1,[r2,r0]
001344  1e40              SUBS     r0,r0,#1
001346  5411              STRB     r1,[r2,r0]
;;;1739   	buf[len+3]='\0';
001348  2100              MOVS     r1,#0
00134a  1c80              ADDS     r0,r0,#2
00134c  5411              STRB     r1,[r2,r0]
;;;1740   	{
;;;1741   		for(i=0;i<YG_FIX_LEN;i++)
00134e  4688              MOV      r8,r1
001350  e009              B        |L1.4966|
                  |L1.4946|
;;;1742   			putchar(buf[i]);		
001352  4994              LDR      r1,|L1.5540|
001354  f8110008          LDRB     r0,[r1,r8]
001358  4993              LDR      r1,|L1.5544|
00135a  f7fffffe          BL       putc
00135e  f1080001          ADD      r0,r8,#1              ;1741
001362  f00008ff          AND      r8,r0,#0xff           ;1741
                  |L1.4966|
001366  f1b80f40          CMP      r8,#0x40              ;1741
00136a  dbf2              BLT      |L1.4946|
;;;1743   	}
;;;1744   	
;;;1745   }
00136c  e8bd87f0          POP      {r4-r10,pc}
;;;1746   
                          ENDP

                  Print_packet PROC
;;;1681   
;;;1682   void Print_packet(u8 ResCode, u8 command, u8 *TxBuffer, u8 TransLen)
001370  e92d41f0          PUSH     {r4-r8,lr}
;;;1683   {
001374  4604              MOV      r4,r0
001376  460f              MOV      r7,r1
001378  4615              MOV      r5,r2
00137a  461e              MOV      r6,r3
;;;1684      if(USB_ReceiveFlg!=TRUE)
00137c  488b              LDR      r0,|L1.5548|
00137e  7800              LDRB     r0,[r0,#0]  ; USB_ReceiveFlg
001380  2801              CMP      r0,#1
001382  d006              BEQ      |L1.5010|
;;;1685   	   UARTRes(ResCode, CMD_READ, TxBuffer, TransLen);
001384  4633              MOV      r3,r6
001386  462a              MOV      r2,r5
001388  2104              MOVS     r1,#4
00138a  4620              MOV      r0,r4
00138c  f7fffffe          BL       UARTRes
001390  e008              B        |L1.5028|
                  |L1.5010|
;;;1686      else 
;;;1687      {
;;;1688      	   USBRes(ResCode, CMD_PID_CFG, TxBuffer, TransLen);
001392  4633              MOV      r3,r6
001394  462a              MOV      r2,r5
001396  2111              MOVS     r1,#0x11
001398  4620              MOV      r0,r4
00139a  f7fffffe          BL       USBRes
;;;1689   	   USB_ReceiveFlg = FALSE;
00139e  2000              MOVS     r0,#0
0013a0  4982              LDR      r1,|L1.5548|
0013a2  7008              STRB     r0,[r1,#0]
                  |L1.5028|
;;;1690   	}
;;;1691   }
0013a4  e8bd81f0          POP      {r4-r8,pc}
;;;1692   
                          ENDP

                  EXTI0_IRQHandler PROC
;;;1693   
;;;1694   void EXTI0_IRQHandler(void)
0013a8  2001              MOVS     r0,#1
;;;1695   
;;;1696   {
;;;1697   		    		    				     		    
;;;1698   	EXTI->PR=1;  //清除中断标志位	  
0013aa  4981              LDR      r1,|L1.5552|
0013ac  6008              STR      r0,[r1,#0]
;;;1699   	PCR_ADC_Done_Flag=1;
0013ae  4981              LDR      r1,|L1.5556|
0013b0  7008              STRB     r0,[r1,#0]
;;;1700   } 
0013b2  4770              BX       lr
;;;1701   
                          ENDP

                  ReadUpdate_Image24_slow PROC
;;;1831   
;;;1832   void ReadUpdate_Image24_slow(u8 mode, u8 row)
0013b4  e92d47f0          PUSH     {r4-r10,lr}
;;;1833   {
0013b8  4604              MOV      r4,r0
0013ba  460d              MOV      r5,r1
;;;1834    	u8 i,j,k,u8temp,txpattern,txset;
;;;1835   // 	u8 count;
;;;1836   	OSC_Ctrl=OSC_ON;
0013bc  2001              MOVS     r0,#1
0013be  4978              LDR      r1,|L1.5536|
0013c0  3910              SUBS     r1,r1,#0x10
0013c2  6008              STR      r0,[r1,#0]
;;;1837   	OSC_Status=1;
0013c4  497c              LDR      r1,|L1.5560|
0013c6  7008              STRB     r0,[r1,#0]
;;;1838   	delay_ms(10);
0013c8  200a              MOVS     r0,#0xa
0013ca  f7fffffe          BL       delay_ms
;;;1839   
;;;1840   	///////	add LED control
;;;1841   	           Time_LED_Delay=0;
0013ce  2000              MOVS     r0,#0
0013d0  497a              LDR      r1,|L1.5564|
0013d2  8008              STRH     r0,[r1,#0]
;;;1842   			   TIM7_Init();
0013d4  f7fffffe          BL       TIM7_Init
;;;1843   			   LED_CTRL=1;
0013d8  2001              MOVS     r0,#1
0013da  4979              LDR      r1,|L1.5568|
0013dc  f8c10194          STR      r0,[r1,#0x194]
;;;1844   			   while(Time_LED_Delay<SetTm_LED_Delay);
0013e0  bf00              NOP      
                  |L1.5090|
0013e2  4876              LDR      r0,|L1.5564|
0013e4  8800              LDRH     r0,[r0,#0]  ; Time_LED_Delay
0013e6  4977              LDR      r1,|L1.5572|
0013e8  8809              LDRH     r1,[r1,#0]  ; SetTm_LED_Delay
0013ea  4288              CMP      r0,r1
0013ec  dbf9              BLT      |L1.5090|
;;;1845   			   TIM7_Stop();
0013ee  f7fffffe          BL       TIM7_Stop
;;;1846   	////////LED control
;;;1847   
;;;1848   //    PCRChip_Command_Send[10]=PCR_Regs.SW_TxCtrl;  		
;;;1849   	for(txset=0;txset<4;txset++)
0013f2  f04f0900          MOV      r9,#0
0013f6  e133              B        |L1.5728|
                  |L1.5112|
;;;1850   	{
;;;1851   		txpattern =  PIXEL_24READ[txset];
0013f8  4873              LDR      r0,|L1.5576|
0013fa  f8108009          LDRB     r8,[r0,r9]
;;;1852   		PCRChip_Command_Send[9]=PCR_Regs.SW_TxCtrl=TX_PACK(txpattern,PCR_Regs.SW_TxCtrl);
0013fe  4873              LDR      r0,|L1.5580|
001400  7900              LDRB     r0,[r0,#4]  ; PCR_Regs
001402  f3680003          BFI      r0,r8,#0,#4
001406  4971              LDR      r1,|L1.5580|
001408  7108              STRB     r0,[r1,#4]
00140a  4971              LDR      r1,|L1.5584|
00140c  7248              STRB     r0,[r1,#9]
;;;1853   		Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[9]);
00140e  f1010309          ADD      r3,r1,#9
001412  2201              MOVS     r2,#1
001414  4611              MOV      r1,r2
001416  2002              MOVS     r0,#2
001418  f7fffffe          BL       Send_Command
;;;1854   
;;;1855   		for(j=0;j<PIX_TOTAL_ROW;j++)
00141c  2700              MOVS     r7,#0
00141e  e019              B        |L1.5204|
                  |L1.5152|
;;;1856   		{
;;;1857   			Read_Row(j);
001420  4638              MOV      r0,r7
001422  f7fffffe          BL       Read_Row
;;;1858   			ImageBuf[j][1]=j;
001426  ebc700c7          RSB      r0,r7,r7,LSL #3
00142a  496a              LDR      r1,|L1.5588|
00142c  eb010080          ADD      r0,r1,r0,LSL #2
001430  7047              STRB     r7,[r0,#1]
;;;1859   			for(i=0;i<(PIX_TOTAL_COL<<1);i++)
001432  2600              MOVS     r6,#0
001434  e00a              B        |L1.5196|
                  |L1.5174|
;;;1860   				ImageBuf[j][i+2]=SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
001436  4858              LDR      r0,|L1.5528|
001438  5d81              LDRB     r1,[r0,r6]
00143a  ebc700c7          RSB      r0,r7,r7,LSL #3
00143e  4a65              LDR      r2,|L1.5588|
001440  eb020280          ADD      r2,r2,r0,LSL #2
001444  1cb0              ADDS     r0,r6,#2
001446  5411              STRB     r1,[r2,r0]
001448  1c70              ADDS     r0,r6,#1              ;1859
00144a  b2c6              UXTB     r6,r0                 ;1859
                  |L1.5196|
00144c  2e1a              CMP      r6,#0x1a              ;1859
00144e  dbf2              BLT      |L1.5174|
001450  1c78              ADDS     r0,r7,#1              ;1855
001452  b2c7              UXTB     r7,r0                 ;1855
                  |L1.5204|
001454  2f0c              CMP      r7,#0xc               ;1855
001456  dbe3              BLT      |L1.5152|
;;;1861   		}
;;;1862   	
;;;1863   		switch(txset)
001458  f1b90f00          CMP      r9,#0
00145c  d009              BEQ      |L1.5234|
00145e  f1b90f01          CMP      r9,#1
001462  d033              BEQ      |L1.5324|
001464  f1b90f02          CMP      r9,#2
001468  d05d              BEQ      |L1.5414|
00146a  f1b90f03          CMP      r9,#3
00146e  d17e              BNE      |L1.5486|
001470  e0bd              B        |L1.5614|
                  |L1.5234|
;;;1864   		{
;;;1865   			case 0:
;;;1866   				for(j=0;j<PIX_TOTAL_ROW;j++)
001472  2700              MOVS     r7,#0
001474  e027              B        |L1.5318|
                  |L1.5238|
;;;1867   				{
;;;1868   			#ifndef PIX24_DEBUG_UART_PRINT
;;;1869   					for(i=0;i<(PIX_TOTAL_COL);i++)
001476  2600              MOVS     r6,#0
001478  e021              B        |L1.5310|
                  |L1.5242|
;;;1870   					{
;;;1871   						ImageBufPIX[(j<<1)][(i<<2)+4] =ImageBuf[j][(i<<1)+2];
00147a  ebc700c7          RSB      r0,r7,r7,LSL #3
00147e  4955              LDR      r1,|L1.5588|
001480  eb010080          ADD      r0,r1,r0,LSL #2
001484  2102              MOVS     r1,#2
001486  eb010146          ADD      r1,r1,r6,LSL #1
00148a  5c40              LDRB     r0,[r0,r1]
00148c  4a52              LDR      r2,|L1.5592|
00148e  eb0211c7          ADD      r1,r2,r7,LSL #7
001492  2204              MOVS     r2,#4
001494  eb020286          ADD      r2,r2,r6,LSL #2
001498  5488              STRB     r0,[r1,r2]
;;;1872   						ImageBufPIX[(j<<1)][(i<<2)+5] =ImageBuf[j][(i<<1)+3];
00149a  ebc700c7          RSB      r0,r7,r7,LSL #3
00149e  494d              LDR      r1,|L1.5588|
0014a0  eb010080          ADD      r0,r1,r0,LSL #2
0014a4  2103              MOVS     r1,#3
0014a6  eb010146          ADD      r1,r1,r6,LSL #1
0014aa  5c40              LDRB     r0,[r0,r1]
0014ac  4a4a              LDR      r2,|L1.5592|
0014ae  eb0211c7          ADD      r1,r2,r7,LSL #7
0014b2  2205              MOVS     r2,#5
0014b4  eb020286          ADD      r2,r2,r6,LSL #2
0014b8  5488              STRB     r0,[r1,r2]
0014ba  1c70              ADDS     r0,r6,#1              ;1869
0014bc  b2c6              UXTB     r6,r0                 ;1869
                  |L1.5310|
0014be  2e0d              CMP      r6,#0xd               ;1869
0014c0  dbdb              BLT      |L1.5242|
0014c2  1c78              ADDS     r0,r7,#1              ;1866
0014c4  b2c7              UXTB     r7,r0                 ;1866
                  |L1.5318|
0014c6  2f0c              CMP      r7,#0xc               ;1866
0014c8  dbd5              BLT      |L1.5238|
;;;1873   					}
;;;1874   			#else
;;;1875   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;1876   					{
;;;1877   						ImageBufPIX[(j<<1)][i+4] =i+4;
;;;1878   						ImageBufPIX[(j<<1)][i+5] =i+5;
;;;1879   					}
;;;1880   			#endif	
;;;1881   				}	
;;;1882   			break;
0014ca  e0c4              B        |L1.5718|
                  |L1.5324|
;;;1883   
;;;1884   			case 1:
;;;1885   				for(j=0;j<PIX_TOTAL_ROW;j++)
0014cc  2700              MOVS     r7,#0
0014ce  e027              B        |L1.5408|
                  |L1.5328|
;;;1886   				{
;;;1887   			#ifndef PIX24_DEBUG_UART_PRINT
;;;1888   					for(i=0;i<(PIX_TOTAL_COL);i++)
0014d0  2600              MOVS     r6,#0
0014d2  e021              B        |L1.5400|
                  |L1.5332|
;;;1889   					{
;;;1890   						ImageBufPIX[(j<<1)][(i<<2)+2] =ImageBuf[j][(i<<1)+2];
0014d4  ebc700c7          RSB      r0,r7,r7,LSL #3
0014d8  493e              LDR      r1,|L1.5588|
0014da  eb010080          ADD      r0,r1,r0,LSL #2
0014de  2102              MOVS     r1,#2
0014e0  eb010146          ADD      r1,r1,r6,LSL #1
0014e4  5c40              LDRB     r0,[r0,r1]
0014e6  4a3c              LDR      r2,|L1.5592|
0014e8  eb0211c7          ADD      r1,r2,r7,LSL #7
0014ec  2202              MOVS     r2,#2
0014ee  eb020286          ADD      r2,r2,r6,LSL #2
0014f2  5488              STRB     r0,[r1,r2]
;;;1891   						ImageBufPIX[(j<<1)][(i<<2)+3] =ImageBuf[j][(i<<1)+3];
0014f4  ebc700c7          RSB      r0,r7,r7,LSL #3
0014f8  4936              LDR      r1,|L1.5588|
0014fa  eb010080          ADD      r0,r1,r0,LSL #2
0014fe  2103              MOVS     r1,#3
001500  eb010146          ADD      r1,r1,r6,LSL #1
001504  5c40              LDRB     r0,[r0,r1]
001506  4a34              LDR      r2,|L1.5592|
001508  eb0211c7          ADD      r1,r2,r7,LSL #7
00150c  2203              MOVS     r2,#3
00150e  eb020286          ADD      r2,r2,r6,LSL #2
001512  5488              STRB     r0,[r1,r2]
001514  1c70              ADDS     r0,r6,#1              ;1888
001516  b2c6              UXTB     r6,r0                 ;1888
                  |L1.5400|
001518  2e0d              CMP      r6,#0xd               ;1888
00151a  dbdb              BLT      |L1.5332|
00151c  1c78              ADDS     r0,r7,#1              ;1885
00151e  b2c7              UXTB     r7,r0                 ;1885
                  |L1.5408|
001520  2f0c              CMP      r7,#0xc               ;1885
001522  dbd5              BLT      |L1.5328|
;;;1892   					}	
;;;1893   			#else
;;;1894   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;1895   					{
;;;1896   						ImageBufPIX[(j<<1)][i+2] =i+2;
;;;1897   						ImageBufPIX[(j<<1)][i+3] =i+3;
;;;1898   					}
;;;1899   			#endif	
;;;1900   				}	
;;;1901   			break;
001524  e097              B        |L1.5718|
                  |L1.5414|
;;;1902   
;;;1903   			case 2:
;;;1904   				for(j=0;j<PIX_TOTAL_ROW;j++)
001526  2700              MOVS     r7,#0
001528  e05e              B        |L1.5608|
                  |L1.5418|
;;;1905   				{
;;;1906   				#ifndef PIX24_DEBUG_UART_PRINT
;;;1907   					for(i=0;i<(PIX_TOTAL_COL);i++)
00152a  2600              MOVS     r6,#0
00152c  e058              B        |L1.5600|
                  |L1.5422|
;;;1908   					{
;;;1909   						ImageBufPIX[(j<<1)+1][(i<<2)+4] =ImageBuf[j][(i<<1)+2];
00152e  ebc700c7          RSB      r0,r7,r7,LSL #3
001532  4928              LDR      r1,|L1.5588|
001534  eb010080          ADD      r0,r1,r0,LSL #2
001538  2102              MOVS     r1,#2
00153a  eb010146          ADD      r1,r1,r6,LSL #1
00153e  5c40              LDRB     r0,[r0,r1]
001540  2101              MOVS     r1,#1
001542  eb010147          ADD      r1,r1,r7,LSL #1
001546  4a24              LDR      r2,|L1.5592|
001548  eb021181          ADD      r1,r2,r1,LSL #6
00154c  2204              MOVS     r2,#4
00154e  eb020286          ADD      r2,r2,r6,LSL #2
001552  5488              STRB     r0,[r1,r2]
;;;1910   						ImageBufPIX[(j<<1)+1][(i<<2)+5] =ImageBuf[j][(i<<1)+3];
001554  ebc700c7          RSB      r0,r7,r7,LSL #3
001558  491e              LDR      r1,|L1.5588|
00155a  eb010080          ADD      r0,r1,r0,LSL #2
00155e  2103              MOVS     r1,#3
001560  eb010146          ADD      r1,r1,r6,LSL #1
001564  5c40              LDRB     r0,[r0,r1]
001566  2101              MOVS     r1,#1
001568  eb010147          ADD      r1,r1,r7,LSL #1
00156c  e000              B        |L1.5488|
                  |L1.5486|
00156e  e071              B        |L1.5716|
                  |L1.5488|
001570  4a19              LDR      r2,|L1.5592|
001572  eb021181          ADD      r1,r2,r1,LSL #6
001576  2205              MOVS     r2,#5
001578  eb020286          ADD      r2,r2,r6,LSL #2
00157c  5488              STRB     r0,[r1,r2]
00157e  e02d              B        |L1.5596|
                  |L1.5504|
                          DCD      0x40012c34
                  |L1.5508|
                          DCD      TempCtrl_Active
                  |L1.5512|
                          DCD      TempCtrl_Active_2
                  |L1.5516|
                          DCD      TxBuffer
                  |L1.5520|
                          DCD      0x4000083c
                  |L1.5524|
                          DCD      SPI_2_Rx_sts
                  |L1.5528|
                          DCD      SPI_2_RcvBuf
                  |L1.5532|
                          DCD      u8buff
                  |L1.5536|
                          DCD      0x422401a8
                  |L1.5540|
                          DCD      buf
                  |L1.5544|
                          DCD      __stdout
                  |L1.5548|
                          DCD      USB_ReceiveFlg
                  |L1.5552|
                          DCD      0x40010414
                  |L1.5556|
                          DCD      PCR_ADC_Done_Flag
                  |L1.5560|
                          DCD      OSC_Status
                  |L1.5564|
                          DCD      Time_LED_Delay
                  |L1.5568|
                          DCD      0x42238000
                  |L1.5572|
                          DCD      SetTm_LED_Delay
                  |L1.5576|
                          DCD      PIXEL_24READ
                  |L1.5580|
                          DCD      PCR_Regs
                  |L1.5584|
                          DCD      PCRChip_Command_Send
                  |L1.5588|
                          DCD      ImageBuf
                  |L1.5592|
                          DCD      ImageBufPIX
                  |L1.5596|
0015dc  1c70              ADDS     r0,r6,#1              ;1907
0015de  b2c6              UXTB     r6,r0                 ;1907
                  |L1.5600|
0015e0  2e0d              CMP      r6,#0xd               ;1907
0015e2  dba4              BLT      |L1.5422|
0015e4  1c78              ADDS     r0,r7,#1              ;1904
0015e6  b2c7              UXTB     r7,r0                 ;1904
                  |L1.5608|
0015e8  2f0c              CMP      r7,#0xc               ;1904
0015ea  db9e              BLT      |L1.5418|
;;;1911   					}
;;;1912   				#else
;;;1913   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;1914   					{
;;;1915   						ImageBufPIX[(j<<1)+1][i+4] =i+4+0x80;
;;;1916   						ImageBufPIX[(j<<1)+1][i+5] =i+5+0x80;
;;;1917   					}
;;;1918   				#endif	
;;;1919   				}	
;;;1920   			break;
0015ec  e033              B        |L1.5718|
                  |L1.5614|
;;;1921   
;;;1922   			case 3:
;;;1923   				for(j=0;j<PIX_TOTAL_ROW;j++)
0015ee  2700              MOVS     r7,#0
0015f0  e02d              B        |L1.5710|
                  |L1.5618|
;;;1924   				{
;;;1925   				#ifndef PIX24_DEBUG_UART_PRINT
;;;1926   					for(i=0;i<(PIX_TOTAL_COL);i++)
0015f2  2600              MOVS     r6,#0
0015f4  e027              B        |L1.5702|
                  |L1.5622|
;;;1927   					{
;;;1928   						ImageBufPIX[(j<<1)+1][(i<<2)+2] =ImageBuf[j][(i<<1)+2];
0015f6  ebc700c7          RSB      r0,r7,r7,LSL #3
0015fa  49ff              LDR      r1,|L1.6648|
0015fc  eb010080          ADD      r0,r1,r0,LSL #2
001600  2102              MOVS     r1,#2
001602  eb010146          ADD      r1,r1,r6,LSL #1
001606  5c40              LDRB     r0,[r0,r1]
001608  2101              MOVS     r1,#1
00160a  eb010147          ADD      r1,r1,r7,LSL #1
00160e  4afb              LDR      r2,|L1.6652|
001610  eb021181          ADD      r1,r2,r1,LSL #6
001614  2202              MOVS     r2,#2
001616  eb020286          ADD      r2,r2,r6,LSL #2
00161a  5488              STRB     r0,[r1,r2]
;;;1929   						ImageBufPIX[(j<<1)+1][(i<<2)+3] =ImageBuf[j][(i<<1)+3];
00161c  ebc700c7          RSB      r0,r7,r7,LSL #3
001620  49f5              LDR      r1,|L1.6648|
001622  eb010080          ADD      r0,r1,r0,LSL #2
001626  2103              MOVS     r1,#3
001628  eb010146          ADD      r1,r1,r6,LSL #1
00162c  5c40              LDRB     r0,[r0,r1]
00162e  2101              MOVS     r1,#1
001630  eb010147          ADD      r1,r1,r7,LSL #1
001634  4af1              LDR      r2,|L1.6652|
001636  eb021181          ADD      r1,r2,r1,LSL #6
00163a  2203              MOVS     r2,#3
00163c  eb020286          ADD      r2,r2,r6,LSL #2
001640  5488              STRB     r0,[r1,r2]
001642  1c70              ADDS     r0,r6,#1              ;1926
001644  b2c6              UXTB     r6,r0                 ;1926
                  |L1.5702|
001646  2e0d              CMP      r6,#0xd               ;1926
001648  dbd5              BLT      |L1.5622|
00164a  1c78              ADDS     r0,r7,#1              ;1923
00164c  b2c7              UXTB     r7,r0                 ;1923
                  |L1.5710|
00164e  2f0c              CMP      r7,#0xc               ;1923
001650  dbcf              BLT      |L1.5618|
;;;1930   					}
;;;1931   				#else
;;;1932   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;1933   					{
;;;1934   						ImageBufPIX[(j<<1)+1][i+2] =i+2+0x80;
;;;1935   						ImageBufPIX[(j<<1)+1][i+3] =i+3+0x80;
;;;1936   					}
;;;1937   				#endif	
;;;1938   				}	
;;;1939   			break;
001652  e000              B        |L1.5718|
                  |L1.5716|
;;;1940   		
;;;1941   			default:
;;;1942   			break;
001654  bf00              NOP      
                  |L1.5718|
001656  bf00              NOP                            ;1882
001658  f1090001          ADD      r0,r9,#1              ;1849
00165c  f00009ff          AND      r9,r0,#0xff           ;1849
                  |L1.5728|
001660  f1b90f04          CMP      r9,#4                 ;1849
001664  f6ffaec8          BLT      |L1.5112|
;;;1943   		}
;;;1944   	}
;;;1945   /*
;;;1946   	PCR_Regs.SW_TxCtrl=	PCRChip_Command_Send[10];
;;;1947   	Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[10]);	
;;;1948   */
;;;1949   
;;;1950   	///////	add LED control
;;;1951   			   LED_CTRL=(0x1 & led_mode);
001668  48e5              LDR      r0,|L1.6656|
00166a  7800              LDRB     r0,[r0,#0]  ; led_mode
00166c  f0000001          AND      r0,r0,#1
001670  49e4              LDR      r1,|L1.6660|
001672  6008              STR      r0,[r1,#0]
;;;1952   	////////LED control
;;;1953   
;;;1954   
;;;1955   	if(OSC_mode != OSC_ON)
001674  48e4              LDR      r0,|L1.6664|
001676  7800              LDRB     r0,[r0,#0]  ; OSC_mode
001678  2801              CMP      r0,#1
00167a  d004              BEQ      |L1.5766|
;;;1956   	{
;;;1957   		OSC_Ctrl=OSC_OFF;
00167c  2000              MOVS     r0,#0
00167e  49e3              LDR      r1,|L1.6668|
001680  6008              STR      r0,[r1,#0]
;;;1958   		OSC_Status=0;
001682  49e3              LDR      r1,|L1.6672|
001684  7008              STRB     r0,[r1,#0]
                  |L1.5766|
;;;1959   	}
;;;1960   
;;;1961   
;;;1962   	if(mode == TYP_24PIXIMAG)
001686  2c08              CMP      r4,#8
001688  d123              BNE      |L1.5842|
;;;1963   	{			
;;;1964   		for(i=0;i<24;i++)
00168a  2600              MOVS     r6,#0
00168c  e00a              B        |L1.5796|
                  |L1.5774|
;;;1965   		{	 ImageBufPIX[i][0]=TYP_24PIXIMAG;
00168e  2008              MOVS     r0,#8
001690  49da              LDR      r1,|L1.6652|
001692  eb011186          ADD      r1,r1,r6,LSL #6
001696  7008              STRB     r0,[r1,#0]
;;;1966   			 ImageBufPIX[i][1] = i;
001698  48d8              LDR      r0,|L1.6652|
00169a  eb001086          ADD      r0,r0,r6,LSL #6
00169e  7046              STRB     r6,[r0,#1]
0016a0  1c70              ADDS     r0,r6,#1              ;1964
0016a2  b2c6              UXTB     r6,r0                 ;1964
                  |L1.5796|
0016a4  2e18              CMP      r6,#0x18              ;1964
0016a6  dbf2              BLT      |L1.5774|
;;;1967   		}
;;;1968   
;;;1969   		for(i=0;i<24;i++)
0016a8  2600              MOVS     r6,#0
0016aa  e00f              B        |L1.5836|
                  |L1.5804|
;;;1970   		{
;;;1971   //#ifndef PIX24_DEBUG_UART_PRINT
;;;1972   			 USBRes(NO_ERR, CMD_GET, &ImageBufPIX[i][0], 52);
0016ac  48d3              LDR      r0,|L1.6652|
0016ae  eb001286          ADD      r2,r0,r6,LSL #6
0016b2  2334              MOVS     r3,#0x34
0016b4  2102              MOVS     r1,#2
0016b6  2000              MOVS     r0,#0
0016b8  f7fffffe          BL       USBRes
;;;1973   //#else
;;;1974   //			 UARTRes(NO_ERR, CMD_GET, &ImageBufPIX[i][0], 52);
;;;1975   //#endif
;;;1976   			#if !defined(USB_WAIT_MODE)
;;;1977   			delay_ms(35);
;;;1978   			#else
;;;1979   			EpMsgEnable();
0016bc  f7fffffe          BL       EpMsgEnable
;;;1980   			UsbReadDone();
0016c0  f7fffffe          BL       UsbReadDone
;;;1981   			EpMsgDisable();
0016c4  f7fffffe          BL       EpMsgDisable
0016c8  1c70              ADDS     r0,r6,#1              ;1969
0016ca  b2c6              UXTB     r6,r0                 ;1969
                  |L1.5836|
0016cc  2e18              CMP      r6,#0x18              ;1969
0016ce  dbed              BLT      |L1.5804|
0016d0  e018              B        |L1.5892|
                  |L1.5842|
;;;1982   			#endif	 
;;;1983   		}
;;;1984   	 }
;;;1985   	 else if(mode == TYP_24PIXROW)
0016d2  2c07              CMP      r4,#7
0016d4  d116              BNE      |L1.5892|
;;;1986   	 {
;;;1987   		 ImageBufPIX[row][0] =  TYP_24PIXROW;
0016d6  2007              MOVS     r0,#7
0016d8  49c8              LDR      r1,|L1.6652|
0016da  eb011185          ADD      r1,r1,r5,LSL #6
0016de  7008              STRB     r0,[r1,#0]
;;;1988   		 ImageBufPIX[row][1] =  row ;
0016e0  48c6              LDR      r0,|L1.6652|
0016e2  eb001085          ADD      r0,r0,r5,LSL #6
0016e6  7045              STRB     r5,[r0,#1]
;;;1989   //#ifndef PIX24_DEBUG_UART_PRINT
;;;1990   		 USBRes(NO_ERR, CMD_GET, &ImageBufPIX[row][0], 52);	
0016e8  48c4              LDR      r0,|L1.6652|
0016ea  eb001285          ADD      r2,r0,r5,LSL #6
0016ee  2334              MOVS     r3,#0x34
0016f0  2102              MOVS     r1,#2
0016f2  2000              MOVS     r0,#0
0016f4  f7fffffe          BL       USBRes
;;;1991   //#else
;;;1992   		// UARTRes(NO_ERR, CMD_GET, &ImageBufPIX[row][0], 52);
;;;1993   //#endif
;;;1994   			#if !defined(USB_WAIT_MODE)
;;;1995   			delay_ms(35);
;;;1996   			#else
;;;1997   			EpMsgEnable();
0016f8  f7fffffe          BL       EpMsgEnable
;;;1998   			UsbReadDone();
0016fc  f7fffffe          BL       UsbReadDone
;;;1999   			EpMsgDisable();
001700  f7fffffe          BL       EpMsgDisable
                  |L1.5892|
;;;2000   			#endif	 		  	
;;;2001   	 }
;;;2002   }
001704  e8bd87f0          POP      {r4-r10,pc}
;;;2003   
                          ENDP

                  ReadUpdate_Image24_XC PROC
;;;2005   
;;;2006   void ReadUpdate_Image24_XC(u8 mode, u8 row)	  //24pixel 图片
001708  e92d47f0          PUSH     {r4-r10,lr}
;;;2007   {
00170c  4604              MOV      r4,r0
00170e  460d              MOV      r5,r1
;;;2008    	u8 i,j,k,u8temp,txpattern,txset;
;;;2009   // 	u8 count;
;;;2010   	OSC_Ctrl=OSC_ON;
001710  2001              MOVS     r0,#1
001712  49be              LDR      r1,|L1.6668|
001714  6008              STR      r0,[r1,#0]
;;;2011   	OSC_Status=1;
001716  49be              LDR      r1,|L1.6672|
001718  7008              STRB     r0,[r1,#0]
;;;2012   	delay_ms(10);
00171a  200a              MOVS     r0,#0xa
00171c  f7fffffe          BL       delay_ms
;;;2013   
;;;2014    	PCRChip_Command_Send[0]=0xC3;
001720  20c3              MOVS     r0,#0xc3
001722  49bc              LDR      r1,|L1.6676|
001724  7008              STRB     r0,[r1,#0]
;;;2015   	PCRChip_Command_Send[1]=0x00;
001726  2000              MOVS     r0,#0
001728  7048              STRB     r0,[r1,#1]
;;;2016   	PCRChip_Command_Send[2]=0xA1;
00172a  20a1              MOVS     r0,#0xa1
00172c  7088              STRB     r0,[r1,#2]
;;;2017   	PCRChip_Command_Send[3]=0xB5;
00172e  20b5              MOVS     r0,#0xb5
001730  70c8              STRB     r0,[r1,#3]
;;;2018   	PCRChip_Command_Send[4]=0x21;
001732  2021              MOVS     r0,#0x21
001734  7108              STRB     r0,[r1,#4]
;;;2019   	PCRChip_Command_Send[5]=0x61;
001736  2061              MOVS     r0,#0x61
001738  7148              STRB     r0,[r1,#5]
;;;2020   
;;;2021   	PCRChip_Command_Send[6]=0x29; 
00173a  2029              MOVS     r0,#0x29
00173c  7188              STRB     r0,[r1,#6]
;;;2022   	PCRChip_Command_Send[7]=0x21; 
00173e  2021              MOVS     r0,#0x21
001740  71c8              STRB     r0,[r1,#7]
;;;2023   	PCRChip_Command_Send[8]=0x00; 
001742  2000              MOVS     r0,#0
001744  7208              STRB     r0,[r1,#8]
;;;2024   	PCRChip_Command_Send[9]=0x00; 
001746  7248              STRB     r0,[r1,#9]
;;;2025   
;;;2026   //	PCRChip_Command_Send[10]=PCR_Regs.SW_TxCtrl;
;;;2027    	
;;;2028   	///////	add LED control
;;;2029   			   Time_LED_Delay=0;
001748  49b3              LDR      r1,|L1.6680|
00174a  8008              STRH     r0,[r1,#0]
;;;2030   			   TIM7_Init();
00174c  f7fffffe          BL       TIM7_Init
;;;2031   			   LED_CTRL=1;
001750  2001              MOVS     r0,#1
001752  49b2              LDR      r1,|L1.6684|
001754  f8c10194          STR      r0,[r1,#0x194]
;;;2032   			   
;;;2033   			   while(Time_LED_Delay<SetTm_LED_Delay);
001758  bf00              NOP      
                  |L1.5978|
00175a  48af              LDR      r0,|L1.6680|
00175c  8800              LDRH     r0,[r0,#0]  ; Time_LED_Delay
00175e  49b0              LDR      r1,|L1.6688|
001760  8809              LDRH     r1,[r1,#0]  ; SetTm_LED_Delay
001762  4288              CMP      r0,r1
001764  dbf9              BLT      |L1.5978|
;;;2034   			   TIM7_Stop();
001766  f7fffffe          BL       TIM7_Stop
;;;2035   	////////LED control
;;;2036   			
;;;2037   	for(txset=0;txset<4;txset++)
00176a  f04f0900          MOV      r9,#0
00176e  e17f              B        |L1.6768|
                  |L1.6000|
;;;2038   	{
;;;2039   		txpattern =  PIXEL_24READ[txset];
001770  48ac              LDR      r0,|L1.6692|
001772  f8108009          LDRB     r8,[r0,r9]
;;;2040   		PCRChip_Command_Send[9]=PCR_Regs.SW_TxCtrl=TX_PACK(txpattern,PCR_Regs.SW_TxCtrl);
001776  48ac              LDR      r0,|L1.6696|
001778  7900              LDRB     r0,[r0,#4]  ; PCR_Regs
00177a  f3680003          BFI      r0,r8,#0,#4
00177e  49aa              LDR      r1,|L1.6696|
001780  7108              STRB     r0,[r1,#4]
001782  49a4              LDR      r1,|L1.6676|
001784  7248              STRB     r0,[r1,#9]
;;;2041   		Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[9]);
001786  f1010309          ADD      r3,r1,#9
00178a  2201              MOVS     r2,#1
00178c  4611              MOV      r1,r2
00178e  2002              MOVS     r0,#2
001790  f7fffffe          BL       Send_Command
;;;2042   
;;;2043   //		LED1=0; 
;;;2044   		for(j=0;j<PIX_TOTAL_ROW;j++)
001794  2700              MOVS     r7,#0
001796  e007              B        |L1.6056|
                  |L1.6040|
;;;2045   	        Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[0]);  //all row reset &start integration
001798  4b9e              LDR      r3,|L1.6676|
00179a  2201              MOVS     r2,#1
00179c  4639              MOV      r1,r7
00179e  2003              MOVS     r0,#3
0017a0  f7fffffe          BL       Send_Command
0017a4  1c78              ADDS     r0,r7,#1              ;2044
0017a6  b2c7              UXTB     r7,r0                 ;2044
                  |L1.6056|
0017a8  2f0c              CMP      r7,#0xc               ;2044
0017aa  dbf5              BLT      |L1.6040|
;;;2046   		for(j=0;j<PIX_TOTAL_ROW;j++)
0017ac  2700              MOVS     r7,#0
0017ae  e020              B        |L1.6130|
                  |L1.6064|
;;;2047   		{
;;;2048   			Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[1]);  // all row reset & start integration
0017b0  4b98              LDR      r3,|L1.6676|
0017b2  1c5b              ADDS     r3,r3,#1
0017b4  2201              MOVS     r2,#1
0017b6  4639              MOV      r1,r7
0017b8  2003              MOVS     r0,#3
0017ba  f7fffffe          BL       Send_Command
;;;2049   	        if(j==0)
0017be  b997              CBNZ     r7,|L1.6118|
;;;2050   			{
;;;2051   				TIM3_ARR_Update(PCR_Regs.InteCount);
0017c0  4999              LDR      r1,|L1.6696|
0017c2  8948              LDRH     r0,[r1,#0xa]  ; PCR_Regs
0017c4  f7fffffe          BL       TIM3_ARR_Update
;;;2052   				BaseCounter= PCR_Regs.InteTime;
0017c8  4897              LDR      r0,|L1.6696|
0017ca  8900              LDRH     r0,[r0,#8]  ; PCR_Regs
0017cc  4997              LDR      r1,|L1.6700|
0017ce  8008              STRH     r0,[r1,#0]
;;;2053   				TIM3->CR1|=0x01; 
0017d0  4897              LDR      r0,|L1.6704|
0017d2  8800              LDRH     r0,[r0,#0]
0017d4  f0400001          ORR      r0,r0,#1
0017d8  f04f4180          MOV      r1,#0x40000000
0017dc  f8a10400          STRH     r0,[r1,#0x400]
;;;2054   				TMR_Int_Flag=0;
0017e0  2000              MOVS     r0,#0
0017e2  4994              LDR      r1,|L1.6708|
0017e4  8008              STRH     r0,[r1,#0]
                  |L1.6118|
;;;2055   //		LED1=1;
;;;2056   			}
;;;2057   			delay_us(INTERVAL_DELAY_US) ;	
0017e6  f44f7016          MOV      r0,#0x258
0017ea  f7fffffe          BL       delay_us
0017ee  1c78              ADDS     r0,r7,#1              ;2046
0017f0  b2c7              UXTB     r7,r0                 ;2046
                  |L1.6130|
0017f2  2f0c              CMP      r7,#0xc               ;2046
0017f4  dbdc              BLT      |L1.6064|
;;;2058   		}
;;;2059   		for(j=0;j<PIX_TOTAL_ROW;j++)
0017f6  2700              MOVS     r7,#0
0017f8  e03e              B        |L1.6264|
                  |L1.6138|
;;;2060   		{
;;;2061   				 	
;;;2062   			while((TMR_Int_Flag & (1<<j))==0);
0017fa  bf00              NOP      
                  |L1.6140|
0017fc  2001              MOVS     r0,#1
0017fe  40b8              LSLS     r0,r0,r7
001800  498c              LDR      r1,|L1.6708|
001802  8809              LDRH     r1,[r1,#0]  ; TMR_Int_Flag
001804  4208              TST      r0,r1
001806  d0f9              BEQ      |L1.6140|
;;;2063   //       LED1=0;                             
;;;2064   			for(i=2;i<PXL_PHASE;i++)
001808  2602              MOVS     r6,#2
00180a  e008              B        |L1.6174|
                  |L1.6156|
;;;2065   				Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[i]);
00180c  4881              LDR      r0,|L1.6676|
00180e  1983              ADDS     r3,r0,r6
001810  2201              MOVS     r2,#1
001812  4639              MOV      r1,r7
001814  2003              MOVS     r0,#3
001816  f7fffffe          BL       Send_Command
00181a  1c70              ADDS     r0,r6,#1              ;2064
00181c  b2c6              UXTB     r6,r0                 ;2064
                  |L1.6174|
00181e  2e09              CMP      r6,#9                 ;2064
001820  dbf4              BLT      |L1.6156|
;;;2066   
;;;2067   			Send_Command(ADC_START, j, 0, &PCRChip_Command_Send[0]); // ADC process
001822  4b7c              LDR      r3,|L1.6676|
001824  2200              MOVS     r2,#0
001826  4639              MOV      r1,r7
001828  2004              MOVS     r0,#4
00182a  f7fffffe          BL       Send_Command
;;;2068   			PCR_ADC_Done_Flag=0;
00182e  2000              MOVS     r0,#0
001830  4981              LDR      r1,|L1.6712|
001832  7008              STRB     r0,[r1,#0]
;;;2069   #ifndef PIX24_DEBUG_UART_PRINT
;;;2070   			while(PCR_ADC_Done_Flag==0); // wait for ADC conversion done
001834  bf00              NOP      
                  |L1.6198|
001836  4880              LDR      r0,|L1.6712|
001838  7800              LDRB     r0,[r0,#0]  ; PCR_ADC_Done_Flag
00183a  2800              CMP      r0,#0
00183c  d0fb              BEQ      |L1.6198|
;;;2071   #endif
;;;2072   			Send_Command(PCR_ADC_READ, j, 0, &PCRChip_Command_Send[0]);	
00183e  4b75              LDR      r3,|L1.6676|
001840  2200              MOVS     r2,#0
001842  4639              MOV      r1,r7
001844  2005              MOVS     r0,#5
001846  f7fffffe          BL       Send_Command
;;;2073   //		LED1=!LED1;
;;;2074   			ImageBuf[j][1]=j;
00184a  ebc700c7          RSB      r0,r7,r7,LSL #3
00184e  496a              LDR      r1,|L1.6648|
001850  eb010080          ADD      r0,r1,r0,LSL #2
001854  7047              STRB     r7,[r0,#1]
;;;2075   			for(i=0;i<(PIX_TOTAL_COL<<1);i++)
001856  2600              MOVS     r6,#0
001858  e00a              B        |L1.6256|
                  |L1.6234|
;;;2076   			{
;;;2077   				ImageBuf[j][i+2]=SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
00185a  4878              LDR      r0,|L1.6716|
00185c  5d81              LDRB     r1,[r0,r6]
00185e  ebc700c7          RSB      r0,r7,r7,LSL #3
001862  4a65              LDR      r2,|L1.6648|
001864  eb020280          ADD      r2,r2,r0,LSL #2
001868  1cb0              ADDS     r0,r6,#2
00186a  5411              STRB     r1,[r2,r0]
00186c  1c70              ADDS     r0,r6,#1              ;2075
00186e  b2c6              UXTB     r6,r0                 ;2075
                  |L1.6256|
001870  2e1a              CMP      r6,#0x1a              ;2075
001872  dbf2              BLT      |L1.6234|
001874  1c78              ADDS     r0,r7,#1              ;2059
001876  b2c7              UXTB     r7,r0                 ;2059
                  |L1.6264|
001878  2f0c              CMP      r7,#0xc               ;2059
00187a  dbbe              BLT      |L1.6138|
;;;2078   			}
;;;2079   		
;;;2080   		}	
;;;2081   		switch(txset)
00187c  f1b90f00          CMP      r9,#0
001880  d009              BEQ      |L1.6294|
001882  f1b90f01          CMP      r9,#1
001886  d033              BEQ      |L1.6384|
001888  f1b90f02          CMP      r9,#2
00188c  d05d              BEQ      |L1.6474|
00188e  f1b90f03          CMP      r9,#3
001892  d17e              BNE      |L1.6546|
001894  e08e              B        |L1.6580|
                  |L1.6294|
;;;2082   		{
;;;2083   			case 0:
;;;2084   				for(j=0;j<PIX_TOTAL_ROW;j++)
001896  2700              MOVS     r7,#0
001898  e027              B        |L1.6378|
                  |L1.6298|
;;;2085   				{
;;;2086   			#ifndef PIX24_DEBUG_UART_PRINT
;;;2087   					for(i=0;i<(PIX_TOTAL_COL);i++)
00189a  2600              MOVS     r6,#0
00189c  e021              B        |L1.6370|
                  |L1.6302|
;;;2088   					{
;;;2089   						ImageBufPIX[(j<<1)][(i<<2)+4] =ImageBuf[j][(i<<1)+2];
00189e  ebc700c7          RSB      r0,r7,r7,LSL #3
0018a2  4955              LDR      r1,|L1.6648|
0018a4  eb010080          ADD      r0,r1,r0,LSL #2
0018a8  2102              MOVS     r1,#2
0018aa  eb010146          ADD      r1,r1,r6,LSL #1
0018ae  5c41              LDRB     r1,[r0,r1]
0018b0  4a52              LDR      r2,|L1.6652|
0018b2  eb0210c7          ADD      r0,r2,r7,LSL #7
0018b6  2204              MOVS     r2,#4
0018b8  eb020286          ADD      r2,r2,r6,LSL #2
0018bc  5481              STRB     r1,[r0,r2]
;;;2090   						ImageBufPIX[(j<<1)][(i<<2)+5] =ImageBuf[j][(i<<1)+3];
0018be  ebc700c7          RSB      r0,r7,r7,LSL #3
0018c2  494d              LDR      r1,|L1.6648|
0018c4  eb010080          ADD      r0,r1,r0,LSL #2
0018c8  2103              MOVS     r1,#3
0018ca  eb010146          ADD      r1,r1,r6,LSL #1
0018ce  5c40              LDRB     r0,[r0,r1]
0018d0  4a4a              LDR      r2,|L1.6652|
0018d2  eb0211c7          ADD      r1,r2,r7,LSL #7
0018d6  2205              MOVS     r2,#5
0018d8  eb020286          ADD      r2,r2,r6,LSL #2
0018dc  5488              STRB     r0,[r1,r2]
0018de  1c70              ADDS     r0,r6,#1              ;2087
0018e0  b2c6              UXTB     r6,r0                 ;2087
                  |L1.6370|
0018e2  2e0d              CMP      r6,#0xd               ;2087
0018e4  dbdb              BLT      |L1.6302|
0018e6  1c78              ADDS     r0,r7,#1              ;2084
0018e8  b2c7              UXTB     r7,r0                 ;2084
                  |L1.6378|
0018ea  2f0c              CMP      r7,#0xc               ;2084
0018ec  dbd5              BLT      |L1.6298|
;;;2091   					}
;;;2092   			#else
;;;2093   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;2094   					{
;;;2095   						ImageBufPIX[(j<<1)][i+4] =i+4;
;;;2096   						ImageBufPIX[(j<<1)][i+5] =i+5;
;;;2097   					}
;;;2098   			#endif	
;;;2099   				}	
;;;2100   			break;
0018ee  e0ba              B        |L1.6758|
                  |L1.6384|
;;;2101   
;;;2102   			case 1:
;;;2103   				for(j=0;j<PIX_TOTAL_ROW;j++)
0018f0  2700              MOVS     r7,#0
0018f2  e027              B        |L1.6468|
                  |L1.6388|
;;;2104   				{
;;;2105   			#ifndef PIX24_DEBUG_UART_PRINT
;;;2106   					for(i=0;i<(PIX_TOTAL_COL);i++)
0018f4  2600              MOVS     r6,#0
0018f6  e021              B        |L1.6460|
                  |L1.6392|
;;;2107   					{
;;;2108   						ImageBufPIX[(j<<1)][(i<<2)+2] =ImageBuf[j][(i<<1)+2];
0018f8  ebc700c7          RSB      r0,r7,r7,LSL #3
0018fc  493e              LDR      r1,|L1.6648|
0018fe  eb010080          ADD      r0,r1,r0,LSL #2
001902  2102              MOVS     r1,#2
001904  eb010146          ADD      r1,r1,r6,LSL #1
001908  5c40              LDRB     r0,[r0,r1]
00190a  4a3c              LDR      r2,|L1.6652|
00190c  eb0211c7          ADD      r1,r2,r7,LSL #7
001910  2202              MOVS     r2,#2
001912  eb020286          ADD      r2,r2,r6,LSL #2
001916  5488              STRB     r0,[r1,r2]
;;;2109   						ImageBufPIX[(j<<1)][(i<<2)+3] =ImageBuf[j][(i<<1)+3];
001918  ebc700c7          RSB      r0,r7,r7,LSL #3
00191c  4936              LDR      r1,|L1.6648|
00191e  eb010080          ADD      r0,r1,r0,LSL #2
001922  2103              MOVS     r1,#3
001924  eb010146          ADD      r1,r1,r6,LSL #1
001928  5c40              LDRB     r0,[r0,r1]
00192a  4a34              LDR      r2,|L1.6652|
00192c  eb0211c7          ADD      r1,r2,r7,LSL #7
001930  2203              MOVS     r2,#3
001932  eb020286          ADD      r2,r2,r6,LSL #2
001936  5488              STRB     r0,[r1,r2]
001938  1c70              ADDS     r0,r6,#1              ;2106
00193a  b2c6              UXTB     r6,r0                 ;2106
                  |L1.6460|
00193c  2e0d              CMP      r6,#0xd               ;2106
00193e  dbdb              BLT      |L1.6392|
001940  1c78              ADDS     r0,r7,#1              ;2103
001942  b2c7              UXTB     r7,r0                 ;2103
                  |L1.6468|
001944  2f0c              CMP      r7,#0xc               ;2103
001946  dbd5              BLT      |L1.6388|
;;;2110   					}	
;;;2111   			#else
;;;2112   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;2113   					{
;;;2114   						ImageBufPIX[(j<<1)][i+2] =i+2;
;;;2115   						ImageBufPIX[(j<<1)][i+3] =i+3;
;;;2116   					}
;;;2117   			#endif	
;;;2118   				}	
;;;2119   			break;
001948  e08d              B        |L1.6758|
                  |L1.6474|
;;;2120   
;;;2121   			case 2:
;;;2122   				for(j=0;j<PIX_TOTAL_ROW;j++)
00194a  2700              MOVS     r7,#0
00194c  e02f              B        |L1.6574|
                  |L1.6478|
;;;2123   				{
;;;2124   				#ifndef PIX24_DEBUG_UART_PRINT
;;;2125   					for(i=0;i<(PIX_TOTAL_COL);i++)
00194e  2600              MOVS     r6,#0
001950  e029              B        |L1.6566|
                  |L1.6482|
;;;2126   					{
;;;2127   						ImageBufPIX[(j<<1)+1][(i<<2)+4] =ImageBuf[j][(i<<1)+2];
001952  ebc700c7          RSB      r0,r7,r7,LSL #3
001956  4928              LDR      r1,|L1.6648|
001958  eb010080          ADD      r0,r1,r0,LSL #2
00195c  2102              MOVS     r1,#2
00195e  eb010146          ADD      r1,r1,r6,LSL #1
001962  5c40              LDRB     r0,[r0,r1]
001964  2101              MOVS     r1,#1
001966  eb010147          ADD      r1,r1,r7,LSL #1
00196a  4a24              LDR      r2,|L1.6652|
00196c  eb021181          ADD      r1,r2,r1,LSL #6
001970  2204              MOVS     r2,#4
001972  eb020286          ADD      r2,r2,r6,LSL #2
001976  5488              STRB     r0,[r1,r2]
;;;2128   						ImageBufPIX[(j<<1)+1][(i<<2)+5] =ImageBuf[j][(i<<1)+3];
001978  ebc700c7          RSB      r0,r7,r7,LSL #3
00197c  491e              LDR      r1,|L1.6648|
00197e  eb010080          ADD      r0,r1,r0,LSL #2
001982  2103              MOVS     r1,#3
001984  eb010146          ADD      r1,r1,r6,LSL #1
001988  5c40              LDRB     r0,[r0,r1]
00198a  2101              MOVS     r1,#1
00198c  eb010147          ADD      r1,r1,r7,LSL #1
001990  e000              B        |L1.6548|
                  |L1.6546|
001992  e067              B        |L1.6756|
                  |L1.6548|
001994  4a19              LDR      r2,|L1.6652|
001996  eb021181          ADD      r1,r2,r1,LSL #6
00199a  2205              MOVS     r2,#5
00199c  eb020286          ADD      r2,r2,r6,LSL #2
0019a0  5488              STRB     r0,[r1,r2]
0019a2  1c70              ADDS     r0,r6,#1              ;2125
0019a4  b2c6              UXTB     r6,r0                 ;2125
                  |L1.6566|
0019a6  2e0d              CMP      r6,#0xd               ;2125
0019a8  dbd3              BLT      |L1.6482|
0019aa  1c78              ADDS     r0,r7,#1              ;2122
0019ac  b2c7              UXTB     r7,r0                 ;2122
                  |L1.6574|
0019ae  2f0c              CMP      r7,#0xc               ;2122
0019b0  dbcd              BLT      |L1.6478|
;;;2129   					}
;;;2130   				#else
;;;2131   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;2132   					{
;;;2133   						ImageBufPIX[(j<<1)+1][i+4] =i+4+0x80;
;;;2134   						ImageBufPIX[(j<<1)+1][i+5] =i+5+0x80;
;;;2135   					}
;;;2136   				#endif	
;;;2137   				}	
;;;2138   			break;
0019b2  e058              B        |L1.6758|
                  |L1.6580|
;;;2139   
;;;2140   			case 3:
;;;2141   				for(j=0;j<PIX_TOTAL_ROW;j++)
0019b4  2700              MOVS     r7,#0
0019b6  e052              B        |L1.6750|
                  |L1.6584|
;;;2142   				{
;;;2143   				#ifndef PIX24_DEBUG_UART_PRINT
;;;2144   					for(i=0;i<(PIX_TOTAL_COL);i++)
0019b8  2600              MOVS     r6,#0
0019ba  e04c              B        |L1.6742|
                  |L1.6588|
;;;2145   					{
;;;2146   						ImageBufPIX[(j<<1)+1][(i<<2)+2] =ImageBuf[j][(i<<1)+2];
0019bc  ebc700c7          RSB      r0,r7,r7,LSL #3
0019c0  490d              LDR      r1,|L1.6648|
0019c2  eb010080          ADD      r0,r1,r0,LSL #2
0019c6  2102              MOVS     r1,#2
0019c8  eb010146          ADD      r1,r1,r6,LSL #1
0019cc  5c40              LDRB     r0,[r0,r1]
0019ce  2101              MOVS     r1,#1
0019d0  eb010147          ADD      r1,r1,r7,LSL #1
0019d4  4a09              LDR      r2,|L1.6652|
0019d6  eb021181          ADD      r1,r2,r1,LSL #6
0019da  2202              MOVS     r2,#2
0019dc  eb020286          ADD      r2,r2,r6,LSL #2
0019e0  5488              STRB     r0,[r1,r2]
;;;2147   						ImageBufPIX[(j<<1)+1][(i<<2)+3] =ImageBuf[j][(i<<1)+3];
0019e2  ebc700c7          RSB      r0,r7,r7,LSL #3
0019e6  4904              LDR      r1,|L1.6648|
0019e8  eb010080          ADD      r0,r1,r0,LSL #2
0019ec  2103              MOVS     r1,#3
0019ee  eb010146          ADD      r1,r1,r6,LSL #1
0019f2  5c40              LDRB     r0,[r0,r1]
0019f4  2101              MOVS     r1,#1
0019f6  e023              B        |L1.6720|
                  |L1.6648|
                          DCD      ImageBuf
                  |L1.6652|
                          DCD      ImageBufPIX
                  |L1.6656|
                          DCD      led_mode
                  |L1.6660|
                          DCD      0x42238194
                  |L1.6664|
                          DCD      OSC_mode
                  |L1.6668|
                          DCD      0x42240198
                  |L1.6672|
                          DCD      OSC_Status
                  |L1.6676|
                          DCD      PCRChip_Command_Send
                  |L1.6680|
                          DCD      Time_LED_Delay
                  |L1.6684|
                          DCD      0x42238000
                  |L1.6688|
                          DCD      SetTm_LED_Delay
                  |L1.6692|
                          DCD      PIXEL_24READ
                  |L1.6696|
                          DCD      PCR_Regs
                  |L1.6700|
                          DCD      BaseCounter
                  |L1.6704|
                          DCD      0x40000400
                  |L1.6708|
                          DCD      TMR_Int_Flag
                  |L1.6712|
                          DCD      PCR_ADC_Done_Flag
                  |L1.6716|
                          DCD      SPI_2_RcvBuf
                  |L1.6720|
001a40  eb010147          ADD      r1,r1,r7,LSL #1
001a44  4ad1              LDR      r2,|L1.7564|
001a46  eb021181          ADD      r1,r2,r1,LSL #6
001a4a  2203              MOVS     r2,#3
001a4c  eb020286          ADD      r2,r2,r6,LSL #2
001a50  5488              STRB     r0,[r1,r2]
001a52  1c70              ADDS     r0,r6,#1              ;2144
001a54  b2c6              UXTB     r6,r0                 ;2144
                  |L1.6742|
001a56  2e0d              CMP      r6,#0xd               ;2144
001a58  dbb0              BLT      |L1.6588|
001a5a  1c78              ADDS     r0,r7,#1              ;2141
001a5c  b2c7              UXTB     r7,r0                 ;2141
                  |L1.6750|
001a5e  2f0c              CMP      r7,#0xc               ;2141
001a60  dbaa              BLT      |L1.6584|
;;;2148   					}
;;;2149   				#else
;;;2150   				   	for(i=0;i<(PIX_TOTAL_COL<<2);i+=4)
;;;2151   					{
;;;2152   						ImageBufPIX[(j<<1)+1][i+2] =i+2+0x80;
;;;2153   						ImageBufPIX[(j<<1)+1][i+3] =i+3+0x80;
;;;2154   					}
;;;2155   				#endif	
;;;2156   				}	
;;;2157   			break;
001a62  e000              B        |L1.6758|
                  |L1.6756|
;;;2158   		
;;;2159   			default:
;;;2160   			break;
001a64  bf00              NOP      
                  |L1.6758|
001a66  bf00              NOP                            ;2100
001a68  f1090001          ADD      r0,r9,#1              ;2037
001a6c  f00009ff          AND      r9,r0,#0xff           ;2037
                  |L1.6768|
001a70  f1b90f04          CMP      r9,#4                 ;2037
001a74  f6ffae7c          BLT      |L1.6000|
;;;2161   		}
;;;2162   	}
;;;2163   /*
;;;2164   	PCR_Regs.SW_TxCtrl=	PCRChip_Command_Send[10];
;;;2165   	Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[10]);	
;;;2166   */
;;;2167   
;;;2168   	///////	add LED control
;;;2169   			   LED_CTRL=(0x1 & led_mode);
001a78  48c5              LDR      r0,|L1.7568|
001a7a  7800              LDRB     r0,[r0,#0]  ; led_mode
001a7c  f0000001          AND      r0,r0,#1
001a80  49c4              LDR      r1,|L1.7572|
001a82  6008              STR      r0,[r1,#0]
;;;2170   	////////LED control
;;;2171   
;;;2172   	if(OSC_mode != OSC_ON)
001a84  48c4              LDR      r0,|L1.7576|
001a86  7800              LDRB     r0,[r0,#0]  ; OSC_mode
001a88  2801              CMP      r0,#1
001a8a  d004              BEQ      |L1.6806|
;;;2173   	{
;;;2174   		OSC_Ctrl=OSC_OFF;
001a8c  2000              MOVS     r0,#0
001a8e  49c3              LDR      r1,|L1.7580|
001a90  6008              STR      r0,[r1,#0]
;;;2175   		OSC_Status=0;
001a92  49c3              LDR      r1,|L1.7584|
001a94  7008              STRB     r0,[r1,#0]
                  |L1.6806|
;;;2176   	}
;;;2177   
;;;2178   	if(mode == TYP_24PIXIMAG)
001a96  2c08              CMP      r4,#8
001a98  d123              BNE      |L1.6882|
;;;2179   	{			
;;;2180   		for(i=0;i<24;i++)
001a9a  2600              MOVS     r6,#0
001a9c  e00a              B        |L1.6836|
                  |L1.6814|
;;;2181   		{	 ImageBufPIX[i][0]=TYP_24PIXIMAG;
001a9e  2008              MOVS     r0,#8
001aa0  49ba              LDR      r1,|L1.7564|
001aa2  eb011186          ADD      r1,r1,r6,LSL #6
001aa6  7008              STRB     r0,[r1,#0]
;;;2182   			 ImageBufPIX[i][1] = i;
001aa8  48b8              LDR      r0,|L1.7564|
001aaa  eb001086          ADD      r0,r0,r6,LSL #6
001aae  7046              STRB     r6,[r0,#1]
001ab0  1c70              ADDS     r0,r6,#1              ;2180
001ab2  b2c6              UXTB     r6,r0                 ;2180
                  |L1.6836|
001ab4  2e18              CMP      r6,#0x18              ;2180
001ab6  dbf2              BLT      |L1.6814|
;;;2183   		}
;;;2184   
;;;2185   		for(i=0;i<24;i++)
001ab8  2600              MOVS     r6,#0
001aba  e00f              B        |L1.6876|
                  |L1.6844|
;;;2186   		{
;;;2187   //#ifndef PIX24_DEBUG_UART_PRINT
;;;2188   			 USBRes(NO_ERR, CMD_GET, &ImageBufPIX[i][0], 52);
001abc  48b3              LDR      r0,|L1.7564|
001abe  eb001286          ADD      r2,r0,r6,LSL #6
001ac2  2334              MOVS     r3,#0x34
001ac4  2102              MOVS     r1,#2
001ac6  2000              MOVS     r0,#0
001ac8  f7fffffe          BL       USBRes
;;;2189   //#else
;;;2190   //			 UARTRes(NO_ERR, CMD_GET, &ImageBufPIX[i][0], 52);
;;;2191   //#endif
;;;2192   			#if !defined(USB_WAIT_MODE)
;;;2193   			delay_ms(35);
;;;2194   			#else
;;;2195   			EpMsgEnable();
001acc  f7fffffe          BL       EpMsgEnable
;;;2196   			UsbReadDone();
001ad0  f7fffffe          BL       UsbReadDone
;;;2197   			EpMsgDisable();
001ad4  f7fffffe          BL       EpMsgDisable
001ad8  1c70              ADDS     r0,r6,#1              ;2185
001ada  b2c6              UXTB     r6,r0                 ;2185
                  |L1.6876|
001adc  2e18              CMP      r6,#0x18              ;2185
001ade  dbed              BLT      |L1.6844|
001ae0  e018              B        |L1.6932|
                  |L1.6882|
;;;2198   			#endif
;;;2199   		}
;;;2200   	 }
;;;2201   	 else if(mode == TYP_24PIXROW)
001ae2  2c07              CMP      r4,#7
001ae4  d116              BNE      |L1.6932|
;;;2202   	 {
;;;2203   		 ImageBufPIX[row][0] =  TYP_24PIXROW;
001ae6  2007              MOVS     r0,#7
001ae8  49a8              LDR      r1,|L1.7564|
001aea  eb011185          ADD      r1,r1,r5,LSL #6
001aee  7008              STRB     r0,[r1,#0]
;;;2204   		 ImageBufPIX[row][1] =  row ;
001af0  48a6              LDR      r0,|L1.7564|
001af2  eb001085          ADD      r0,r0,r5,LSL #6
001af6  7045              STRB     r5,[r0,#1]
;;;2205   //#ifndef PIX24_DEBUG_UART_PRINT
;;;2206   		 USBRes(NO_ERR, CMD_GET, &ImageBufPIX[row][0], 52);	
001af8  48a4              LDR      r0,|L1.7564|
001afa  eb001285          ADD      r2,r0,r5,LSL #6
001afe  2334              MOVS     r3,#0x34
001b00  2102              MOVS     r1,#2
001b02  2000              MOVS     r0,#0
001b04  f7fffffe          BL       USBRes
;;;2207   //#else
;;;2208   		// UARTRes(NO_ERR, CMD_GET, &ImageBufPIX[row][0], 52);
;;;2209   //#endif	
;;;2210   			#if !defined(USB_WAIT_MODE)
;;;2211   			delay_ms(35);
;;;2212   			#else
;;;2213   			EpMsgEnable();
001b08  f7fffffe          BL       EpMsgEnable
;;;2214   			UsbReadDone();
001b0c  f7fffffe          BL       UsbReadDone
;;;2215   			EpMsgDisable();
001b10  f7fffffe          BL       EpMsgDisable
                  |L1.6932|
;;;2216   			#endif	  	
;;;2217   	 }
;;;2218   /*
;;;2219   	if(PixReadmMode==TYP_24PIXIMAG)//TXC
;;;2220   	{
;;;2221   		for(j=0;j<24;j++)
;;;2222   			ImageBuf[j][1]=j;
;;;2223      		PixReadmMode=DISABLE;
;;;2224   	}
;;;2225   	else if(PixReadmMode==TYP_VIDEO)
;;;2226   	{
;;;2227   		for(j=0;j<(PIX_TOTAL_ROW);j++)
;;;2228   			ImageBuf[j][0]=VIDEO_TOTAL_ROW;
;;;2229   	}
;;;2230   
;;;2231   */
;;;2232   
;;;2233   }
001b14  e8bd87f0          POP      {r4-r10,pc}
;;;2234   
                          ENDP

                  ReadUpdate_Image PROC
;;;2235   void ReadUpdate_Image(void)	
001b18  b570              PUSH     {r4-r6,lr}
;;;2236   {
;;;2237    	u8 i,j,u8temp;
;;;2238   
;;;2239   	OSC_Ctrl=OSC_ON;
001b1a  2001              MOVS     r0,#1
001b1c  499f              LDR      r1,|L1.7580|
001b1e  6008              STR      r0,[r1,#0]
;;;2240   	OSC_Status=1;
001b20  499f              LDR      r1,|L1.7584|
001b22  7008              STRB     r0,[r1,#0]
;;;2241   	delay_ms(10);
001b24  200a              MOVS     r0,#0xa
001b26  f7fffffe          BL       delay_ms
;;;2242    	PCRChip_Command_Send[0]=0xC3;
001b2a  20c3              MOVS     r0,#0xc3
001b2c  499d              LDR      r1,|L1.7588|
001b2e  7008              STRB     r0,[r1,#0]
;;;2243   	PCRChip_Command_Send[1]=0x00;
001b30  2000              MOVS     r0,#0
001b32  7048              STRB     r0,[r1,#1]
;;;2244   	PCRChip_Command_Send[2]=0xA1;
001b34  20a1              MOVS     r0,#0xa1
001b36  7088              STRB     r0,[r1,#2]
;;;2245   	PCRChip_Command_Send[3]=0xB5;
001b38  20b5              MOVS     r0,#0xb5
001b3a  70c8              STRB     r0,[r1,#3]
;;;2246   	PCRChip_Command_Send[4]=0x21;
001b3c  2021              MOVS     r0,#0x21
001b3e  7108              STRB     r0,[r1,#4]
;;;2247   	PCRChip_Command_Send[5]=0x61;
001b40  2061              MOVS     r0,#0x61
001b42  7148              STRB     r0,[r1,#5]
;;;2248   	/*
;;;2249   	PCRChip_Command_Send[6]=0x2D; 
;;;2250   	PCRChip_Command_Send[7]=0x00;
;;;2251   	*/
;;;2252        //Anitoa required to change it @ 12nd Oct.
;;;2253   	PCRChip_Command_Send[6]=0x29; 
001b44  2029              MOVS     r0,#0x29
001b46  7188              STRB     r0,[r1,#6]
;;;2254   	PCRChip_Command_Send[7]=0x21; 
001b48  2021              MOVS     r0,#0x21
001b4a  71c8              STRB     r0,[r1,#7]
;;;2255   	PCRChip_Command_Send[8]=0x00; 
001b4c  2000              MOVS     r0,#0
001b4e  7208              STRB     r0,[r1,#8]
;;;2256   /*
;;;2257   	PCRChip_Command_Send[9]=0xf;
;;;2258    	PCRChip_Command_Send[9]=PCR_Regs.SW_TxCtrl=TX_PACK(0x0f,PCR_Regs.SW_TxCtrl);
;;;2259   	Send_Command(REG_WRITE, TX_PATTERN_ADDR, 1, &PCRChip_Command_Send[9]);
;;;2260   */
;;;2261   
;;;2262   	///////	add LED control
;;;2263   	           Time_LED_Delay=0;
001b50  4995              LDR      r1,|L1.7592|
001b52  8008              STRH     r0,[r1,#0]
;;;2264   			   TIM7_Init();
001b54  f7fffffe          BL       TIM7_Init
;;;2265   			   LED_CTRL=1;
001b58  2001              MOVS     r0,#1
001b5a  4994              LDR      r1,|L1.7596|
001b5c  f8c10194          STR      r0,[r1,#0x194]
;;;2266   			   while(Time_LED_Delay<SetTm_LED_Delay);
001b60  bf00              NOP      
                  |L1.7010|
001b62  4891              LDR      r0,|L1.7592|
001b64  8800              LDRH     r0,[r0,#0]  ; Time_LED_Delay
001b66  4992              LDR      r1,|L1.7600|
001b68  8809              LDRH     r1,[r1,#0]  ; SetTm_LED_Delay
001b6a  4288              CMP      r0,r1
001b6c  dbf9              BLT      |L1.7010|
;;;2267   			   TIM7_Stop();
001b6e  f7fffffe          BL       TIM7_Stop
;;;2268   	////////LED control
;;;2269   
;;;2270   //LED1=0;
;;;2271   	for(j=0;j<PIX_TOTAL_ROW;j++)
001b72  2400              MOVS     r4,#0
001b74  e007              B        |L1.7046|
                  |L1.7030|
;;;2272   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[0]);  // all row reset & start integration
001b76  4b8b              LDR      r3,|L1.7588|
001b78  2201              MOVS     r2,#1
001b7a  4621              MOV      r1,r4
001b7c  2003              MOVS     r0,#3
001b7e  f7fffffe          BL       Send_Command
001b82  1c60              ADDS     r0,r4,#1              ;2271
001b84  b2c4              UXTB     r4,r0                 ;2271
                  |L1.7046|
001b86  2c0c              CMP      r4,#0xc               ;2271
001b88  dbf5              BLT      |L1.7030|
;;;2273   	 
;;;2274   	for(j=0;j<PIX_TOTAL_ROW;j++)
001b8a  2400              MOVS     r4,#0
001b8c  e020              B        |L1.7120|
                  |L1.7054|
;;;2275   	{
;;;2276   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[1]); // start integration
001b8e  4b85              LDR      r3,|L1.7588|
001b90  1c5b              ADDS     r3,r3,#1
001b92  2201              MOVS     r2,#1
001b94  4621              MOV      r1,r4
001b96  2003              MOVS     r0,#3
001b98  f7fffffe          BL       Send_Command
;;;2277   
;;;2278   
;;;2279   		if(j==0)
001b9c  b994              CBNZ     r4,|L1.7108|
;;;2280   		{
;;;2281   			TIM3_ARR_Update(PCR_Regs.InteCount);
001b9e  4985              LDR      r1,|L1.7604|
001ba0  8948              LDRH     r0,[r1,#0xa]  ; PCR_Regs
001ba2  f7fffffe          BL       TIM3_ARR_Update
;;;2282   			BaseCounter= PCR_Regs.InteTime;
001ba6  4883              LDR      r0,|L1.7604|
001ba8  8900              LDRH     r0,[r0,#8]  ; PCR_Regs
001baa  4983              LDR      r1,|L1.7608|
001bac  8008              STRH     r0,[r1,#0]
;;;2283   			TIM3->CR1|=0x01; 
001bae  4883              LDR      r0,|L1.7612|
001bb0  8800              LDRH     r0,[r0,#0]
001bb2  f0400001          ORR      r0,r0,#1
001bb6  f04f4180          MOV      r1,#0x40000000
001bba  f8a10400          STRH     r0,[r1,#0x400]
;;;2284   			TMR_Int_Flag=0;
001bbe  2000              MOVS     r0,#0
001bc0  497f              LDR      r1,|L1.7616|
001bc2  8008              STRH     r0,[r1,#0]
                  |L1.7108|
;;;2285   //	LED1=1;
;;;2286   			//TIM3_ARR_Update(PCR_Regs.InteDelayCount);
;;;2287   		}
;;;2288   		delay_us(INTERVAL_DELAY_US);
001bc4  f44f7016          MOV      r0,#0x258
001bc8  f7fffffe          BL       delay_us
001bcc  1c60              ADDS     r0,r4,#1              ;2274
001bce  b2c4              UXTB     r4,r0                 ;2274
                  |L1.7120|
001bd0  2c0c              CMP      r4,#0xc               ;2274
001bd2  dbdc              BLT      |L1.7054|
;;;2289   	}
;;;2290   
;;;2291   	for(j=0;j<PIX_TOTAL_ROW;j++)
001bd4  2400              MOVS     r4,#0
001bd6  e03e              B        |L1.7254|
                  |L1.7128|
;;;2292   	{
;;;2293   		while((TMR_Int_Flag & (1<<j))==0);
001bd8  bf00              NOP      
                  |L1.7130|
001bda  2001              MOVS     r0,#1
001bdc  40a0              LSLS     r0,r0,r4
001bde  4978              LDR      r1,|L1.7616|
001be0  8809              LDRH     r1,[r1,#0]  ; TMR_Int_Flag
001be2  4208              TST      r0,r1
001be4  d0f9              BEQ      |L1.7130|
;;;2294   //	LED1=0;
;;;2295   /*
;;;2296   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[2]); //reset
;;;2297   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[3]); //capture reset value
;;;2298   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[4]); //finish reset capture
;;;2299   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[5]); //charge transfer
;;;2300   		Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[6]); //capture the pixel value
;;;2301   	    Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[7]); // all done
;;;2302   */
;;;2303   
;;;2304   		for(i=2;i<PXL_PHASE;i++)
001be6  2502              MOVS     r5,#2
001be8  e008              B        |L1.7164|
                  |L1.7146|
;;;2305   			Send_Command(PXL_DRIVE, j, 1, &PCRChip_Command_Send[i]);
001bea  486e              LDR      r0,|L1.7588|
001bec  1943              ADDS     r3,r0,r5
001bee  2201              MOVS     r2,#1
001bf0  4621              MOV      r1,r4
001bf2  2003              MOVS     r0,#3
001bf4  f7fffffe          BL       Send_Command
001bf8  1c68              ADDS     r0,r5,#1              ;2304
001bfa  b2c5              UXTB     r5,r0                 ;2304
                  |L1.7164|
001bfc  2d09              CMP      r5,#9                 ;2304
001bfe  dbf4              BLT      |L1.7146|
;;;2306   
;;;2307   		Send_Command(ADC_START, j, 0, &PCRChip_Command_Send[0]); // ADC process
001c00  4b68              LDR      r3,|L1.7588|
001c02  2200              MOVS     r2,#0
001c04  4621              MOV      r1,r4
001c06  2004              MOVS     r0,#4
001c08  f7fffffe          BL       Send_Command
;;;2308   		PCR_ADC_Done_Flag=0;
001c0c  2000              MOVS     r0,#0
001c0e  496d              LDR      r1,|L1.7620|
001c10  7008              STRB     r0,[r1,#0]
;;;2309   #ifndef PIX24_DEBUG_UART_PRINT
;;;2310   		while(PCR_ADC_Done_Flag==0); // wait for ADC conversion done
001c12  bf00              NOP      
                  |L1.7188|
001c14  486b              LDR      r0,|L1.7620|
001c16  7800              LDRB     r0,[r0,#0]  ; PCR_ADC_Done_Flag
001c18  2800              CMP      r0,#0
001c1a  d0fb              BEQ      |L1.7188|
;;;2311   #endif
;;;2312   		Send_Command(PCR_ADC_READ, j, 0, &PCRChip_Command_Send[0]);
001c1c  4b61              LDR      r3,|L1.7588|
001c1e  2200              MOVS     r2,#0
001c20  4621              MOV      r1,r4
001c22  2005              MOVS     r0,#5
001c24  f7fffffe          BL       Send_Command
;;;2313   //	LED1=!LED1;
;;;2314   
;;;2315   		ImageBuf[j][1]=j;
001c28  ebc400c4          RSB      r0,r4,r4,LSL #3
001c2c  4966              LDR      r1,|L1.7624|
001c2e  eb010080          ADD      r0,r1,r0,LSL #2
001c32  7044              STRB     r4,[r0,#1]
;;;2316   		for(i=0;i<(PIX_TOTAL_COL<<1);i++)
001c34  2500              MOVS     r5,#0
001c36  e00a              B        |L1.7246|
                  |L1.7224|
;;;2317   		{
;;;2318   			ImageBuf[j][i+2]=SPI_2_RcvBuf[i];//RowData[i];  // LPG: read SPI buffer directly, 131015
001c38  4864              LDR      r0,|L1.7628|
001c3a  5d41              LDRB     r1,[r0,r5]
001c3c  ebc400c4          RSB      r0,r4,r4,LSL #3
001c40  4a61              LDR      r2,|L1.7624|
001c42  eb020280          ADD      r2,r2,r0,LSL #2
001c46  1ca8              ADDS     r0,r5,#2
001c48  5411              STRB     r1,[r2,r0]
001c4a  1c68              ADDS     r0,r5,#1              ;2316
001c4c  b2c5              UXTB     r5,r0                 ;2316
                  |L1.7246|
001c4e  2d1a              CMP      r5,#0x1a              ;2316
001c50  dbf2              BLT      |L1.7224|
001c52  1c60              ADDS     r0,r4,#1              ;2291
001c54  b2c4              UXTB     r4,r0                 ;2291
                  |L1.7254|
001c56  2c0c              CMP      r4,#0xc               ;2291
001c58  dbbe              BLT      |L1.7128|
;;;2319   		}
;;;2320   			
;;;2321   	}
;;;2322   
;;;2323   	///////	add LED control
;;;2324   			   LED_CTRL=(0x1 & led_mode);
001c5a  484d              LDR      r0,|L1.7568|
001c5c  7800              LDRB     r0,[r0,#0]  ; led_mode
001c5e  f0000001          AND      r0,r0,#1
001c62  494c              LDR      r1,|L1.7572|
001c64  6008              STR      r0,[r1,#0]
;;;2325   	////////LED control
;;;2326   
;;;2327   	if(OSC_mode != OSC_ON)
001c66  484c              LDR      r0,|L1.7576|
001c68  7800              LDRB     r0,[r0,#0]  ; OSC_mode
001c6a  2801              CMP      r0,#1
001c6c  d004              BEQ      |L1.7288|
;;;2328   	{
;;;2329   		OSC_Ctrl=OSC_OFF;
001c6e  2000              MOVS     r0,#0
001c70  494a              LDR      r1,|L1.7580|
001c72  6008              STR      r0,[r1,#0]
;;;2330   		OSC_Status=0;
001c74  494a              LDR      r1,|L1.7584|
001c76  7008              STRB     r0,[r1,#0]
                  |L1.7288|
;;;2331   	}
;;;2332   
;;;2333   
;;;2334   	if(PixReadmMode==TYP_IMAGE)
001c78  4855              LDR      r0,|L1.7632|
001c7a  7800              LDRB     r0,[r0,#0]  ; PixReadmMode
001c7c  2802              CMP      r0,#2
001c7e  d10f              BNE      |L1.7328|
;;;2335   	{
;;;2336   		for(j=0;j<(PIX_TOTAL_ROW);j++)
001c80  2400              MOVS     r4,#0
001c82  e007              B        |L1.7316|
                  |L1.7300|
;;;2337   		ImageBuf[j][0]=TYP_IMAGE;  //TXC://ImageBuf[j][0]=PIX_TOTAL_ROW;
001c84  2002              MOVS     r0,#2
001c86  ebc401c4          RSB      r1,r4,r4,LSL #3
001c8a  4a4f              LDR      r2,|L1.7624|
001c8c  f8020021          STRB     r0,[r2,r1,LSL #2]
001c90  1c60              ADDS     r0,r4,#1              ;2336
001c92  b2c4              UXTB     r4,r0                 ;2336
                  |L1.7316|
001c94  2c0c              CMP      r4,#0xc               ;2336
001c96  dbf5              BLT      |L1.7300|
;;;2338      		PixReadmMode=DISABLE;
001c98  2000              MOVS     r0,#0
001c9a  494d              LDR      r1,|L1.7632|
001c9c  7008              STRB     r0,[r1,#0]
001c9e  e00f              B        |L1.7360|
                  |L1.7328|
;;;2339   	}
;;;2340   	else if(PixReadmMode==TYP_VIDEO)
001ca0  484b              LDR      r0,|L1.7632|
001ca2  7800              LDRB     r0,[r0,#0]  ; PixReadmMode
001ca4  2803              CMP      r0,#3
001ca6  d10b              BNE      |L1.7360|
;;;2341   	{
;;;2342   		for(j=0;j<(PIX_TOTAL_ROW);j++)
001ca8  2400              MOVS     r4,#0
001caa  e007              B        |L1.7356|
                  |L1.7340|
;;;2343   			ImageBuf[j][0]=VIDEO_TOTAL_ROW;
001cac  20ff              MOVS     r0,#0xff
001cae  ebc401c4          RSB      r1,r4,r4,LSL #3
001cb2  4a45              LDR      r2,|L1.7624|
001cb4  f8020021          STRB     r0,[r2,r1,LSL #2]
001cb8  1c60              ADDS     r0,r4,#1              ;2342
001cba  b2c4              UXTB     r4,r0                 ;2342
                  |L1.7356|
001cbc  2c0c              CMP      r4,#0xc               ;2342
001cbe  dbf5              BLT      |L1.7340|
                  |L1.7360|
;;;2344   	}
;;;2345   	u8temp=(PIX_TOTAL_COL<<1)+2;
001cc0  261c              MOVS     r6,#0x1c
;;;2346   /*
;;;2347   	///////debug
;;;2348   		for(j=0;j<(PIX_TOTAL_ROW);j++)
;;;2349   		{
;;;2350   			for(i=0;i<(PIX_TOTAL_COL<<1);i++)
;;;2351   				ImageBuf[j][i+2]=i;
;;;2352   		}	
;;;2353   	///////debug end
;;;2354   */
;;;2355   	for(i=0;i<(PIX_TOTAL_ROW);i++)
001cc2  2500              MOVS     r5,#0
001cc4  e011              B        |L1.7402|
                  |L1.7366|
;;;2356   	{
;;;2357   		USBRes(NO_ERR, CMD_GET,&ImageBuf[i][0],u8temp);
001cc6  ebc500c5          RSB      r0,r5,r5,LSL #3
001cca  493f              LDR      r1,|L1.7624|
001ccc  eb010280          ADD      r2,r1,r0,LSL #2
001cd0  4633              MOV      r3,r6
001cd2  2102              MOVS     r1,#2
001cd4  2000              MOVS     r0,#0
001cd6  f7fffffe          BL       USBRes
;;;2358   	   		#if !defined(USB_WAIT_MODE)
;;;2359   			delay_ms(35);
;;;2360   			#else
;;;2361   			EpMsgEnable();
001cda  f7fffffe          BL       EpMsgEnable
;;;2362   			UsbReadDone();
001cde  f7fffffe          BL       UsbReadDone
;;;2363   			EpMsgDisable();
001ce2  f7fffffe          BL       EpMsgDisable
001ce6  1c68              ADDS     r0,r5,#1              ;2355
001ce8  b2c5              UXTB     r5,r0                 ;2355
                  |L1.7402|
001cea  2d0c              CMP      r5,#0xc               ;2355
001cec  dbeb              BLT      |L1.7366|
;;;2364   			#endif	 
;;;2365   	 }
;;;2366   }
001cee  bd70              POP      {r4-r6,pc}
;;;2367   
                          ENDP

                  Read_Row_Debug_2 PROC
;;;2381   /* 	ADC convert & SPI  read, without pixel driving*/
;;;2382   void Read_Row_Debug_2(void)
001cf0  b510              PUSH     {r4,lr}
;;;2383   {
;;;2384   
;;;2385   
;;;2386   	OSC_Ctrl=OSC_ON;
001cf2  2001              MOVS     r0,#1
001cf4  4929              LDR      r1,|L1.7580|
001cf6  6008              STR      r0,[r1,#0]
;;;2387   	OSC_Status=1;
001cf8  4929              LDR      r1,|L1.7584|
001cfa  7008              STRB     r0,[r1,#0]
;;;2388   
;;;2389   	delay_ms(10);
001cfc  200a              MOVS     r0,#0xa
001cfe  f7fffffe          BL       delay_ms
;;;2390   	Send_Command(ADC_START, 0, 0, &PCRChip_Command_Send[0]);
001d02  4b28              LDR      r3,|L1.7588|
001d04  2200              MOVS     r2,#0
001d06  4611              MOV      r1,r2
001d08  2004              MOVS     r0,#4
001d0a  f7fffffe          BL       Send_Command
;;;2391   	PCR_ADC_Done_Flag=0;
001d0e  2000              MOVS     r0,#0
001d10  492c              LDR      r1,|L1.7620|
001d12  7008              STRB     r0,[r1,#0]
;;;2392   	while(PCR_ADC_Done_Flag==0);
001d14  bf00              NOP      
                  |L1.7446|
001d16  482b              LDR      r0,|L1.7620|
001d18  7800              LDRB     r0,[r0,#0]  ; PCR_ADC_Done_Flag
001d1a  2800              CMP      r0,#0
001d1c  d0fb              BEQ      |L1.7446|
;;;2393   	if(OSC_mode != OSC_ON)
001d1e  481e              LDR      r0,|L1.7576|
001d20  7800              LDRB     r0,[r0,#0]  ; OSC_mode
001d22  2801              CMP      r0,#1
001d24  d004              BEQ      |L1.7472|
;;;2394   	{
;;;2395   		OSC_Ctrl=OSC_OFF;
001d26  2000              MOVS     r0,#0
001d28  491c              LDR      r1,|L1.7580|
001d2a  6008              STR      r0,[r1,#0]
;;;2396   		OSC_Status=0;
001d2c  491c              LDR      r1,|L1.7584|
001d2e  7008              STRB     r0,[r1,#0]
                  |L1.7472|
;;;2397   	}	 
;;;2398   	Send_Command(PCR_ADC_READ, 0, 0, &PCRChip_Command_Send[0]);
001d30  4b1c              LDR      r3,|L1.7588|
001d32  2200              MOVS     r2,#0
001d34  4611              MOV      r1,r2
001d36  2005              MOVS     r0,#5
001d38  f7fffffe          BL       Send_Command
;;;2399   }	
001d3c  bd10              POP      {r4,pc}
;;;2400   
                          ENDP

                  Fan_Echo PROC
;;;2401   void Fan_Echo(u8 dat)
001d3e  4925              LDR      r1,|L1.7636|
;;;2402   {
;;;2403   	TxBuffer[0]= dat;
001d40  7008              STRB     r0,[r1,#0]
;;;2404   //txc//	USBRes(NO_ERR, CMD_TEMP_SET, TxBuffer, 1); 	
;;;2405   }
001d42  4770              BX       lr
;;;2406   
                          ENDP

                  EpMsgStk PROC
;;;2421   
;;;2422   void EpMsgStk(MSG_TYP u8Q)
001d44  4924              LDR      r1,|L1.7640|
;;;2423   {
;;;2424   	if(EpMsgRdy)
001d46  7809              LDRB     r1,[r1,#0]  ; EpMsgRdy
001d48  b111              CBZ      r1,|L1.7504|
;;;2425   		UsbFlg=	u8Q;	
001d4a  4923              LDR      r1,|L1.7640|
001d4c  1e49              SUBS     r1,r1,#1
001d4e  7008              STRB     r0,[r1,#0]
                  |L1.7504|
;;;2426   }
001d50  4770              BX       lr
;;;2427   
                          ENDP

                  EXTI9_5_IRQHandler PROC
;;;2467   
;;;2468   void EXTI9_5_IRQHandler(void)
001d52  4822              LDR      r0,|L1.7644|
;;;2469   {
;;;2470   	if(EXTI->PR & (0x1<<6)) //trg happen
001d54  6800              LDR      r0,[r0,#0]
001d56  f0100f40          TST      r0,#0x40
001d5a  d00d              BEQ      |L1.7544|
;;;2471   	{
;;;2472   		EXTI->PR |= (0x1<<6);
001d5c  481f              LDR      r0,|L1.7644|
001d5e  6800              LDR      r0,[r0,#0]
001d60  f0400040          ORR      r0,r0,#0x40
001d64  491e              LDR      r1,|L1.7648|
001d66  f8c10414          STR      r0,[r1,#0x414]
;;;2473   		if(mst_flag == BRD_IN_IDLE)
001d6a  481e              LDR      r0,|L1.7652|
001d6c  7800              LDRB     r0,[r0,#0]  ; mst_flag
001d6e  b958              CBNZ     r0,|L1.7560|
;;;2474   		{
;;;2475   			//trg_count=0; // count the trg number
;;;2476   			mst_flag = BRD_IN_TRG;  // flag record
001d70  2001              MOVS     r0,#1
001d72  491c              LDR      r1,|L1.7652|
001d74  7008              STRB     r0,[r1,#0]
001d76  e007              B        |L1.7560|
                  |L1.7544|
;;;2477   		}
;;;2478   	}
;;;2479   	else/*
;;;2480   		 if(EXTI->PR & (0x1<<15)) // rst happen
;;;2481   		{
;;;2482   			EXTI->PR |= (0x1<<15);
;;;2483   			trg_count=0; 				
;;;2484   		}
;;;2485   		*/
;;;2486   		EXTI->PR |= 0xffff;
001d78  4818              LDR      r0,|L1.7644|
001d7a  6800              LDR      r0,[r0,#0]
001d7c  f64f71ff          MOV      r1,#0xffff
001d80  4308              ORRS     r0,r0,r1
001d82  4917              LDR      r1,|L1.7648|
001d84  f8c10414          STR      r0,[r1,#0x414]
                  |L1.7560|
;;;2487   }
001d88  4770              BX       lr
                          ENDP

001d8a  0000              DCW      0x0000
                  |L1.7564|
                          DCD      ImageBufPIX
                  |L1.7568|
                          DCD      led_mode
                  |L1.7572|
                          DCD      0x42238194
                  |L1.7576|
                          DCD      OSC_mode
                  |L1.7580|
                          DCD      0x42240198
                  |L1.7584|
                          DCD      OSC_Status
                  |L1.7588|
                          DCD      PCRChip_Command_Send
                  |L1.7592|
                          DCD      Time_LED_Delay
                  |L1.7596|
                          DCD      0x42238000
                  |L1.7600|
                          DCD      SetTm_LED_Delay
                  |L1.7604|
                          DCD      PCR_Regs
                  |L1.7608|
                          DCD      BaseCounter
                  |L1.7612|
                          DCD      0x40000400
                  |L1.7616|
                          DCD      TMR_Int_Flag
                  |L1.7620|
                          DCD      PCR_ADC_Done_Flag
                  |L1.7624|
                          DCD      ImageBuf
                  |L1.7628|
                          DCD      SPI_2_RcvBuf
                  |L1.7632|
                          DCD      PixReadmMode
                  |L1.7636|
                          DCD      TxBuffer
                  |L1.7640|
                          DCD      ||.data||+0x52
                  |L1.7644|
                          DCD      0x40010414
                  |L1.7648|
                          DCD      0x40010000
                  |L1.7652|
                          DCD      mst_flag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  u8buff
                          %        40
                  PCRChip_Command_Send
                          %        40
                  Comand_Buf
                          %        64
                  ImageBuf
                          %        336
                  ImageBufPIX
                          %        4096
                  buf
                          %        64
                  PCR_Regs
                          %        16
                  PCR_Cycle_SetPoint
                          %        80
                  Buffer_Cycle_SetPoint
                          %        80
                  PE_Cycle_SetPoint
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  TEXT_Buffer
000000  57617253          DCB      0x57,0x61,0x72,0x53
000004  68697053          DCB      0x68,0x69,0x70,0x53
000008  544d3332          DCB      0x54,0x4d,0x33,0x32
00000c  20535049          DCB      0x20,0x53,0x50,0x49
000010  20544553          DCB      0x20,0x54,0x45,0x53
000014  5400              DCB      0x54,0x00
                  PIXEL_24READ
000016  0102              DCB      0x01,0x02
000018  0408              DCB      0x04,0x08

                          AREA ||.data||, DATA, ALIGN=2

                  TMR_Int_Flag
000000  0000              DCW      0x0000
                  PCR_ADC_Done_Flag
000002  00                DCB      0x00
                  Command_Len
000003  00                DCB      0x00
                  TxBuffer
000004  aa000000          DCB      0xaa,0x00,0x00,0x00
                          %        60
                  InteCnt
000044  0000              DCW      0x0000
                  msg_debug
000046  00                DCB      0x00
                  USB_Reply_Tail
000047  00                DCB      0x00
                  mst_flag
000048  0000              DCB      0x00,0x00
                  Time_LED_Delay
00004a  0000              DCW      0x0000
                  SetTm_LED_Delay
00004c  000a              DCW      0x000a
                  HoldTm_LED_Delay
00004e  000a              DCW      0x000a
                  led_mode
000050  00                DCB      0x00
                  UsbFlg
000051  00                DCB      0x00
                  EpMsgRdy
000052  00                DCB      0x00
                  PixReadmMode
000053  00                DCB      0x00
                  KL_temp
                          DCD      0x00000000
                  KP_temp
                          DCD      0x00000000
                  KI_temp
                          DCD      0x00000000
                  KD_temp
                          DCD      0x00000000
                  TempSet_1_temp
                          DCD      0x00000000
                  TempSet_2_temp
                          DCD      0x00000000
                  TempCurr_1_temp
                          DCD      0x00000000
                  TempCurr_2_temp
                          DCD      0x00000000
                  UnionTemp
                          DCD      0x00000000
                  PCR_Cycle_Control
                          DCD      0x00000000
                  Buffer_Cycle_Control
                          DCD      0x00000000
                  pCycleArray
                          DCD      0x00000000
                  CycleSTS
000084  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
