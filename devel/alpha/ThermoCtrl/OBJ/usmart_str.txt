; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o..\OBJ\usmart_str.o --depend=..\OBJ\usmart_str.d --device=DARMSTM --apcs=interwork -O0 -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\USMART -I..\HARDWARE\LED -I..\HARDWARE\BEEP -I..\HARDWARE\KEY -I..\HARDWARE\EXTI -I..\HARDWARE\WDG -I..\HARDWARE\TIMER -I..\HARDWARE\TPAD -I..\HARDWARE\OLED -I..\HARDWARE\LCD -I..\HARDWARE\RTC -I..\HARDWARE\WKUP -I..\HARDWARE\ADC -I..\HARDWARE\DAC -I..\HARDWARE\DMA -I..\HARDWARE\24CXX -I..\HARDWARE\SPI -I..\HARDWARE\FLASH -I..\USER -I..\USB\LIB -I..\USB\CONFIG -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=..\OBJ\usmart_str.crf ..\USMART\usmart_str.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usmart_strcmp PROC
;;;58     //返回值:0，相等;1，不相等;
;;;59     u8 usmart_strcmp(u8 *str1,u8 *str2)
000000  4602              MOV      r2,r0
;;;60     {
;;;61     	while(1)
000002  e00a              B        |L1.26|
                  |L1.4|
;;;62     	{
;;;63     		if(*str1!=*str2)return 1;//不相等
000004  7810              LDRB     r0,[r2,#0]
000006  780b              LDRB     r3,[r1,#0]
000008  4298              CMP      r0,r3
00000a  d001              BEQ      |L1.16|
00000c  2001              MOVS     r0,#1
                  |L1.14|
;;;64     		if(*str1=='\0')break;//对比完成了.
;;;65     		str1++;
;;;66     		str2++;
;;;67     	}
;;;68     	return 0;//两个字符串相等
;;;69     }
00000e  4770              BX       lr
                  |L1.16|
000010  7810              LDRB     r0,[r2,#0]            ;64
000012  b900              CBNZ     r0,|L1.22|
000014  e002              B        |L1.28|
                  |L1.22|
000016  1c52              ADDS     r2,r2,#1              ;65
000018  1c49              ADDS     r1,r1,#1              ;66
                  |L1.26|
00001a  e7f3              B        |L1.4|
                  |L1.28|
00001c  bf00              NOP                            ;64
00001e  2000              MOVS     r0,#0                 ;68
000020  e7f5              B        |L1.14|
;;;70     //把str1的内容copy到str2
                          ENDP

                  usmart_strcopy PROC
;;;72     //*str2:字符串2指针			   
;;;73     void usmart_strcopy(u8*str1,u8 *str2)
000022  e006              B        |L1.50|
                  |L1.36|
;;;74     {
;;;75     	while(1)
;;;76     	{										   
;;;77     		*str2=*str1;	//拷贝
000024  7802              LDRB     r2,[r0,#0]
000026  700a              STRB     r2,[r1,#0]
;;;78     		if(*str1=='\0')break;//拷贝完成了.
000028  7802              LDRB     r2,[r0,#0]
00002a  b902              CBNZ     r2,|L1.46|
00002c  e002              B        |L1.52|
                  |L1.46|
;;;79     		str1++;
00002e  1c40              ADDS     r0,r0,#1
;;;80     		str2++;
000030  1c49              ADDS     r1,r1,#1
                  |L1.50|
000032  e7f7              B        |L1.36|
                  |L1.52|
000034  bf00              NOP                            ;78
;;;81     	}
;;;82     }
000036  4770              BX       lr
;;;83     //得到字符串的长度(字节)
                          ENDP

                  usmart_strlen PROC
;;;85     //返回值:字符串的长度		   
;;;86     u8 usmart_strlen(u8*str)
000038  4601              MOV      r1,r0
;;;87     {
;;;88     	u8 len=0;
00003a  2000              MOVS     r0,#0
;;;89     	while(1)
00003c  e005              B        |L1.74|
                  |L1.62|
;;;90     	{							 
;;;91     		if(*str=='\0')break;//拷贝完成了.
00003e  780a              LDRB     r2,[r1,#0]
000040  b902              CBNZ     r2,|L1.68|
000042  e003              B        |L1.76|
                  |L1.68|
;;;92     		len++;
000044  1c42              ADDS     r2,r0,#1
000046  b2d0              UXTB     r0,r2
;;;93     		str++;
000048  1c49              ADDS     r1,r1,#1
                  |L1.74|
00004a  e7f8              B        |L1.62|
                  |L1.76|
00004c  bf00              NOP                            ;91
;;;94     	}
;;;95     	return len;
;;;96     }
00004e  4770              BX       lr
;;;97     //m^n函数
                          ENDP

                  usmart_pow PROC
;;;98     //返回值:m^n次方
;;;99     u32 usmart_pow(u8 m,u8 n)
000050  b510              PUSH     {r4,lr}
;;;100    {
000052  4602              MOV      r2,r0
;;;101    	u32 result=1;	 
000054  2001              MOVS     r0,#1
;;;102    	while(n--)result*=m;    
000056  e000              B        |L1.90|
                  |L1.88|
000058  4350              MULS     r0,r2,r0
                  |L1.90|
00005a  000b              MOVS     r3,r1
00005c  f1a10401          SUB      r4,r1,#1
000060  b2e1              UXTB     r1,r4
000062  d1f9              BNE      |L1.88|
;;;103    	return result;
;;;104    }	    
000064  bd10              POP      {r4,pc}
;;;105    //把字符串转为数字
                          ENDP

                  usmart_str2num PROC
;;;111    //1,数据格式错误.2,16进制位数为0.3,起始格式错误.4,十进制位数为0.
;;;112    u8 usmart_str2num(u8*str,u32 *res)
000066  e92d43f0          PUSH     {r4-r9,lr}
;;;113    {
00006a  4604              MOV      r4,r0
00006c  460d              MOV      r5,r1
;;;114    	u32 t;
;;;115    	u8 bnum=0;	//数字的位数
00006e  2700              MOVS     r7,#0
;;;116    	u8 *p;		  
;;;117    	u8 hexdec=10;//默认为十进制数据
000070  f04f090a          MOV      r9,#0xa
;;;118    	p=str;
000074  46a0              MOV      r8,r4
;;;119    	*res=0;//清零.
000076  2000              MOVS     r0,#0
000078  6028              STR      r0,[r5,#0]
;;;120    	while(1)
00007a  e027              B        |L1.204|
                  |L1.124|
;;;121    	{
;;;122    		if((*p<='9'&&*p>='0')||(*p<='F'&&*p>='A')||(*p=='X'&&bnum==1))//参数合法
00007c  f8980000          LDRB     r0,[r8,#0]
000080  2839              CMP      r0,#0x39
000082  dc03              BGT      |L1.140|
000084  f8980000          LDRB     r0,[r8,#0]
000088  2830              CMP      r0,#0x30
00008a  da0d              BGE      |L1.168|
                  |L1.140|
00008c  f8980000          LDRB     r0,[r8,#0]
000090  2846              CMP      r0,#0x46
000092  dc03              BGT      |L1.156|
000094  f8980000          LDRB     r0,[r8,#0]
000098  2841              CMP      r0,#0x41
00009a  da05              BGE      |L1.168|
                  |L1.156|
00009c  f8980000          LDRB     r0,[r8,#0]
0000a0  2858              CMP      r0,#0x58
0000a2  d10a              BNE      |L1.186|
0000a4  2f01              CMP      r7,#1
0000a6  d108              BNE      |L1.186|
                  |L1.168|
;;;123    		{
;;;124    			if(*p>='A')hexdec=16;	//字符串中存在字母,为16进制格式.
0000a8  f8980000          LDRB     r0,[r8,#0]
0000ac  2841              CMP      r0,#0x41
0000ae  db01              BLT      |L1.180|
0000b0  f04f0910          MOV      r9,#0x10
                  |L1.180|
;;;125    			bnum++;					//位数增加.
0000b4  1c78              ADDS     r0,r7,#1
0000b6  b2c7              UXTB     r7,r0
0000b8  e006              B        |L1.200|
                  |L1.186|
;;;126    		}else if(*p=='\0')break;	//碰到结束符,退出.
0000ba  f8980000          LDRB     r0,[r8,#0]
0000be  b900              CBNZ     r0,|L1.194|
0000c0  e005              B        |L1.206|
                  |L1.194|
;;;127    		else return 1;				//不全是十进制或者16进制数据.
0000c2  2001              MOVS     r0,#1
                  |L1.196|
;;;128    		p++; 
;;;129    	} 
;;;130    	p=str;			    //重新定位到字符串开始的地址.
;;;131    	if(hexdec==16)		//16进制数据
;;;132    	{
;;;133    		if(bnum<3)return 2;			//位数小于3，直接退出.因为0X就占了2个,如果0X后面不跟数据,则该数据非法.
;;;134    		if(*p=='0' && (*(p+1)=='X'))//必须以'0X'开头.
;;;135    		{
;;;136    			p+=2;	//偏移到数据起始地址.
;;;137    			bnum-=2;//减去偏移量	 
;;;138    		}else return 3;//起始头的格式不对
;;;139    	}else if(bnum==0)return 4;//位数为0，直接退出.	  
;;;140    	while(1)
;;;141    	{
;;;142    		if(bnum)bnum--;
;;;143    		if(*p<='9'&&*p>='0')t=*p-'0';	//得到数字的值
;;;144    		else t=*p-'A'+10;				//得到A~F对应的值	    
;;;145    		*res+=t*usmart_pow(hexdec,bnum);		   
;;;146    		p++;
;;;147    		if(*p=='\0')break;//数据都查完了.	
;;;148    	}
;;;149    	return 0;//成功转换
;;;150    }
0000c4  e8bd83f0          POP      {r4-r9,pc}
                  |L1.200|
0000c8  f1080801          ADD      r8,r8,#1              ;128
                  |L1.204|
0000cc  e7d6              B        |L1.124|
                  |L1.206|
0000ce  bf00              NOP                            ;126
0000d0  46a0              MOV      r8,r4                 ;130
0000d2  f1b90f10          CMP      r9,#0x10              ;131
0000d6  d112              BNE      |L1.254|
0000d8  2f03              CMP      r7,#3                 ;133
0000da  da01              BGE      |L1.224|
0000dc  2002              MOVS     r0,#2                 ;133
0000de  e7f1              B        |L1.196|
                  |L1.224|
0000e0  f8980000          LDRB     r0,[r8,#0]            ;134
0000e4  2830              CMP      r0,#0x30              ;134
0000e6  d108              BNE      |L1.250|
0000e8  f8980001          LDRB     r0,[r8,#1]            ;134
0000ec  2858              CMP      r0,#0x58              ;134
0000ee  d104              BNE      |L1.250|
0000f0  f1080802          ADD      r8,r8,#2              ;136
0000f4  1eb8              SUBS     r0,r7,#2              ;137
0000f6  b2c7              UXTB     r7,r0                 ;137
0000f8  e004              B        |L1.260|
                  |L1.250|
0000fa  2003              MOVS     r0,#3                 ;138
0000fc  e7e2              B        |L1.196|
                  |L1.254|
0000fe  b90f              CBNZ     r7,|L1.260|
000100  2004              MOVS     r0,#4                 ;139
000102  e7df              B        |L1.196|
                  |L1.260|
000104  e021              B        |L1.330|
                  |L1.262|
000106  b10f              CBZ      r7,|L1.268|
000108  1e78              SUBS     r0,r7,#1              ;142
00010a  b2c7              UXTB     r7,r0                 ;142
                  |L1.268|
00010c  f8980000          LDRB     r0,[r8,#0]            ;143
000110  2839              CMP      r0,#0x39              ;143
000112  dc08              BGT      |L1.294|
000114  f8980000          LDRB     r0,[r8,#0]            ;143
000118  2830              CMP      r0,#0x30              ;143
00011a  db04              BLT      |L1.294|
00011c  f8980000          LDRB     r0,[r8,#0]            ;143
000120  f1a00630          SUB      r6,r0,#0x30           ;143
000124  e003              B        |L1.302|
                  |L1.294|
000126  f8980000          LDRB     r0,[r8,#0]            ;144
00012a  f1a00637          SUB      r6,r0,#0x37           ;144
                  |L1.302|
00012e  4639              MOV      r1,r7                 ;145
000130  4648              MOV      r0,r9                 ;145
000132  f7fffffe          BL       usmart_pow
000136  6829              LDR      r1,[r5,#0]            ;145
000138  fb061000          MLA      r0,r6,r0,r1           ;145
00013c  6028              STR      r0,[r5,#0]            ;145
00013e  f1080801          ADD      r8,r8,#1              ;146
000142  f8980000          LDRB     r0,[r8,#0]            ;147
000146  b900              CBNZ     r0,|L1.330|
000148  e000              B        |L1.332|
                  |L1.330|
00014a  e7dc              B        |L1.262|
                  |L1.332|
00014c  bf00              NOP                            ;147
00014e  2000              MOVS     r0,#0                 ;149
000150  e7b8              B        |L1.196|
;;;151    //得到指令名
                          ENDP

                  usmart_get_cmdname PROC
;;;156    //返回值:0,成功;其他,失败.	  
;;;157    u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen)
000152  b510              PUSH     {r4,lr}
;;;158    {
000154  4604              MOV      r4,r0
;;;159    	*nlen=0;
000156  2000              MOVS     r0,#0
000158  7010              STRB     r0,[r2,#0]
;;;160     	while(*str!=' '&&*str!='\0') //找到空格或者结束符则认为结束了
00015a  e00b              B        |L1.372|
                  |L1.348|
;;;161    	{
;;;162    		*cmdname=*str;
00015c  7820              LDRB     r0,[r4,#0]
00015e  7008              STRB     r0,[r1,#0]
;;;163    		str++;
000160  1c64              ADDS     r4,r4,#1
;;;164    		cmdname++;
000162  1c49              ADDS     r1,r1,#1
;;;165    		(*nlen)++;//统计命令长度
000164  7810              LDRB     r0,[r2,#0]
000166  1c40              ADDS     r0,r0,#1
000168  7010              STRB     r0,[r2,#0]
;;;166    		if(*nlen>=maxlen)return 1;//错误的指令
00016a  7810              LDRB     r0,[r2,#0]
00016c  4298              CMP      r0,r3
00016e  db01              BLT      |L1.372|
000170  2001              MOVS     r0,#1
                  |L1.370|
;;;167    	}
;;;168    	*cmdname='\0';//加入结束符
;;;169    	return 0;//正常返回
;;;170    }
000172  bd10              POP      {r4,pc}
                  |L1.372|
000174  7820              LDRB     r0,[r4,#0]            ;160
000176  2820              CMP      r0,#0x20              ;160
000178  d002              BEQ      |L1.384|
00017a  7820              LDRB     r0,[r4,#0]            ;160
00017c  2800              CMP      r0,#0                 ;160
00017e  d1ed              BNE      |L1.348|
                  |L1.384|
000180  2000              MOVS     r0,#0                 ;168
000182  7008              STRB     r0,[r1,#0]            ;168
000184  e7f5              B        |L1.370|
;;;171    //获取下一个字符（当中间有很多空格的时候，此函数直接忽略空格，找到空格之后的第一个字符）
                          ENDP

                  usmart_search_nextc PROC
;;;173    //返回值:下一个字符
;;;174    u8 usmart_search_nextc(u8* str)
000186  4601              MOV      r1,r0
;;;175    {		   	 	
;;;176    	str++;
000188  1c49              ADDS     r1,r1,#1
;;;177    	while(*str==' '&&str!='\0')str++;
00018a  e000              B        |L1.398|
                  |L1.396|
00018c  1c49              ADDS     r1,r1,#1
                  |L1.398|
00018e  7808              LDRB     r0,[r1,#0]
000190  2820              CMP      r0,#0x20
000192  d101              BNE      |L1.408|
000194  2900              CMP      r1,#0
000196  d1f9              BNE      |L1.396|
                  |L1.408|
;;;178    	return *str;
000198  7808              LDRB     r0,[r1,#0]
;;;179    } 
00019a  4770              BX       lr
;;;180    //从str中得到函数名
                          ENDP

                  usmart_get_fname PROC
;;;185    //返回值:0,成功;其他,错误代码.
;;;186    u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval)
00019c  e92d4fff          PUSH     {r0-r11,lr}
;;;187    {
0001a0  b086              SUB      sp,sp,#0x18
0001a2  4604              MOV      r4,r0
0001a4  460d              MOV      r5,r1
0001a6  461e              MOV      r6,r3
;;;188    	u8 res;
;;;189    	u8 fover=0;	  //括号深度
0001a8  f04f0800          MOV      r8,#0
;;;190    	u8 *strtemp;
;;;191    	u8 offset=0;  
0001ac  2000              MOVS     r0,#0
0001ae  9005              STR      r0,[sp,#0x14]
;;;192    	u8 parmnum=0;
0001b0  4682              MOV      r10,r0
;;;193    	u8 temp=1;
0001b2  2001              MOVS     r0,#1
0001b4  9004              STR      r0,[sp,#0x10]
;;;194    	u8 fpname[6];//void+X+'/0'
;;;195    	u8 fplcnt=0; //第一个参数的长度计数器
0001b6  2000              MOVS     r0,#0
0001b8  9001              STR      r0,[sp,#4]
;;;196    	u8 pcnt=0;	 //参数计数器
0001ba  9000              STR      r0,[sp,#0]
;;;197    	u8 nchar;
;;;198    	//判断函数是否有返回值
;;;199    	strtemp=str;
0001bc  46a1              MOV      r9,r4
;;;200    	while(*strtemp!='\0')//没有结束
0001be  e02a              B        |L1.534|
                  |L1.448|
;;;201    	{
;;;202    		if(*strtemp!=' '&&(pcnt&0X7F)<5)//最多记录5个字符
0001c0  f8990000          LDRB     r0,[r9,#0]
0001c4  2820              CMP      r0,#0x20
0001c6  d020              BEQ      |L1.522|
0001c8  9800              LDR      r0,[sp,#0]
0001ca  f000007f          AND      r0,r0,#0x7f
0001ce  2805              CMP      r0,#5
0001d0  da1b              BGE      |L1.522|
;;;203    		{	
;;;204    			if(pcnt==0)pcnt|=0X80;//置位最高位,标记开始接收返回值类型
0001d2  9800              LDR      r0,[sp,#0]
0001d4  b918              CBNZ     r0,|L1.478|
0001d6  9800              LDR      r0,[sp,#0]
0001d8  f0400080          ORR      r0,r0,#0x80
0001dc  9000              STR      r0,[sp,#0]
                  |L1.478|
;;;205    			if(((pcnt&0x7f)==4)&&(*strtemp!='*'))break;//最后一个字符,必须是*
0001de  9800              LDR      r0,[sp,#0]
0001e0  f000007f          AND      r0,r0,#0x7f
0001e4  2804              CMP      r0,#4
0001e6  d104              BNE      |L1.498|
0001e8  f8990000          LDRB     r0,[r9,#0]
0001ec  282a              CMP      r0,#0x2a
0001ee  d000              BEQ      |L1.498|
0001f0  e015              B        |L1.542|
                  |L1.498|
;;;206    			fpname[pcnt&0x7f]=*strtemp;//记录函数的返回值类型
0001f2  f8990000          LDRB     r0,[r9,#0]
0001f6  9900              LDR      r1,[sp,#0]
0001f8  f001017f          AND      r1,r1,#0x7f
0001fc  aa02              ADD      r2,sp,#8
0001fe  5450              STRB     r0,[r2,r1]
;;;207    			pcnt++;
000200  9800              LDR      r0,[sp,#0]
000202  1c40              ADDS     r0,r0,#1
000204  b2c0              UXTB     r0,r0
000206  9000              STR      r0,[sp,#0]
000208  e003              B        |L1.530|
                  |L1.522|
;;;208    		}else if(pcnt==0X85)break;
00020a  9800              LDR      r0,[sp,#0]
00020c  2885              CMP      r0,#0x85
00020e  d100              BNE      |L1.530|
000210  e005              B        |L1.542|
                  |L1.530|
;;;209    		strtemp++; 
000212  f1090901          ADD      r9,r9,#1
                  |L1.534|
000216  f8990000          LDRB     r0,[r9,#0]            ;200
00021a  2800              CMP      r0,#0                 ;200
00021c  d1d0              BNE      |L1.448|
                  |L1.542|
00021e  bf00              NOP                            ;205
;;;210    	} 
;;;211    	if(pcnt)//接收完了
000220  9800              LDR      r0,[sp,#0]
000222  b188              CBZ      r0,|L1.584|
;;;212    	{
;;;213    		fpname[pcnt&0x7f]='\0';//加入结束符
000224  2000              MOVS     r0,#0
000226  9900              LDR      r1,[sp,#0]
000228  f001017f          AND      r1,r1,#0x7f
00022c  aa02              ADD      r2,sp,#8
00022e  5450              STRB     r0,[r2,r1]
;;;214    		if(usmart_strcmp(fpname,"void")==0)*rval=0;//不需要返回值
000230  a1dc              ADR      r1,|L1.1444|
000232  a802              ADD      r0,sp,#8
000234  f7fffffe          BL       usmart_strcmp
000238  b910              CBNZ     r0,|L1.576|
00023a  2000              MOVS     r0,#0
00023c  7030              STRB     r0,[r6,#0]
00023e  e001              B        |L1.580|
                  |L1.576|
;;;215    		else *rval=1;							   //需要返回值
000240  2001              MOVS     r0,#1
000242  7030              STRB     r0,[r6,#0]
                  |L1.580|
;;;216    		pcnt=0;
000244  2000              MOVS     r0,#0
000246  9000              STR      r0,[sp,#0]
                  |L1.584|
;;;217    	} 
;;;218    	res=0;
000248  2700              MOVS     r7,#0
;;;219    	strtemp=str;
00024a  46a1              MOV      r9,r4
;;;220    	while(*strtemp!='('&&*strtemp!='\0') //此代码找到函数名的真正起始位置
00024c  e016              B        |L1.636|
                  |L1.590|
;;;221    	{  
;;;222    		strtemp++;
00024e  f1090901          ADD      r9,r9,#1
;;;223    		res++;
000252  1c78              ADDS     r0,r7,#1
000254  b2c7              UXTB     r7,r0
;;;224    		if(*strtemp==' '||*strtemp=='*')
000256  f8990000          LDRB     r0,[r9,#0]
00025a  2820              CMP      r0,#0x20
00025c  d003              BEQ      |L1.614|
00025e  f8990000          LDRB     r0,[r9,#0]
000262  282a              CMP      r0,#0x2a
000264  d10a              BNE      |L1.636|
                  |L1.614|
;;;225    		{
;;;226    			nchar=usmart_search_nextc(strtemp);		//获取下一个字符
000266  4648              MOV      r0,r9
000268  f7fffffe          BL       usmart_search_nextc
00026c  4683              MOV      r11,r0
;;;227    			if(nchar!='('&&nchar!='*')offset=res;	//跳过空格和*号
00026e  f1bb0f28          CMP      r11,#0x28
000272  d003              BEQ      |L1.636|
000274  f1bb0f2a          CMP      r11,#0x2a
000278  d000              BEQ      |L1.636|
00027a  9705              STR      r7,[sp,#0x14]
                  |L1.636|
00027c  f8990000          LDRB     r0,[r9,#0]            ;220
000280  2828              CMP      r0,#0x28              ;220
000282  d003              BEQ      |L1.652|
000284  f8990000          LDRB     r0,[r9,#0]            ;220
000288  2800              CMP      r0,#0                 ;220
00028a  d1e0              BNE      |L1.590|
                  |L1.652|
;;;228    		}
;;;229    	}	 
;;;230    	strtemp=str;
00028c  46a1              MOV      r9,r4
;;;231    	if(offset)strtemp+=offset+1;//跳到函数名开始的地方	   
00028e  9805              LDR      r0,[sp,#0x14]
000290  b110              CBZ      r0,|L1.664|
000292  9805              LDR      r0,[sp,#0x14]
000294  1c40              ADDS     r0,r0,#1
000296  4481              ADD      r9,r9,r0
                  |L1.664|
;;;232    	res=0;
000298  2700              MOVS     r7,#0
;;;233    	nchar=0;//是否正在字符串里面的标志,0，不在字符串;1，在字符串;
00029a  46bb              MOV      r11,r7
;;;234    	while(1)
00029c  e071              B        |L1.898|
                  |L1.670|
;;;235    	{
;;;236    		if(*strtemp==0)
00029e  f8990000          LDRB     r0,[r9,#0]
0002a2  b908              CBNZ     r0,|L1.680|
;;;237    		{
;;;238    			res=USMART_FUNCERR;//函数错误
0002a4  2701              MOVS     r7,#1
;;;239    			break;
0002a6  e06d              B        |L1.900|
                  |L1.680|
;;;240    		}else if(*strtemp=='('&&nchar==0)fover++;//括号深度增加一级	 
0002a8  f8990000          LDRB     r0,[r9,#0]
0002ac  2828              CMP      r0,#0x28
0002ae  d107              BNE      |L1.704|
0002b0  f1bb0f00          CMP      r11,#0
0002b4  d104              BNE      |L1.704|
0002b6  f1080001          ADD      r0,r8,#1
0002ba  f00008ff          AND      r8,r0,#0xff
0002be  e01f              B        |L1.768|
                  |L1.704|
;;;241    		else if(*strtemp==')'&&nchar==0)
0002c0  f8990000          LDRB     r0,[r9,#0]
0002c4  2829              CMP      r0,#0x29
0002c6  d10f              BNE      |L1.744|
0002c8  f1bb0f00          CMP      r11,#0
0002cc  d10c              BNE      |L1.744|
;;;242    		{
;;;243    			if(fover)fover--;
0002ce  f1b80f00          CMP      r8,#0
0002d2  d004              BEQ      |L1.734|
0002d4  f1a80001          SUB      r0,r8,#1
0002d8  f00008ff          AND      r8,r0,#0xff
0002dc  e000              B        |L1.736|
                  |L1.734|
;;;244    			else res=USMART_FUNCERR;//错误结束,没收到'('
0002de  2701              MOVS     r7,#1
                  |L1.736|
;;;245    			if(fover==0)break;//到末尾了,退出	    
0002e0  f1b80f00          CMP      r8,#0
0002e4  d10c              BNE      |L1.768|
0002e6  e04d              B        |L1.900|
                  |L1.744|
;;;246    		}else if(*strtemp=='"')nchar=!nchar;
0002e8  f8990000          LDRB     r0,[r9,#0]
0002ec  2822              CMP      r0,#0x22
0002ee  d107              BNE      |L1.768|
0002f0  f1bb0f00          CMP      r11,#0
0002f4  d101              BNE      |L1.762|
0002f6  2001              MOVS     r0,#1
0002f8  e000              B        |L1.764|
                  |L1.762|
0002fa  2000              MOVS     r0,#0
                  |L1.764|
0002fc  f0000bff          AND      r11,r0,#0xff
                  |L1.768|
;;;247    
;;;248    		if(fover==0)//函数名还没接收完
000300  f1b80f00          CMP      r8,#0
000304  d108              BNE      |L1.792|
;;;249    		{
;;;250    			if(*strtemp!=' ')//空格不属于函数名
000306  f8990000          LDRB     r0,[r9,#0]
00030a  2820              CMP      r0,#0x20
00030c  d037              BEQ      |L1.894|
;;;251    			{
;;;252    				*fname=*strtemp;//得到函数名
00030e  f8990000          LDRB     r0,[r9,#0]
000312  7028              STRB     r0,[r5,#0]
;;;253    				fname++;
000314  1c6d              ADDS     r5,r5,#1
000316  e032              B        |L1.894|
                  |L1.792|
;;;254    			}
;;;255    		}else //已经接受完了函数名了.
;;;256    		{
;;;257    			if(*strtemp==',')
000318  f8990000          LDRB     r0,[r9,#0]
00031c  282c              CMP      r0,#0x2c
00031e  d106              BNE      |L1.814|
;;;258    			{
;;;259    				temp=1;		//使能增加一个参数
000320  2001              MOVS     r0,#1
000322  9004              STR      r0,[sp,#0x10]
;;;260    				pcnt++;	
000324  9800              LDR      r0,[sp,#0]
000326  1c40              ADDS     r0,r0,#1
000328  b2c0              UXTB     r0,r0
00032a  9000              STR      r0,[sp,#0]
00032c  e019              B        |L1.866|
                  |L1.814|
;;;261    			}else if(*strtemp!=' '&&*strtemp!='(')
00032e  f8990000          LDRB     r0,[r9,#0]
000332  2820              CMP      r0,#0x20
000334  d015              BEQ      |L1.866|
000336  f8990000          LDRB     r0,[r9,#0]
00033a  2828              CMP      r0,#0x28
00033c  d011              BEQ      |L1.866|
;;;262    			{
;;;263    				if(pcnt==0&&fplcnt<5)		//当第一个参数来时,为了避免统计void类型的参数,必须做判断.
00033e  9800              LDR      r0,[sp,#0]
000340  b958              CBNZ     r0,|L1.858|
000342  9801              LDR      r0,[sp,#4]
000344  2805              CMP      r0,#5
000346  da08              BGE      |L1.858|
;;;264    				{
;;;265    					fpname[fplcnt]=*strtemp;//记录参数特征.
000348  f8990000          LDRB     r0,[r9,#0]
00034c  a902              ADD      r1,sp,#8
00034e  9a01              LDR      r2,[sp,#4]
000350  5488              STRB     r0,[r1,r2]
;;;266    					fplcnt++;
000352  9801              LDR      r0,[sp,#4]
000354  1c40              ADDS     r0,r0,#1
000356  b2c0              UXTB     r0,r0
000358  9001              STR      r0,[sp,#4]
                  |L1.858|
;;;267    				}
;;;268    				temp++;	//得到有效参数(非空格)
00035a  9804              LDR      r0,[sp,#0x10]
00035c  1c40              ADDS     r0,r0,#1
00035e  b2c0              UXTB     r0,r0
000360  9004              STR      r0,[sp,#0x10]
                  |L1.866|
;;;269    			}
;;;270    			if(fover==1&&temp==2)
000362  f1b80f01          CMP      r8,#1
000366  d10a              BNE      |L1.894|
000368  9804              LDR      r0,[sp,#0x10]
00036a  2802              CMP      r0,#2
00036c  d107              BNE      |L1.894|
;;;271    			{
;;;272    				temp++;		//防止重复增加
00036e  9804              LDR      r0,[sp,#0x10]
000370  1c40              ADDS     r0,r0,#1
000372  b2c0              UXTB     r0,r0
000374  9004              STR      r0,[sp,#0x10]
;;;273    				parmnum++; 	//参数增加一个
000376  f10a0001          ADD      r0,r10,#1
00037a  f0000aff          AND      r10,r0,#0xff
                  |L1.894|
;;;274    			}
;;;275    		}
;;;276    		strtemp++; 			
00037e  f1090901          ADD      r9,r9,#1
                  |L1.898|
000382  e78c              B        |L1.670|
                  |L1.900|
000384  bf00              NOP                            ;239
;;;277    	}   
;;;278    	if(parmnum==1)//只有1个参数.
000386  f1ba0f01          CMP      r10,#1
00038a  d10a              BNE      |L1.930|
;;;279    	{
;;;280    		fpname[fplcnt]='\0';//加入结束符
00038c  2000              MOVS     r0,#0
00038e  a902              ADD      r1,sp,#8
000390  9a01              LDR      r2,[sp,#4]
000392  5488              STRB     r0,[r1,r2]
;;;281    		if(usmart_strcmp(fpname,"void")==0)parmnum=0;//参数为void,表示没有参数.
000394  a183              ADR      r1,|L1.1444|
000396  a802              ADD      r0,sp,#8
000398  f7fffffe          BL       usmart_strcmp
00039c  b908              CBNZ     r0,|L1.930|
00039e  f04f0a00          MOV      r10,#0
                  |L1.930|
;;;282    	}
;;;283    	*pnum=parmnum;	//记录参数个数
0003a2  9808              LDR      r0,[sp,#0x20]
0003a4  f880a000          STRB     r10,[r0,#0]
;;;284    	*fname='\0';	//加入结束符
0003a8  2000              MOVS     r0,#0
0003aa  7028              STRB     r0,[r5,#0]
;;;285    	return res;		//返回执行结果
0003ac  4638              MOV      r0,r7
;;;286    }
0003ae  b00a              ADD      sp,sp,#0x28
0003b0  e8bd8ff0          POP      {r4-r11,pc}
;;;287    
                          ENDP

                  usmart_get_aparm PROC
;;;293    //返回值:0,已经无参数了;其他,下一个参数的偏移量.
;;;294    u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype)
0003b4  b5f0              PUSH     {r4-r7,lr}
;;;295    {
0003b6  4603              MOV      r3,r0
;;;296    	u8 i=0;
0003b8  2000              MOVS     r0,#0
;;;297    	u8 enout=0;
0003ba  2400              MOVS     r4,#0
;;;298    	u8 type=0;//默认是数字
0003bc  2500              MOVS     r5,#0
;;;299    	u8 string=0; //标记str是否正在读
0003be  2600              MOVS     r6,#0
;;;300    	while(1)
0003c0  e04f              B        |L1.1122|
                  |L1.962|
;;;301    	{		    
;;;302    		if(*str==','&& string==0)enout=1;			//暂缓立即退出,目的是寻找下一个参数的起始地址
0003c2  781f              LDRB     r7,[r3,#0]
0003c4  2f2c              CMP      r7,#0x2c
0003c6  d101              BNE      |L1.972|
0003c8  b906              CBNZ     r6,|L1.972|
0003ca  2401              MOVS     r4,#1
                  |L1.972|
;;;303    		if((*str==')'||*str=='\0')&&string==0)break;//立即退出标识符
0003cc  781f              LDRB     r7,[r3,#0]
0003ce  2f29              CMP      r7,#0x29
0003d0  d001              BEQ      |L1.982|
0003d2  781f              LDRB     r7,[r3,#0]
0003d4  b90f              CBNZ     r7,|L1.986|
                  |L1.982|
0003d6  b906              CBNZ     r6,|L1.986|
0003d8  e044              B        |L1.1124|
                  |L1.986|
;;;304    		if(type==0)//默认是数字的
0003da  2d00              CMP      r5,#0
0003dc  d134              BNE      |L1.1096|
;;;305    		{
;;;306    			if((*str>='0' && *str<='9')||(*str>='a' && *str<='f')||(*str>='A' && *str<='F')||*str=='X'||*str=='x')//数字串检测
0003de  781f              LDRB     r7,[r3,#0]
0003e0  2f30              CMP      r7,#0x30
0003e2  db02              BLT      |L1.1002|
0003e4  781f              LDRB     r7,[r3,#0]
0003e6  2f39              CMP      r7,#0x39
0003e8  dd11              BLE      |L1.1038|
                  |L1.1002|
0003ea  781f              LDRB     r7,[r3,#0]
0003ec  2f61              CMP      r7,#0x61
0003ee  db02              BLT      |L1.1014|
0003f0  781f              LDRB     r7,[r3,#0]
0003f2  2f66              CMP      r7,#0x66
0003f4  dd0b              BLE      |L1.1038|
                  |L1.1014|
0003f6  781f              LDRB     r7,[r3,#0]
0003f8  2f41              CMP      r7,#0x41
0003fa  db02              BLT      |L1.1026|
0003fc  781f              LDRB     r7,[r3,#0]
0003fe  2f46              CMP      r7,#0x46
000400  dd05              BLE      |L1.1038|
                  |L1.1026|
000402  781f              LDRB     r7,[r3,#0]
000404  2f58              CMP      r7,#0x58
000406  d002              BEQ      |L1.1038|
000408  781f              LDRB     r7,[r3,#0]
00040a  2f78              CMP      r7,#0x78
00040c  d10c              BNE      |L1.1064|
                  |L1.1038|
;;;307    			{
;;;308    				if(enout)break;					//找到了下一个参数,直接退出.
00040e  b104              CBZ      r4,|L1.1042|
000410  e028              B        |L1.1124|
                  |L1.1042|
;;;309    				if(*str>='a')*fparm=*str-0X20;	//小写转换为大写
000412  781f              LDRB     r7,[r3,#0]
000414  2f61              CMP      r7,#0x61
000416  db03              BLT      |L1.1056|
000418  781f              LDRB     r7,[r3,#0]
00041a  3f20              SUBS     r7,r7,#0x20
00041c  700f              STRB     r7,[r1,#0]
00041e  e001              B        |L1.1060|
                  |L1.1056|
;;;310    				else *fparm=*str;		   		//小写或者数字保持不变
000420  781f              LDRB     r7,[r3,#0]
000422  700f              STRB     r7,[r1,#0]
                  |L1.1060|
;;;311    				fparm++;
000424  1c49              ADDS     r1,r1,#1
000426  e019              B        |L1.1116|
                  |L1.1064|
;;;312    			}else if(*str=='"')//找到字符串的开始标志
000428  781f              LDRB     r7,[r3,#0]
00042a  2f22              CMP      r7,#0x22
00042c  d104              BNE      |L1.1080|
;;;313    			{
;;;314    				if(enout)break;//找到,后才找到",认为结束了.
00042e  b104              CBZ      r4,|L1.1074|
000430  e018              B        |L1.1124|
                  |L1.1074|
;;;315    				type=1;
000432  2501              MOVS     r5,#1
;;;316    				string=1;//登记STRING 正在读了
000434  2601              MOVS     r6,#1
000436  e011              B        |L1.1116|
                  |L1.1080|
;;;317    			}else if(*str!=' '&&*str!=',')//发现非法字符,参数错误
000438  781f              LDRB     r7,[r3,#0]
00043a  2f20              CMP      r7,#0x20
00043c  d00e              BEQ      |L1.1116|
00043e  781f              LDRB     r7,[r3,#0]
000440  2f2c              CMP      r7,#0x2c
000442  d00b              BEQ      |L1.1116|
;;;318    			{
;;;319    				type=0XFF;
000444  25ff              MOVS     r5,#0xff
;;;320    				break;
000446  e00d              B        |L1.1124|
                  |L1.1096|
;;;321    			}
;;;322    		}else//string类
;;;323    		{
;;;324    			if(*str=='"')string=0;
000448  781f              LDRB     r7,[r3,#0]
00044a  2f22              CMP      r7,#0x22
00044c  d100              BNE      |L1.1104|
00044e  2600              MOVS     r6,#0
                  |L1.1104|
;;;325    			if(enout)break;					//找到了下一个参数,直接退出.
000450  b104              CBZ      r4,|L1.1108|
000452  e007              B        |L1.1124|
                  |L1.1108|
;;;326    			if(string)					    //字符串正在读
000454  b116              CBZ      r6,|L1.1116|
;;;327    			{	 
;;;328    				*fparm=*str;		   		//小写或者数字保持不变
000456  781f              LDRB     r7,[r3,#0]
000458  700f              STRB     r7,[r1,#0]
;;;329    				fparm++;
00045a  1c49              ADDS     r1,r1,#1
                  |L1.1116|
;;;330    			}	
;;;331    		}
;;;332    		i++;//偏移量增加
00045c  1c47              ADDS     r7,r0,#1
00045e  b2f8              UXTB     r0,r7
;;;333    		str++;
000460  1c5b              ADDS     r3,r3,#1
                  |L1.1122|
000462  e7ae              B        |L1.962|
                  |L1.1124|
000464  bf00              NOP                            ;303
;;;334    	}
;;;335    	*fparm='\0';	//加入结束符
000466  2700              MOVS     r7,#0
000468  700f              STRB     r7,[r1,#0]
;;;336    	*ptype=type;	//返回参数类型
00046a  7015              STRB     r5,[r2,#0]
;;;337    	return i;		//返回参数长度
;;;338    }
00046c  bdf0              POP      {r4-r7,pc}
;;;339    //得到指定参数的起始地址
                          ENDP

                  usmart_get_parmpos PROC
;;;341    //返回值:该参数的起始地址
;;;342    u8 usmart_get_parmpos(u8 num)
00046e  4601              MOV      r1,r0
;;;343    {
;;;344    	u8 temp=0;
000470  2000              MOVS     r0,#0
;;;345    	u8 i;
;;;346    	for(i=0;i<num;i++)temp+=usmart_dev.plentbl[i];
000472  2200              MOVS     r2,#0
000474  e005              B        |L1.1154|
                  |L1.1142|
000476  4b4d              LDR      r3,|L1.1452|
000478  5c9b              LDRB     r3,[r3,r2]
00047a  4403              ADD      r3,r3,r0
00047c  b2d8              UXTB     r0,r3
00047e  1c53              ADDS     r3,r2,#1
000480  b2da              UXTB     r2,r3
                  |L1.1154|
000482  428a              CMP      r2,r1
000484  dbf7              BLT      |L1.1142|
;;;347    	return temp;
;;;348    }
000486  4770              BX       lr
;;;349    //从str中得到函数参数
                          ENDP

                  usmart_get_fparam PROC
;;;352    //返回值:0,成功;其他,错误代码.
;;;353    u8 usmart_get_fparam(u8*str,u8 *parn)
000488  e92d43f0          PUSH     {r4-r9,lr}
;;;354    {	
00048c  b0b5              SUB      sp,sp,#0xd4
00048e  4604              MOV      r4,r0
000490  460d              MOV      r5,r1
;;;355    	u8 i,type;  
;;;356    	u32 res;
;;;357    	u8 n=0;
000492  f04f0800          MOV      r8,#0
;;;358    	u8 len;
;;;359    	u8 tstr[PARM_LEN+1];//字节长度的缓存,最多可以存放PARM_LEN个字符的字符串
;;;360    	for(i=0;i<MAX_PARM;i++)usmart_dev.plentbl[i]=0;//清空参数长度表
000496  2600              MOVS     r6,#0
000498  e004              B        |L1.1188|
                  |L1.1178|
00049a  2100              MOVS     r1,#0
00049c  4843              LDR      r0,|L1.1452|
00049e  5581              STRB     r1,[r0,r6]
0004a0  1c70              ADDS     r0,r6,#1
0004a2  b2c6              UXTB     r6,r0
                  |L1.1188|
0004a4  2e0a              CMP      r6,#0xa
0004a6  dbf8              BLT      |L1.1178|
;;;361    	while(*str!='(')//偏移到参数开始的地方
0004a8  e006              B        |L1.1208|
                  |L1.1194|
;;;362    	{
;;;363    		str++;											    
0004aa  1c64              ADDS     r4,r4,#1
;;;364    		if(*str=='\0')return USMART_FUNCERR;//遇到结束符了
0004ac  7820              LDRB     r0,[r4,#0]
0004ae  b918              CBNZ     r0,|L1.1208|
0004b0  2001              MOVS     r0,#1
                  |L1.1202|
;;;365    	}
;;;366    	str++;//偏移到"("之后的第一个字节
;;;367    	while(1)
;;;368    	{
;;;369    		i=usmart_get_aparm(str,tstr,&type);	//得到第一个参数  
;;;370    		str+=i;								//偏移
;;;371    		switch(type)
;;;372    		{
;;;373    			case 0:	//数字
;;;374    				if(tstr[0]!='\0')				//接收到的参数有效
;;;375    				{					    
;;;376    					i=usmart_str2num(tstr,&res);	//记录该参数	 
;;;377    					if(i)return USMART_PARMERR;		//参数错误.
;;;378    					*(u32*)(usmart_dev.parm+usmart_get_parmpos(n))=res;//记录转换成功的结果.
;;;379    					usmart_dev.parmtype&=~(1<<n);	//标记数字
;;;380    					usmart_dev.plentbl[n]=4;		//该参数的长度为4  
;;;381    					n++;							//参数增加  
;;;382    					if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;383    				}
;;;384    				break;
;;;385    			case 1://字符串	 	
;;;386    				len=usmart_strlen(tstr)+1;	//包含了结束符'\0'
;;;387    				usmart_strcopy(tstr,&usmart_dev.parm[usmart_get_parmpos(n)]);//拷贝tstr数据到usmart_dev.parm[n]
;;;388    				usmart_dev.parmtype|=1<<n;	//标记字符串 
;;;389    				usmart_dev.plentbl[n]=len;	//该参数的长度为len  
;;;390    				n++;
;;;391    				if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;392    				break;
;;;393    			case 0XFF://错误
;;;394    				return USMART_PARMERR;//参数错误	  
;;;395    		}
;;;396    		if(*str==')'||*str=='\0')break;//查到结束标志了.
;;;397    	}
;;;398    	*parn=n;	//记录参数的个数
;;;399    	return USMART_OK;//正确得到了参数
;;;400    }
0004b2  b035              ADD      sp,sp,#0xd4
0004b4  e8bd83f0          POP      {r4-r9,pc}
                  |L1.1208|
0004b8  7820              LDRB     r0,[r4,#0]            ;361
0004ba  2828              CMP      r0,#0x28              ;361
0004bc  d1f5              BNE      |L1.1194|
0004be  1c64              ADDS     r4,r4,#1              ;366
0004c0  e069              B        |L1.1430|
                  |L1.1218|
0004c2  aa34              ADD      r2,sp,#0xd0           ;369
0004c4  4669              MOV      r1,sp                 ;369
0004c6  4620              MOV      r0,r4                 ;369
0004c8  f7fffffe          BL       usmart_get_aparm
0004cc  4606              MOV      r6,r0                 ;369
0004ce  4434              ADD      r4,r4,r6              ;370
0004d0  f89d00d0          LDRB     r0,[sp,#0xd0]         ;371
0004d4  b120              CBZ      r0,|L1.1248|
0004d6  2801              CMP      r0,#1                 ;371
0004d8  d02c              BEQ      |L1.1332|
0004da  28ff              CMP      r0,#0xff              ;371
0004dc  d154              BNE      |L1.1416|
0004de  e051              B        |L1.1412|
                  |L1.1248|
0004e0  f89d0000          LDRB     r0,[sp,#0]            ;374
0004e4  b328              CBZ      r0,|L1.1330|
0004e6  a933              ADD      r1,sp,#0xcc           ;376
0004e8  4668              MOV      r0,sp                 ;376
0004ea  f7fffffe          BL       usmart_str2num
0004ee  4606              MOV      r6,r0                 ;376
0004f0  b10e              CBZ      r6,|L1.1270|
0004f2  2002              MOVS     r0,#2                 ;377
0004f4  e7dd              B        |L1.1202|
                  |L1.1270|
0004f6  4640              MOV      r0,r8                 ;378
0004f8  f7fffffe          BL       usmart_get_parmpos
0004fc  492b              LDR      r1,|L1.1452|
0004fe  310a              ADDS     r1,r1,#0xa            ;378
000500  9a33              LDR      r2,[sp,#0xcc]         ;378
000502  500a              STR      r2,[r1,r0]            ;378
000504  f1a10024          SUB      r0,r1,#0x24           ;379
000508  8b01              LDRH     r1,[r0,#0x18]         ;379  ; usmart_dev
00050a  2001              MOVS     r0,#1                 ;379
00050c  fa00f008          LSL      r0,r0,r8              ;379
000510  4381              BICS     r1,r1,r0              ;379
000512  4826              LDR      r0,|L1.1452|
000514  381a              SUBS     r0,r0,#0x1a           ;379
000516  8301              STRH     r1,[r0,#0x18]         ;379
000518  2104              MOVS     r1,#4                 ;380
00051a  301a              ADDS     r0,r0,#0x1a           ;380
00051c  f8001008          STRB     r1,[r0,r8]            ;380
000520  f1080001          ADD      r0,r8,#1              ;381
000524  f00008ff          AND      r8,r0,#0xff           ;381
000528  f1b80f0a          CMP      r8,#0xa               ;382
00052c  dd01              BLE      |L1.1330|
00052e  2003              MOVS     r0,#3                 ;382
000530  e7bf              B        |L1.1202|
                  |L1.1330|
000532  e029              B        |L1.1416|
                  |L1.1332|
000534  4668              MOV      r0,sp                 ;386
000536  f7fffffe          BL       usmart_strlen
00053a  1c40              ADDS     r0,r0,#1              ;386
00053c  b2c7              UXTB     r7,r0                 ;386
00053e  4640              MOV      r0,r8                 ;387
000540  f7fffffe          BL       usmart_get_parmpos
000544  4919              LDR      r1,|L1.1452|
000546  310a              ADDS     r1,r1,#0xa            ;387
000548  eb000901          ADD      r9,r0,r1              ;387
00054c  4649              MOV      r1,r9                 ;387
00054e  4668              MOV      r0,sp                 ;387
000550  f7fffffe          BL       usmart_strcopy
000554  4815              LDR      r0,|L1.1452|
000556  381a              SUBS     r0,r0,#0x1a           ;388
000558  8b01              LDRH     r1,[r0,#0x18]         ;388  ; usmart_dev
00055a  2001              MOVS     r0,#1                 ;388
00055c  fa00f008          LSL      r0,r0,r8              ;388
000560  4301              ORRS     r1,r1,r0              ;388
000562  b288              UXTH     r0,r1                 ;388
000564  4911              LDR      r1,|L1.1452|
000566  391a              SUBS     r1,r1,#0x1a           ;388
000568  8308              STRH     r0,[r1,#0x18]         ;388
00056a  4810              LDR      r0,|L1.1452|
00056c  f8007008          STRB     r7,[r0,r8]            ;389
000570  f1080001          ADD      r0,r8,#1              ;390
000574  f00008ff          AND      r8,r0,#0xff           ;390
000578  f1b80f0a          CMP      r8,#0xa               ;391
00057c  dd01              BLE      |L1.1410|
00057e  2003              MOVS     r0,#3                 ;391
000580  e797              B        |L1.1202|
                  |L1.1410|
000582  e001              B        |L1.1416|
                  |L1.1412|
000584  2002              MOVS     r0,#2                 ;394
000586  e794              B        |L1.1202|
                  |L1.1416|
000588  bf00              NOP                            ;384
00058a  7820              LDRB     r0,[r4,#0]            ;396
00058c  2829              CMP      r0,#0x29              ;396
00058e  d001              BEQ      |L1.1428|
000590  7820              LDRB     r0,[r4,#0]            ;396
000592  b900              CBNZ     r0,|L1.1430|
                  |L1.1428|
000594  e000              B        |L1.1432|
                  |L1.1430|
000596  e794              B        |L1.1218|
                  |L1.1432|
000598  bf00              NOP                            ;396
00059a  f8858000          STRB     r8,[r5,#0]            ;398
00059e  2000              MOVS     r0,#0                 ;399
0005a0  e787              B        |L1.1202|
;;;401    
                          ENDP

0005a2  0000              DCW      0x0000
                  |L1.1444|
0005a4  766f696400        DCB      "void",0
0005a9  00                DCB      0
0005aa  00                DCB      0
0005ab  00                DCB      0
                  |L1.1452|
                          DCD      usmart_dev+0x1a
